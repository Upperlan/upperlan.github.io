<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="几个宏观上的理解 从直觉上理解，两阶段模型做了粗挑+精挑的操作。 那在目标物体的召回率上会有所下降，在精确率上会有所提升。单阶段模型只有一个阶段，在物体的召回率上会比较高，但在精确率上会有所下降。 业务上会根据需求来挑模型，如果要求高精度，就用frcnn，精度和性能平衡，就用yolo。  YOLOv11.概述YOLO是一个单独的end-to-end网络，其本质是吧目标检测问题当做一个回归问题去解">
<meta property="og:type" content="article">
<meta property="og:title" content="YOLO系列模型">
<meta property="og:url" content="http://example.com/2021/11/02/YOLO%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B/index.html">
<meta property="og:site_name" content="Upperlan">
<meta property="og:description" content="几个宏观上的理解 从直觉上理解，两阶段模型做了粗挑+精挑的操作。 那在目标物体的召回率上会有所下降，在精确率上会有所提升。单阶段模型只有一个阶段，在物体的召回率上会比较高，但在精确率上会有所下降。 业务上会根据需求来挑模型，如果要求高精度，就用frcnn，精度和性能平衡，就用yolo。  YOLOv11.概述YOLO是一个单独的end-to-end网络，其本质是吧目标检测问题当做一个回归问题去解">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2021/11/02/YOLO%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B/image-20220305211422793.png">
<meta property="og:image" content="http://example.com/2021/11/02/YOLO%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B/image-20220314150921131-7241762.png">
<meta property="og:image" content="http://example.com/2021/11/02/YOLO%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B/anchor_offset.png">
<meta property="og:image" content="http://example.com/2021/11/02/YOLO%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B/darknet.png">
<meta property="og:image" content="http://example.com/2021/11/02/YOLO%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B/image-20220314155601017-7244563.png">
<meta property="og:image" content="http://example.com/2021/11/02/YOLO%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B/image-20220314155700031-7244621.png">
<meta property="og:image" content="http://example.com/2021/11/02/YOLO%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B/image-20220314155726577-7244651.png">
<meta property="og:image" content="http://example.com/2021/11/02/YOLO%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B/image-20220314155800077-7244681.png">
<meta property="og:image" content="http://example.com/2021/11/02/YOLO%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B/image-20220314160013157-7244814.png">
<meta property="og:image" content="http://example.com/2021/11/02/YOLO%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B/image-20220314160406858-7245052.png">
<meta property="og:image" content="http://example.com/2021/11/02/YOLO%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B/image-20220314160454314-7245095.png">
<meta property="og:image" content="http://example.com/2021/11/02/YOLO%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B/image-20220314160946001-7245388.png">
<meta property="og:image" content="http://example.com/2021/11/02/YOLO%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B/image-20220314161210057-7245531.png">
<meta property="og:image" content="http://example.com/2021/11/02/YOLO%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B/image-20220314163109996.png">
<meta property="og:image" content="http://example.com/2021/11/02/YOLO%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B/GIOU.png">
<meta property="og:image" content="http://example.com/2021/11/02/YOLO%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B/diou.png">
<meta property="article:published_time" content="2021-11-02T12:40:25.000Z">
<meta property="article:modified_time" content="2022-03-14T09:23:41.518Z">
<meta property="article:author" content="篮球架上打砖块">
<meta property="article:tag" content="实习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/11/02/YOLO%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B/image-20220305211422793.png">

<link rel="canonical" href="http://example.com/2021/11/02/YOLO%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>YOLO系列模型 | Upperlan</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Upperlan</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/02/YOLO%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="篮球架上打砖块">
      <meta itemprop="description" content="Apodidae">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Upperlan">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          YOLO系列模型
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-02 20:40:25" itemprop="dateCreated datePublished" datetime="2021-11-02T20:40:25+08:00">2021-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-14 17:23:41" itemprop="dateModified" datetime="2022-03-14T17:23:41+08:00">2022-03-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/" itemprop="url" rel="index"><span itemprop="name">目标检测</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <span id="more"></span>
<h3 id="几个宏观上的理解"><a href="#几个宏观上的理解" class="headerlink" title="几个宏观上的理解"></a>几个宏观上的理解</h3><ul>
<li>从直觉上理解，两阶段模型做了粗挑+精挑的操作。 那在目标物体的召回率上会有所下降，在精确率上会有所提升。<br>单阶段模型只有一个阶段，在物体的召回率上会比较高，但在精确率上会有所下降。</li>
<li>业务上会根据需求来挑模型，如果要求高精度，就用frcnn，精度和性能平衡，就用yolo。</li>
</ul>
<h2 id="YOLOv1"><a href="#YOLOv1" class="headerlink" title="YOLOv1"></a>YOLOv1</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>YOLO是一个单独的end-to-end网络，其本质是吧目标检测问题当做一个回归问题去解决。</p>
<p>整体模型图如下：</p>
<p><img src="image-20220305211422793.png" alt="image-20220305211422793"></p>
<h4 id="backbone"><a href="#backbone" class="headerlink" title="backbone"></a>backbone</h4><p>基于GoogLeNet model，24个卷积层和两个全连接层，前20层在image1000上预训练，然后连上剩下的卷积层和全连接层再训练。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>是一个unified模型即整体性-&gt;把识别bbox，识别标签两个功能集成到一个网络中</p>
</li>
<li><p>训练时能够看到整个图片-&gt;即端到端，输出层是从整个特征图，其中每个位置上的通道就反应了这个位置的图像特征，因此yolo会比rcnn更少犯背景识别错误<br>注解：和两阶段检测模型不同，两阶段模型是先筛选ROI区域，此时卷积还不够深，还比较浅所以容易误识别背景为目标提取出来了；单阶段模型输出的特征图反应的是感受野区域上与目标物体相关的信息，输出时层数更深，所以对背景和物体的分辨能力更强，不容易犯背景误识别的错误。</p>
</li>
<li><p>学习的是总体上的特征-&gt;对于输入的鲁棒性强</p>
</li>
<li><p>虽然精度离其他模型还有一些差距，但是贵在快</p>
</li>
</ul>
<p>最后训练完备的模型推理时的输出：</p>
<ul>
<li><p>输入：原始图像resize后的图像</p>
</li>
<li><p>输出：物体位置和类别</p>
</li>
</ul>
<p><strong>注意：</strong> RCNN系列模型是将检测模块分为两部分，物体类别是一个分类问题；物体位置（即求bbox）是个回归问题</p>
<h4 id="2-1输入输出定义"><a href="#2-1输入输出定义" class="headerlink" title="2.1输入输出定义"></a>2.1输入输出定义</h4><p>输入：一个batch的image，shape是[batch_size,3,448,448]</p>
<p>输出：shape是[batch_size，Bboxs * 5 + Classes，size， size]</p>
<p>把图像分成S * S个grid cell，当有物体的中心落到一个cell中时（怎么判断？-&gt;confidence值），这个cell就要负责检测这个物体。每个cell要预测B个bbox，每个bbox都有一个相应的confidence</p>
<p>预测时，每个Bounding box包含五个数据值：</p>
<ul>
<li><p>x,y为当前格子预测到的物体的bbox中心位置坐标。</p>
</li>
<li><p>w和y为这个格子的高度和宽度</p>
</li>
<li><p>confidence反应当前bbox包含物体的置信概率</p>
</li>
</ul>
<p>confidence = P(object) * IOU(交并比)</p>
<p>若包含物体，P（）=1，否则为0。所以预测时输出的p值就是预测了这个bbox和object的IoU</p>
<p>每个grid cell预测C个种类，每个种类有个概率P值，每个grid cell只输出一组预测值</p>
<p>条件概率P（class i | Object）这个概率是基于grid cell包含object的概率为前提的，所以P（class i）=P（class i | Object）* P（object）</p>
<p>最后得到class-specific confidence = P（class i） * IOU，这个值说明了box中出现相应类的概率，也表征了预测的bbox对目标的拟合程度</p>
<p>所以输出的维数是S <em> S </em> （B * 5 + C）</p>
<p>在test时，在object所在的grid cell，yolo每次都会预测许多bbox，每个预测bbox都包含了一个预测的IOU大小，选取有更大IOU的bbox就会被选出来成为检测出来的框，预测的类别是每个grid cell中最大的那个Ci值</p>
<h4 id="2-2-损失函数"><a href="#2-2-损失函数" class="headerlink" title="2.2 损失函数"></a>2.2 损失函数</h4><p>损失分为两部分，bbox和种类预测。如果设为相同比重来构成总得损失函数不太理想-&gt;因为有的grid cell并不包含有效内容-&gt;影响了（overpower）包含目标物体的cell的梯度信息，导致confidence很低，所以将bbox损失的权重调整为5，confidence损失的权重调整为0.5。（应该是调出来的值）这样的直接结果就是大bbox中小的偏差相对于小bbox中小的偏差对损失影响较小。-&gt;为了实现这个目的，我们预测的值是width和height值的平方根</p>
<p><img src="image-20220314150921131-7241762.png" alt="image-20220314150921131"></p>
<h3 id="3训练过程"><a href="#3训练过程" class="headerlink" title="3训练过程"></a>3训练过程</h3><p>YOLO模型训练分为两步：</p>
<p>1）预训练。使用ImageNet 1000类数据训练YOLO网络的前20个卷积层+1个average池化层+1个全连接层。训练图像分辨率resize到224x224。训练一周，单个corp（应该是边框预测）88% top5准确率</p>
<p>2）用步骤1）得到的前20个卷积层网络参数来初始化YOLO模型前20个卷积层的网络参数，加四个卷积层和两个全连接层，随机初始化这几层的权重，然后用VOC 20类标注数据进行YOLO模型训练。为提高图像精度，在训练检测模型时，将输入图像分辨率resize到448x448。</p>
<p>3）最后一层的输出是归一化后的width和height，x，y</p>
<p>NOTE：只有当object在相应cell中时才会有分类损失，也只有最高IOU的predictor找到后才会有bbox相应的损失惩罚</p>
<p>训练时一开始学习率要小一点，慢慢升高，最后再降下来</p>
<p>使用了dropout来尽量避免过拟合</p>
<p>非极大抑制（non-maximal suppression）解决检测结果中，有多个区域重叠问题，增大了ap</p>
<h4 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a>Limitation</h4><p>由于空间约束的原因，很难识别小的成群的目标</p>
<p>采用的特征相对比较粗糙</p>
<p>对于小目标的的识别可能定位不太准确</p>
<h4 id="模型对比"><a href="#模型对比" class="headerlink" title="模型对比"></a>模型对比</h4><p>RCNN使用一个region proposals来候选出待识别的对象，再用selective Search来生成大概2k个bbox，通过一个cnn来提取特征，再用svm对特征进行分类评分，再用线性模型调整bbox，非极大抑制来减少多重框，每个阶段都要单独调参，但是精度相对比较高。yolo一般就生成98个bbox，速度会快很多，而且是一个unified模型，运行也很快。</p>
<p>相对来说能够减少将背景误识别成object的概率</p>
<h2 id="YoloV2（Yolo9000）"><a href="#YoloV2（Yolo9000）" class="headerlink" title="YoloV2（Yolo9000）"></a>YoloV2（Yolo9000）</h2><p>存在的问题：相比于f-rcnn，预测框不准，不全，</p>
<h3 id="改良步骤："><a href="#改良步骤：" class="headerlink" title="改良步骤："></a>改良步骤：</h3><p>1.加了BN层：mAp加了2%，丢掉了dropout</p>
<p>2.分类器：用了在ImageNet上预训练的模型。原始的分类器是在224 <em> 224的图像上预训练，然后检测448 </em> 448的图像，现在改成预训练后先在448 * 448的图上fine-tune。这个操作加了%4的mAP</p>
<p>3.卷积的过程中加入了anchor box：yolov1单纯在卷积层之后使用全链接层才获取特征。现在移除全连接层，变成了对每个anchor box的种类和目标位置进行预测，目标检测依然是预测P值和框的属性值，类检测依然是预测此处物体的类别。简而言之，就是v1是对每个grid预测一次种类，现在是对每个anchor预测一次种类。对原始数据集里的框框大小来一次k均值分类来选出频率最高的几种框框类型。</p>
<p><strong>=================================</strong></p>
<p><strong>名词解释：</strong></p>
<p>anchor box：原本一个格子只能检测出一个对象，anchor box能让一个格子检测出多个对象。预先定义几个不懂形状的anchor box。假设普通yolo中一个bbox的预测输出y包含object的中心位置（横纵坐标x，y），bbox的宽和高（w，h），是否存在object的置信概率p，各个类别的预测值（n种类别就有n个输出）。那么普通yolo对于一个bbox的预测输出就是5+n维数据。</p>
<p>而anchor是对多个bbox进行预测，假设预测m个bbox，则输出y为m * (5+n)维数据。每5+n维数据都与一个bbox相关联。</p>
<p>所以现在就是根据object中心点分配到一个格子中，然后看gt和每个anchor bbox的IOU，选取IOU最大的anchor bbox来预测。</p>
<p><strong>=================================</strong></p>
<p>4.anchor box遇到的问题</p>
<p>5.直接位置预测：直接预测x，y坐标时可能会出现预测的坐标在grid cell以外的情况，不稳定，所以改成预测下图中的t值，</p>
<p><img src="anchor_offset.png" alt="image-20220305205145344"></p>
<p>预测框就是在anchor box的基础上进行微调</p>
<p>6.更精细的特征：用了一个passingthrough layer重排特征，有利于小目标识别</p>
<p>7.多重大小图像训练：所以虽然每个batch之内图像的尺寸必须是相同的，但是不同的batch之间图像的尺寸是不受限于框架的。YOLOv2便是基于这点实现了其训练过程中的多尺度。</p>
<p>8.语义分层： 在预测物体的类别时，我们遍历整个WordTree，在每个分割中采用最高的置信度路径，直到分类概率小于某个阈值（源码给的是0.6）时，然后预测结果，可以检测coco中没有的标签，类似于一种半监督学习</p>
<h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>Darknet-19</p>
<p>包括了19个卷积层和5个maxpooling层</p>
<p><img src="darknet.png" alt="image-20220305205225977"></p>
<p><img src="image-20220314155601017-7244563.png" alt="image-20220314155601017"></p>
<p>route层就是将两个或多个卷积层的结果做拼接</p>
<p>这里再放一张和yolov1标注的对比</p>
<p><img src="image-20220314155700031-7244621.png" alt="image-20220314155700031"></p>
<h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><h4 id="训练分类"><a href="#训练分类" class="headerlink" title="训练分类"></a>训练分类</h4><p>预训练，ImageNet 1000训练160个epochs。</p>
<p>fine tune，由原来的224变成448</p>
<h4 id="训练检测"><a href="#训练检测" class="headerlink" title="训练检测"></a>训练检测</h4><p>去掉最后一个卷积层，加了三个3 <em> 3 卷积层，每个卷积层后有一个1 </em> 1 的卷积层输出我们想要的结果</p>
<h3 id="loss"><a href="#loss" class="headerlink" title="loss"></a>loss</h3><p><img src="image-20220314155726577-7244651.png" alt="image-20220314155726577"></p>
<h2 id="Yolov3"><a href="#Yolov3" class="headerlink" title="Yolov3"></a>Yolov3</h2><p>先放一张网络结构图</p>
<p><img src="image-20220314155800077-7244681.png" alt="image-20220314155800077"></p>
<p>1.多尺度预测，步长不同，预测物体尺寸不同</p>
<p>2.既发挥了深层网络的语义特化抽象特征（大目标），又利用了浅层网络的细粒度的底层特征（小目标）。</p>
<h3 id="bbox预测"><a href="#bbox预测" class="headerlink" title="bbox预测"></a>bbox预测</h3><p>预测的参数还是和V2相似，但是目标检测分数（类似于IOU，表征这个bbox是否是目标bbox）改成了用逻辑回归来输出，如果有一个bbox比其他所有bbox覆盖的gt面积更多的话，他的值就是1</p>
<h3 id="网络设计"><a href="#网络设计" class="headerlink" title="网络设计"></a>网络设计</h3><h4 id="backbone-1"><a href="#backbone-1" class="headerlink" title="backbone"></a>backbone</h4><p>Darknet-53</p>
<h4 id="多尺度预测FPN-feature-pyramid-network"><a href="#多尺度预测FPN-feature-pyramid-network" class="headerlink" title="多尺度预测FPN(feature pyramid network)"></a>多尺度预测FPN(feature pyramid network)</h4><p>当前层的feature map会对更高层的feature map进行上采样，并加以利用。这是一个有跨越性的设计。因为有了这样一个结构，当前的feature map就可以获得更高层，更抽象的信息，这样的话低阶特征与高阶特征就有机融合起来了，提升检测精度。</p>
<p><img src="image-20220314160013157-7244814.png" alt="image-20220314160013157"></p>
<p>步幅越大，特征图尺寸越小，每个像素点感受野很大，有丰富的高层语义信息，容易检测到大目标，但是对小目标识别效果不太好，小目标需要在尺寸较大的特征图上面建立预测输出。</p>
<p>在目标检测中，解决这一问题的方式是，将高层级的特征图尺寸放大之后跟低层级的特征图进行融合，得到的新特征图既能包含丰富的语义信息，又具有较多的像素点，能够描述更加精细的结构。</p>
<p>深层一般具有更丰富的语义信息，但精度低，稍微浅一点的层含的语义信息会少一些，但是精度高。所以把高层的特征图通过卷积，upsample后与稍微低一点的层拼接，就有比较丰富的语义，p1和p2在空间和语义含义上都更具有优越性</p>
<h3 id="目标检测模型模块化"><a href="#目标检测模型模块化" class="headerlink" title="目标检测模型模块化"></a>目标检测模型模块化</h3><p><img src="image-20220314160406858-7245052.png" alt="image-20220314160406858"></p>
<p>yolov3开始基本上可以将目标检测模型分成backbone，Neck，head这几个大的模块，backbone是用来学习目标对象特征的基础，neck主要是关于模型多尺度识别的结构，head在其他模型上有开启下游任务的结构，也有anchor-free系列模型会在head上做一些设计</p>
<h3 id="模型输出"><a href="#模型输出" class="headerlink" title="模型输出"></a>模型输出</h3><p><img src="image-20220314160454314-7245095.png" alt="image-20220314160454314"></p>
<p>输出的是特征图，不是原来yolov1输出的序列，在每个特征图上，根据步长大小在每个相应感受野的point上生成三个预测框，每个预测框包括bbox位置信息，objectness物体是否存在置信度，以及物体类别的置信度</p>
<h4 id="类别置信度"><a href="#类别置信度" class="headerlink" title="类别置信度"></a>类别置信度</h4><p>类别置信度表示检测到的对象属于某个类别的概率（如狗、猫、香蕉、汽车等）。YOLO v3 使用 sigmoid 函数。因为对类别分数执行 softmax 操作的前提是类别是互斥的。简言之，如果对象属于一个类别，那么必须确保其不属于另一个类别。这在我们设置检测器的 COCO 数据集上是正确的。但是，当出现类别「女性」（Women）和「人」（Person）时，该假设不可行。这就是作者选择不使用 Softmax 激活函数的原因。</p>
<h4 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h4><p><img src="image-20220314160946001-7245388.png" alt="image-20220314160946001"></p>
<h3 id="正负样本分配"><a href="#正负样本分配" class="headerlink" title="正负样本分配"></a>正负样本分配</h3><p><img src="image-20220314161210057-7245531.png" alt="image-20220314161210057"></p>
<p>在训练过程中，论文上表达的是，模型会先根据在每个grid cell上预先设计好的anchor与gt框做IOU计算，然后选择某个步长上的某个特定的grid cell上的特定的bbox作为这个gt框的正样本（因此正样本很少），其余的检测框中，如果有检测框与gt框的IOU比较大（如大于0.7），就直接标记为负（这样其实漏掉了很多检测很好的样本，过于依赖先验知识了）</p>
<h2 id="Yolov3的一些代码逻辑"><a href="#Yolov3的一些代码逻辑" class="headerlink" title="Yolov3的一些代码逻辑"></a>Yolov3的一些代码逻辑</h2><p>yolov3对图像实现目标检测目标，其模型本质的功能是基于输入的图像生成对该图像上检测目标的标签的值。</p>
<p>假设一张图像被分成13 * 13 = 169个grid cells，每个cell生成3个anchor box</p>
<p>标签的值包括：bbox的位置相对值，objectness值，类别预测值。</p>
<p>特点：通过算数转换，模型计算损失时所有的标签值序列里每一个值都是由sigmoid输出0-1之间的相对值。</p>
<p>输入的单个样本：一张图像</p>
<p>对应标签：由图像生成anchor box 数据，每个anchor box数据包括上述标签的值，即每个图片的标签包含是13 <em> 13 </em> 3 <em> （4+1+clsss）个0-1之间的值，因此我们的模型输出也是13 </em> 13 <em> 3 </em> （4+1+clsss）个0-1之间的值，后续我们通过iou计算，objectness阈值，nms等处理我们模型输出的值，得到较为直观的结果。</p>
<p>所以yolov3整体的流程为：</p>
<p>图像数据resize-&gt;图像增广-&gt;图像上anchor box标签生成-&gt;将输入样本和其标签对应起来-&gt;输入模型-&gt;输出数据后选择正负样本与检测框计算loss，处理，根据模型输出计算出预测框的xywh，种类等</p>
<h3 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1 预处理"></a>1 预处理</h3><h4 id="1-1-图像读取"><a href="#1-1-图像读取" class="headerlink" title="1.1 图像读取"></a>1.1 图像读取</h4><p>用cv包读取后resize成416（为了让图像中心正好有一个grid cell），通道顺序注意一下，加一个batch_size通道,顺便归一化，把图像数值化成tensor变成相应框架的变量。</p>
<h4 id="1-2-anchor-box的生成与标注标签"><a href="#1-2-anchor-box的生成与标注标签" class="headerlink" title="1.2 anchor box的生成与标注标签"></a>1.2 anchor box的生成与标注标签</h4><h5 id="anchor-box标签生成"><a href="#anchor-box标签生成" class="headerlink" title="anchor box标签生成"></a>anchor box标签生成</h5><p>其实就是需要给每个grid cell生成指定的height和width的anchor box。bbox所需的参数即xywh：中心坐标和长宽数据。而在实际生成预测框时这四个数据都要进行一定程度的改变来指向特定物体</p>
<h5 id="划分单位size的grid-cell"><a href="#划分单位size的grid-cell" class="headerlink" title="划分单位size的grid cell"></a>划分单位size的grid cell</h5><p>列数：</p>
<script type="math/tex; mode=display">m = \frac{height}{size}</script><p>行数：</p>
<script type="math/tex; mode=display">n = \frac{width}{size}</script><h5 id="针对objectness单独的理解"><a href="#针对objectness单独的理解" class="headerlink" title="针对objectness单独的理解"></a>针对objectness单独的理解</h5><p>针对每一个图，所有的anchor box放在一起相当于一个小的数据集，其中有一些样本的objectness标签为1，有一些样本的objectness标签为0。让模型学习类似f（box参数+图像）=objectness这样的函数关系，从而让模型能够预测anchor box的objectness值</p>
<p>这里的标签是计算出来的，计算方法是计算每个anchor box和每个gt物体框的iou，同一个物体中心只存在于一个grid cell，iou超过阈值且最大的那个anchor box标签为1，超过阈值但不是最大的box标签为-1（不参加训练objectness模型），剩下的标签为0。所以同一个物体只能选一个anchor box打上objectness = 1的标签。将图像数据和box的参数作为输入，objectness值作为输出进行训练，让模型学习类似f（box参数+图像）=objectness这样的函数关系，所以训练好的抽象模型就可以根据输入的图像数据和box参数判断objectness的值。</p>
<p>当一个框的objectness为0或-1时，不用再去标注下面的box标签参数了。</p>
<h5 id="由anchor-box到预测框：中心坐标"><a href="#由anchor-box到预测框：中心坐标" class="headerlink" title="由anchor box到预测框：中心坐标"></a>由anchor box到预测框：中心坐标</h5><p>因为每个objectness = 1的anchor box都是批量生成好的，不可能和物体恰好重合，所以检测时肯定会微调，由anchor box到检测的bbox。此时为了方便，技术单位统一变成grid cell的size，所以x行，y列的位置坐标其实为 <script type="math/tex">(x + \sigma(t_{x})) \times size</script> 和 <script type="math/tex">(y + \sigma(t_{y})) \times size</script> 其中 $\sigma()$ 可以是一个sigmoid函数，输出是0到1之间的数。因此我们可以通过改变 $\sigma()$ 来改变anchor的中心坐标，且保证中心坐标一定在规定的grid cell里面。</p>
<h5 id="由anchor-box的-p-w-p-h-到预测框：w-h"><a href="#由anchor-box的-p-w-p-h-到预测框：w-h" class="headerlink" title="由anchor box的 $p_{w}$,$p_{h}$ 到预测框：w,h"></a>由anchor box的 $p_{w}$,$p_{h}$ 到预测框：w,h</h5><script type="math/tex; mode=display">w = p_{w}e^{t_{w}}</script><script type="math/tex; mode=display">h = p_{h}e^{t_{h}}</script><p>其中$t$是参数</p>
<h5 id="而anchor-box到预测框之间的这些参数就是我们模型希望能够预测的值"><a href="#而anchor-box到预测框之间的这些参数就是我们模型希望能够预测的值" class="headerlink" title="而anchor box到预测框之间的这些参数就是我们模型希望能够预测的值"></a>而anchor box到预测框之间的这些参数就是我们模型希望能够预测的值</h5><p>针对一个gt框，我们可以直接通过计算得到其中心坐标。通过上面的式子，我们可以得到真实中心坐标对应的$t$参数值，即成了我们训练的标签。通过巧妙的变换，我们将所有的值预测问题变成了一个预测某个0-1之间数值的问题，增强了模型的鲁棒性。</p>
<h5 id="模型功能"><a href="#模型功能" class="headerlink" title="模型功能"></a>模型功能</h5><p>样本：图像 + 每个objectness = 1的anchor box的四个参数值</p>
<p>标签：真实box计算出来的四个参数值-&gt;即表征真实box的位置</p>
<h5 id="预测标签"><a href="#预测标签" class="headerlink" title="预测标签"></a>预测标签</h5><p>抽象模型的训练集是只有objectness = 1的anchor box，数据是图像 + anchor box参数，标签是类别，训练后的目标是通过anchor box参数和图像就可以预测图像所属的标签。</p>
<h3 id="2-模型设计"><a href="#2-模型设计" class="headerlink" title="2 模型设计"></a>2 模型设计</h3><h4 id="2-1-backbone-ResNet"><a href="#2-1-backbone-ResNet" class="headerlink" title="2.1 backbone ResNet"></a>2.1 backbone ResNet</h4><h5 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h5><p>就通道数，卷积核，步长，padding，用的leakyRelu激活函数</p>
<h5 id="shortcut残差块"><a href="#shortcut残差块" class="headerlink" title="shortcut残差块"></a>shortcut残差块</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[shortcut]</span><br><span class="line"></span><br><span class="line">from=-3</span><br><span class="line"></span><br><span class="line">activation=linear</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>跳过连接与残差网络中使用的结构相似，参数 from 为-3 表示捷径层的输出会通过将之前层的和之前第三个层的输出的特征图与模块的输入相加而得出</p>
<h5 id="上采样upsample"><a href="#上采样upsample" class="headerlink" title="上采样upsample"></a>上采样upsample</h5><p>参数只有一个步幅</p>
<h5 id="路由层Route"><a href="#路由层Route" class="headerlink" title="路由层Route"></a>路由层Route</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[route]</span><br><span class="line"></span><br><span class="line">layers = -4</span><br><span class="line"></span><br><span class="line">[route]</span><br><span class="line"></span><br><span class="line">layers = -1, 61</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>路由层需要一些解释，它的参数 layers 有一个或两个值。当只有一个值时，它输出这一层通过该值索引的特征图。在我们的实验中设置为了-4，所以层级将输出路由层之前第四个层的特征图。</p>
<p>当层级有两个值时，它将返回由这两个值索引的拼接特征图。在我们的实验中为-1 和 61，因此该层级将输出从前一层级（-1）到第 61 层的特征图，并将它们按深度拼接。</p>
<p>按深度即对应位置的方块通道数增加</p>
<h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">x = np.random.randn(1, 3, 640, 640).astype(&#x27;float32&#x27;)</span><br><span class="line"></span><br><span class="line">x = paddle.to_tensor(x)</span><br><span class="line"></span><br><span class="line">C0, C1, C2 = backbone(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>指定输入数据的形状是(1,3,640,640)，则3个层级的输出特征图的形状分别是C0 (1, 1024, 20, 20)，C1(1,512,40,40)和C2(1,256,80,80)。</p>
<p>每个小方块区域产生K个预测框，每个预测框需要(5+C)个实数预测值，则每个像素点相对应的要有K(5+C)个实数。为了解决这一问题，对特征图进行多次卷积，并将最终的输出通道数设置为K(5+C)，即可将生成的特征图与每个预测框所需要的预测值对应起来。7</p>
<p>目的：保证为了针对输出和标签形成对应的loss。</p>
<h4 id="2-2-yolo层"><a href="#2-2-yolo层" class="headerlink" title="2.2 yolo层"></a>2.2 yolo层</h4><p>yolo层是检测层(一种head)，传入一个Backbone生成的特征图（如C0），每一个特征图表征了一种属性在指定grid cell位置的第k个预测框的第n个参数的预测值。在yolo层里输入和输出通道数不变。</p>
<p>输出的是一个route特征图和一个tip特征图，其中tip比route多经历一个卷积核为3的卷积层。然后tip特征图经过一个卷积核为1的卷积层就输出C0层的预测特征图P0.</p>
<p>x-&gt;(backbone)-&gt;C0-&gt;(yolo层)route-&gt;(conv2d)-&gt;tip-&gt;(conv2d)-&gt;P0</p>
<p>-&gt;C1</p>
<p>-&gt;C2</p>
<h3 id="正负样本标注细节：objecness标注"><a href="#正负样本标注细节：objecness标注" class="headerlink" title="正负样本标注细节：objecness标注"></a>正负样本标注细节：objecness标注</h3><p>首先基于原始图像的标注文件生成许多anchor box和相应标注。</p>
<p>Shape是[batch_size, rows, cols, anchors],就是单个图片分割成rows <em> cols个cell，每个cell生成K个anchors标注，因此单个图像一共生成rows</em>cols*K个anchor标注框。</p>
<p><strong>正样本标注</strong></p>
<p>这些标注中，每个真实框只有一个标注框与之对应，即生成的所有anchor box中与真实框IoU最大的anchor box标注为正</p>
<p><strong>负样本标注</strong></p>
<p>这些标注中，没有跟任何一个真实框匹配上的标注框都标记为负样本。</p>
<p>问题： objectness标注的是该anchor bbox包含物体的可能性，即训练时理论上正样本标注框对应的预测框应该是包含物体的，负样本标注框对应的预测框应该是不包含物体的。那么是不是<strong>所有标注为负样本的标注框对应的预测框都一定不包含物体</strong>呢？答案显然是否定的，依然有很多效果很好的预测框没有参与训练。这些框的处理规则是：</p>
<h4 id="忽略预测框中，与真实框-IoU-较大的负样本框"><a href="#忽略预测框中，与真实框-IoU-较大的负样本框" class="headerlink" title="忽略预测框中，与真实框**IoU**较大的负样本框"></a><strong>忽略预测框中，与真实框**</strong>IoU<strong>**较大的负样本框</strong></h4><p>首先选出IoU大于阈值的所有pred_box</p>
<p>选出跟真实框IoU大于指定阈值的预测，get_iou_above_thresh_inds(pred_box, gt_boxes, iou_threshold)，</p>
<p> pred_box：预测框，shape是batch_size, rows, cols, anchors，即按照特征图尺寸，每个位置都有K个预测的anchors。</p>
<p> gt_bboxes：真实框， shape相同，iou_threshold是阈值（0.7）。</p>
<p>1.取出对应位置的K个pred_box与相应位置的gt_boxes计算IoU，选出IoU&gt; iou_threshold的pred_boxes标记为1</p>
<p>2.将所有label_objectness &lt; 0.5的标注box选出来，索引为negative_indices,即没有和gt_bbox匹配上的标注框都已被标记为负样本。这些box本来是应该作为负样本参与损失函数objectness部分的构建，但是<strong>如果相应的**</strong>pred_box<strong><strong>有</strong></strong>IoU<strong>**和真实框很大的，标记为负样本显然会对模型的学习造成影响</strong>。因此这些选出来的bbox索引negative_indices 与1中得到的索引相乘，得到的就是既是没有与gt匹配上的样本，预测框又和gt有很大IoU，将这些框的索引标记为-1，不参与损失函数构建。</p>
<p>所以总结一下 yolov3在这个模块的特点是：<strong>按照经验设置**</strong>anchor <strong>box**</strong>，按照经验设置<strong>IoU</strong>阈值，按照经验忽略一些检测框。</p>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h3 id="loss-1"><a href="#loss-1" class="headerlink" title="loss"></a>loss</h3><p><img src="image-20220314163109996.png" alt="image-20220314163109996"></p>
<h3 id="3-输出变换"><a href="#3-输出变换" class="headerlink" title="3.输出变换"></a>3.输出变换</h3><h4 id="输出时3个预测图维度不同，先变换维度"><a href="#输出时3个预测图维度不同，先变换维度" class="headerlink" title="输出时3个预测图维度不同，先变换维度"></a>输出时3个预测图维度不同，先变换维度</h4><p>prediction（batch_size,第几个anchor box，bbox的几个参数）</p>
<p>从第三个维度里，原地取出x，y，confidence的预测值，取sigmoid值</p>
<p>x，y加上偏移：和grid cell的位置相关。</p>
<p>再根据w，h来调整anchor box</p>
<p>再原地将class的预测值通过sigmoid</p>
<p>最后将检测图的大小调整到和输入图像一致。</p>
<h4 id="执行nms（非极大值抑制）"><a href="#执行nms（非极大值抑制）" class="headerlink" title="执行nms（非极大值抑制）"></a>执行nms（非极大值抑制）</h4><p>取出一张图的bbox参数</p>
<p>先取出80个class的预测值，找出最大值，取出</p>
<h2 id="YOLOv4"><a href="#YOLOv4" class="headerlink" title="YOLOv4"></a>YOLOv4</h2><h3 id="Data-Augmentation"><a href="#Data-Augmentation" class="headerlink" title="Data Augmentation"></a>Data Augmentation</h3><h4 id="Cut-Mix"><a href="#Cut-Mix" class="headerlink" title="Cut Mix"></a>Cut Mix</h4><p>就是将一部分区域cut掉但不填充0像素而是随机填充训练集中的其他数据的区域像素值，分类结果按一定的比例分配，使得模型能够从一幅图像上的局部视图上识别出两个目标，提高训练的效率。</p>
<h4 id="Mosaic-Mix"><a href="#Mosaic-Mix" class="headerlink" title="Mosaic Mix"></a>Mosaic Mix</h4><p>四个图mix，可以显著减少有的模型对大batch size的需求（coco）</p>
<h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><h4 id="backbone：CSPDarknet53"><a href="#backbone：CSPDarknet53" class="headerlink" title="backbone：CSPDarknet53"></a>backbone：CSPDarknet53</h4><p>目的：减少部分多余的梯度信息</p>
<p>作者认为现在的网络计算量大是由于在网络优化的过程中重复的梯度信息。作者将一个stage的头尾两部分的特征图集成起来，来解决这个问题，减少了至少20%的计算量，网络效果与之前相当甚至超过，而且CSP结构可以和其他网络结构结合，</p>
<p>使用了mish层作为激活函数，原因是在小于0的部分有更多梯度信息</p>
<h5 id="Weighted-Residual-Connections-WRC-："><a href="#Weighted-Residual-Connections-WRC-：" class="headerlink" title="Weighted-Residual-Connections (WRC)："></a>Weighted-Residual-Connections (WRC)：</h5><p>残差块里残差部分变成两个连续Conv-BN-ReLUs。</p>
<h5 id="Cross-mini-Batch-Normalization-CmBN"><a href="#Cross-mini-Batch-Normalization-CmBN" class="headerlink" title="Cross mini-Batch Normalization (CmBN)"></a>Cross mini-Batch Normalization (CmBN)</h5><h4 id="Neck：SPP-PAN"><a href="#Neck：SPP-PAN" class="headerlink" title="Neck：SPP + PAN"></a>Neck：SPP + PAN</h4><p>PAN其实就是在FPN自深到浅的concat之后再加上一个自浅到深的concat。</p>
<p>SPP（spatial pyramid pooling）特点：</p>
<ul>
<li><p>不管输入尺寸是怎样的，SPP可以产生固定大小的输出</p>
</li>
<li><p>使用多个窗口</p>
</li>
<li><p>SPP可以使用同一图像不同尺寸作为输入，得到同样长度的池化特征。</p>
</li>
</ul>
<p>根据输入和输入图像的尺寸来设计滑动窗口的尺寸和步长，从而保证不同的输入有相同的输出</p>
<p>保留原图片的尺寸对实验的特征提取和结果都很重要。</p>
<p>简单一点就是目标检测时把最后一个卷积特征图上ROI拿出来，经过SPP之后不同大小的ROI区域图像变成相同大小的数据输入到全连接层</p>
<p>实验证明：</p>
<p>对尺度的改变具有更强的鲁棒性，能提高准确率</p>
<p>而且是pooling层，对网络结构没有影响</p>
<h3 id="loss-2"><a href="#loss-2" class="headerlink" title="loss"></a>loss</h3><p>MSE损失函数存在的问题：将中心点坐标作为独立的变量对待</p>
<p>（1）bounding box regression损失</p>
<p>（2）置信度损失</p>
<p>（3）分类损失</p>
<h4 id="IOU-loss"><a href="#IOU-loss" class="headerlink" title="IOU loss"></a>IOU loss</h4><script type="math/tex; mode=display">L_{IOU}=1-IOU(A,B)</script><p>但这个损失函数知道bbox重叠的时候管用，不重叠的话iou=0，没有梯度</p>
<h4 id="GIOU"><a href="#GIOU" class="headerlink" title="GIOU"></a>GIOU</h4><script type="math/tex; mode=display">L_{GIOU}=1-IOU(A,B)+|C-A\bigcup B|/C</script><p>Generallized IOU loss,IOU LOSS加了一个惩罚项，惩罚项是大框框C中非AB部分面积和大框框面积的比，当然loss越小越好，具体是GIOU先增大预测框的大小来找真实框，找到后再优化，但问题在于这个找真实框的时间可能会很久，需要比较长的收敛速度</p>
<p><img src="GIOU.png" alt="image-20220305205502841"></p>
<h4 id="DIOU"><a href="#DIOU" class="headerlink" title="DIOU"></a>DIOU</h4><p>D:distance，原理在于优化anchor中心和真实框中心的距离，这样可以收敛更快</p>
<script type="math/tex; mode=display">L_{GIOU}=1-IOU(A,B)+\rho (A_{ctr},B_{ctr})/c^{2}</script><p>A : 预测框， B：真实框</p>
<p>$A_{ctr}$: 预测框中心点坐标</p>
<p>$B_{ctr}$ ：真实框中心点坐标</p>
<p>$\rho (.)$是欧式距离的计算</p>
<p>c 为 A , B 最小包围框的对角线长度</p>
<p><img src="diou.png" alt="image-20220305205556281"></p>
<p>距离越远，DIOU越接近2，距离越近，DIOU越接近0。</p>
<h4 id="CIOU"><a href="#CIOU" class="headerlink" title="CIOU"></a>CIOU</h4><p>Complete IoU Loss</p>
<p>（1）重叠面积</p>
<p>（2）中心点距离</p>
<p>（3）长宽比</p>
<script type="math/tex; mode=display">L_{GIOU}=1-IOU(A,B)+\rho (A_{ctr},B_{ctr})/c^{2}+\alpha.v</script><h2 id="YOLOv5"><a href="#YOLOv5" class="headerlink" title="YOLOv5"></a>YOLOv5</h2><h3 id="网络结构和v4基本相同"><a href="#网络结构和v4基本相同" class="headerlink" title="网络结构和v4基本相同"></a>网络结构和v4基本相同</h3><h4 id="backbone-Neck"><a href="#backbone-Neck" class="headerlink" title="backbone + Neck"></a>backbone + Neck</h4><p>和v4一样，都是CSPDarknet + PAN</p>
<h1 id="明确每个trick目的是什么"><a href="#明确每个trick目的是什么" class="headerlink" title="明确每个trick目的是什么"></a>明确每个trick目的是什么</h1><p>一般目标检测模型的pipeline显示特征提取，而后是分类器或者定位器在特征空间中寻找需要的特征，一般是用滑动窗口扫描整张图像或者扫描图相中的子集</p>
<p>模型Head主要用于最终检测部分。它在特征图上应用锚定框，并生成带有类概率、对象得分和包围框的最终输出向量。</p>
<h2 id="通用API"><a href="#通用API" class="headerlink" title="通用API"></a>通用API</h2><h3 id="绘制anchor-box"><a href="#绘制anchor-box" class="headerlink" title="绘制anchor box"></a>绘制anchor box</h3><h4 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h4><p>中心点坐标：[x, y]</p>
<p>基准长度：length</p>
<p>尺寸比例：scales</p>
<p>长宽比例：ratios</p>
<p>原图尺寸：img_height,img_width</p>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>基准长度,尺寸,和长宽比得到anchor的长和宽</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h = length \times scales \times \sqrt[]&#123;ratios&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = length \times scales \div \sqrt[]&#123;ratios&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由中心点和w，h就可以确定anchor box的坐标和大小</p>
<p>然后传入已有的坐标轴即可</p>
<h3 id="计算iou"><a href="#计算iou" class="headerlink" title="计算iou"></a>计算iou</h3><h4 id="输入：-1"><a href="#输入：-1" class="headerlink" title="输入："></a>输入：</h4><p>xywh形式或者xyxy格式的两个box，即两个长度为4的数列</p>
<h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><p>IOU数值</p>
<h4 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h4><p>思想都是先取出相交处的左上和右下点的坐标，计算出相交面积，然后就好算了。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AE%9E%E4%B9%A0/" rel="tag"># 实习</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/11/01/Linux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" rel="prev" title="Linux常用操作">
      <i class="fa fa-chevron-left"></i> Linux常用操作
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/01/10/%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E7%AF%AE%E7%90%83%E6%8A%80%E6%9C%AF/" rel="next" title="训练计划-篮球技术">
      训练计划-篮球技术 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%A0%E4%B8%AA%E5%AE%8F%E8%A7%82%E4%B8%8A%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.</span> <span class="nav-text">几个宏观上的理解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#YOLOv1"><span class="nav-number"></span> <span class="nav-text">YOLOv1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">1.概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#backbone"><span class="nav-number">1.1.</span> <span class="nav-text">backbone</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-number">1.2.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%AE%9A%E4%B9%89"><span class="nav-number">1.3.</span> <span class="nav-text">2.1输入输出定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.</span> <span class="nav-text">2.2 损失函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">3训练过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Limitation"><span class="nav-number">2.1.</span> <span class="nav-text">Limitation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94"><span class="nav-number">2.2.</span> <span class="nav-text">模型对比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#YoloV2%EF%BC%88Yolo9000%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">YoloV2（Yolo9000）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E8%89%AF%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="nav-number">1.</span> <span class="nav-text">改良步骤：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">网络结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">训练过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%AD%E7%BB%83%E5%88%86%E7%B1%BB"><span class="nav-number">3.1.</span> <span class="nav-text">训练分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%AD%E7%BB%83%E6%A3%80%E6%B5%8B"><span class="nav-number">3.2.</span> <span class="nav-text">训练检测</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#loss"><span class="nav-number">4.</span> <span class="nav-text">loss</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Yolov3"><span class="nav-number"></span> <span class="nav-text">Yolov3</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bbox%E9%A2%84%E6%B5%8B"><span class="nav-number">1.</span> <span class="nav-text">bbox预测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.</span> <span class="nav-text">网络设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#backbone-1"><span class="nav-number">2.1.</span> <span class="nav-text">backbone</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E5%B0%BA%E5%BA%A6%E9%A2%84%E6%B5%8BFPN-feature-pyramid-network"><span class="nav-number">2.2.</span> <span class="nav-text">多尺度预测FPN(feature pyramid network)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="nav-number">3.</span> <span class="nav-text">目标检测模型模块化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E8%BE%93%E5%87%BA"><span class="nav-number">4.</span> <span class="nav-text">模型输出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%88%AB%E7%BD%AE%E4%BF%A1%E5%BA%A6"><span class="nav-number">4.1.</span> <span class="nav-text">类别置信度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-number">4.2.</span> <span class="nav-text">处理流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E8%B4%9F%E6%A0%B7%E6%9C%AC%E5%88%86%E9%85%8D"><span class="nav-number">5.</span> <span class="nav-text">正负样本分配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Yolov3%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91"><span class="nav-number"></span> <span class="nav-text">Yolov3的一些代码逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E9%A2%84%E5%A4%84%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">1 预处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E5%9B%BE%E5%83%8F%E8%AF%BB%E5%8F%96"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 图像读取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-anchor-box%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E6%A0%87%E6%B3%A8%E6%A0%87%E7%AD%BE"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 anchor box的生成与标注标签</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#anchor-box%E6%A0%87%E7%AD%BE%E7%94%9F%E6%88%90"><span class="nav-number">1.2.1.</span> <span class="nav-text">anchor box标签生成</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%92%E5%88%86%E5%8D%95%E4%BD%8Dsize%E7%9A%84grid-cell"><span class="nav-number">1.2.2.</span> <span class="nav-text">划分单位size的grid cell</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%92%88%E5%AF%B9objectness%E5%8D%95%E7%8B%AC%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.2.3.</span> <span class="nav-text">针对objectness单独的理解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%B1anchor-box%E5%88%B0%E9%A2%84%E6%B5%8B%E6%A1%86%EF%BC%9A%E4%B8%AD%E5%BF%83%E5%9D%90%E6%A0%87"><span class="nav-number">1.2.4.</span> <span class="nav-text">由anchor box到预测框：中心坐标</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%B1anchor-box%E7%9A%84-p-w-p-h-%E5%88%B0%E9%A2%84%E6%B5%8B%E6%A1%86%EF%BC%9Aw-h"><span class="nav-number">1.2.5.</span> <span class="nav-text">由anchor box的 $p_{w}$,$p_{h}$ 到预测框：w,h</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%80%8Canchor-box%E5%88%B0%E9%A2%84%E6%B5%8B%E6%A1%86%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%99%E4%BA%9B%E5%8F%82%E6%95%B0%E5%B0%B1%E6%98%AF%E6%88%91%E4%BB%AC%E6%A8%A1%E5%9E%8B%E5%B8%8C%E6%9C%9B%E8%83%BD%E5%A4%9F%E9%A2%84%E6%B5%8B%E7%9A%84%E5%80%BC"><span class="nav-number">1.2.6.</span> <span class="nav-text">而anchor box到预测框之间的这些参数就是我们模型希望能够预测的值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E5%8A%9F%E8%83%BD"><span class="nav-number">1.2.7.</span> <span class="nav-text">模型功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%84%E6%B5%8B%E6%A0%87%E7%AD%BE"><span class="nav-number">1.2.8.</span> <span class="nav-text">预测标签</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.</span> <span class="nav-text">2 模型设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-backbone-ResNet"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 backbone ResNet</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%B7%E7%A7%AF%E5%B1%82"><span class="nav-number">2.1.1.</span> <span class="nav-text">卷积层</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#shortcut%E6%AE%8B%E5%B7%AE%E5%9D%97"><span class="nav-number">2.1.2.</span> <span class="nav-text">shortcut残差块</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8A%E9%87%87%E6%A0%B7upsample"><span class="nav-number">2.1.3.</span> <span class="nav-text">上采样upsample</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E5%B1%82Route"><span class="nav-number">2.1.4.</span> <span class="nav-text">路由层Route</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BE%93%E5%87%BA"><span class="nav-number">2.1.5.</span> <span class="nav-text">输出</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-yolo%E5%B1%82"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 yolo层</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E8%B4%9F%E6%A0%B7%E6%9C%AC%E6%A0%87%E6%B3%A8%E7%BB%86%E8%8A%82%EF%BC%9Aobjecness%E6%A0%87%E6%B3%A8"><span class="nav-number">3.</span> <span class="nav-text">正负样本标注细节：objecness标注</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%BD%E7%95%A5%E9%A2%84%E6%B5%8B%E6%A1%86%E4%B8%AD%EF%BC%8C%E4%B8%8E%E7%9C%9F%E5%AE%9E%E6%A1%86-IoU-%E8%BE%83%E5%A4%A7%E7%9A%84%E8%B4%9F%E6%A0%B7%E6%9C%AC%E6%A1%86"><span class="nav-number">3.1.</span> <span class="nav-text">忽略预测框中，与真实框**IoU**较大的负样本框</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text"> </span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#loss-1"><span class="nav-number">1.</span> <span class="nav-text">loss</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%BE%93%E5%87%BA%E5%8F%98%E6%8D%A2"><span class="nav-number">2.</span> <span class="nav-text">3.输出变换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E6%97%B63%E4%B8%AA%E9%A2%84%E6%B5%8B%E5%9B%BE%E7%BB%B4%E5%BA%A6%E4%B8%8D%E5%90%8C%EF%BC%8C%E5%85%88%E5%8F%98%E6%8D%A2%E7%BB%B4%E5%BA%A6"><span class="nav-number">2.1.</span> <span class="nav-text">输出时3个预测图维度不同，先变换维度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8Cnms%EF%BC%88%E9%9D%9E%E6%9E%81%E5%A4%A7%E5%80%BC%E6%8A%91%E5%88%B6%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">执行nms（非极大值抑制）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#YOLOv4"><span class="nav-number"></span> <span class="nav-text">YOLOv4</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Data-Augmentation"><span class="nav-number">1.</span> <span class="nav-text">Data Augmentation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Cut-Mix"><span class="nav-number">1.1.</span> <span class="nav-text">Cut Mix</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mosaic-Mix"><span class="nav-number">1.2.</span> <span class="nav-text">Mosaic Mix</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">模型结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#backbone%EF%BC%9ACSPDarknet53"><span class="nav-number">2.1.</span> <span class="nav-text">backbone：CSPDarknet53</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Weighted-Residual-Connections-WRC-%EF%BC%9A"><span class="nav-number">2.1.1.</span> <span class="nav-text">Weighted-Residual-Connections (WRC)：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Cross-mini-Batch-Normalization-CmBN"><span class="nav-number">2.1.2.</span> <span class="nav-text">Cross mini-Batch Normalization (CmBN)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Neck%EF%BC%9ASPP-PAN"><span class="nav-number">2.2.</span> <span class="nav-text">Neck：SPP + PAN</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#loss-2"><span class="nav-number">3.</span> <span class="nav-text">loss</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IOU-loss"><span class="nav-number">3.1.</span> <span class="nav-text">IOU loss</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GIOU"><span class="nav-number">3.2.</span> <span class="nav-text">GIOU</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DIOU"><span class="nav-number">3.3.</span> <span class="nav-text">DIOU</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CIOU"><span class="nav-number">3.4.</span> <span class="nav-text">CIOU</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#YOLOv5"><span class="nav-number"></span> <span class="nav-text">YOLOv5</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E5%92%8Cv4%E5%9F%BA%E6%9C%AC%E7%9B%B8%E5%90%8C"><span class="nav-number">1.</span> <span class="nav-text">网络结构和v4基本相同</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#backbone-Neck"><span class="nav-number">1.1.</span> <span class="nav-text">backbone + Neck</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%98%8E%E7%A1%AE%E6%AF%8F%E4%B8%AAtrick%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number"></span> <span class="nav-text">明确每个trick目的是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E7%94%A8API"><span class="nav-number"></span> <span class="nav-text">通用API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%98%E5%88%B6anchor-box"><span class="nav-number">1.</span> <span class="nav-text">绘制anchor box</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%EF%BC%9A"><span class="nav-number">1.1.</span> <span class="nav-text">输入：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD"><span class="nav-number">1.2.</span> <span class="nav-text">功能</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97iou"><span class="nav-number">2.</span> <span class="nav-text">计算iou</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%EF%BC%9A-1"><span class="nav-number">2.1.</span> <span class="nav-text">输入：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%EF%BC%9A"><span class="nav-number">2.2.</span> <span class="nav-text">输出：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%EF%BC%9A"><span class="nav-number">2.3.</span> <span class="nav-text">功能：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#-1"><span class="nav-number"></span> <span class="nav-text"> </span></a></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">篮球架上打砖块</p>
  <div class="site-description" itemprop="description">Apodidae</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">篮球架上打砖块</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '[object Object]';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
