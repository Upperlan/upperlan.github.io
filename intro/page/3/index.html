<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Apodidae">
<meta property="og:type" content="website">
<meta property="og:title" content="Upperlan">
<meta property="og:url" content="http://example.com/intro/page/3/index.html">
<meta property="og:site_name" content="Upperlan">
<meta property="og:description" content="Apodidae">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="篮球架上打砖块">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/intro/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Upperlan</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Upperlan</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/11/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97-%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="篮球架上打砖块">
      <meta itemprop="description" content="Apodidae">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Upperlan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/11/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97-%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">算法系列-排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-11 20:23:04" itemprop="dateCreated datePublished" datetime="2022-03-11T20:23:04+08:00">2022-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-06 10:41:27" itemprop="dateModified" datetime="2022-04-06T10:41:27+08:00">2022-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>自己写输入输出的格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">include&lt;bits/stdc++.h&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;ans, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>; <span class="comment">//即输入已经不是l &lt; r，直接返回</span></span><br><span class="line">    <span class="type">int</span> l = left - <span class="number">1</span>; <span class="comment">//因为每次都是先加，再比较，所以初始化时初始化到前面一个位置</span></span><br><span class="line">    <span class="type">int</span> r = right + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> x = ans[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">do</span> l ++ ; <span class="keyword">while</span> (ans[l] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> r -- ; <span class="keyword">while</span> (ans[r] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(l &lt; r) <span class="built_in">swap</span>(ans[l], ans[r]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(ans, left, r);</span><br><span class="line">    <span class="built_in">quick_sort</span>(ans, r + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">while</span>(N --) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(ans, <span class="number">0</span>, ans.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : ans) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心代码模式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = nums[r]; <span class="comment">//p是待比较的数</span></span><br><span class="line">        <span class="type">int</span> i = l - <span class="number">1</span>; <span class="comment">//不确定第一个数比p大还是小，所以指针移到上一位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = l;j &lt; r ;++j) &#123;<span class="comment">//快慢指针，保证i自己和它左边的数一定比p小</span></span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt;= p) &#123;<span class="comment">//从左遍历到右，如果快指针j找到了比p小的，就交给慢指针</span></span><br><span class="line">                i = i + <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">swap</span>(nums[j],nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i+<span class="number">1</span>],nums[r]);<span class="comment">//因为i本身也比p小，就i+1指定比p大，所以可以直接换</span></span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rand_partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> random_pos = <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>) + l;<span class="comment">// % (r-l+1)控制随机数的范围，减是防止直接加导致数据过界</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[random_pos],nums[r]); <span class="comment">//将选中的随机数换到最后</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">partition</span>(nums,l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> pos = <span class="built_in">rand_partition</span>(nums,l,r);</span><br><span class="line">            <span class="built_in">quicksort</span>(nums,l,pos - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">quicksort</span>(nums,pos + <span class="number">1</span>,r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));<span class="comment">//</span></span><br><span class="line">        <span class="built_in">quicksort</span>(nums,<span class="number">0</span>,(<span class="type">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>srand(time(NULL)); 的意思是：使用当前时间进行随机数发生器的初始化。</strong></p>
<p>t是空指针（NULL），直接返回当前时间。</p>
<p>time() 是指返回自 Unix 纪元起的当前时间的秒数的函数，主要用来获取当前的系统时间，返回的结果是一个time_t类型。</p>
<p>srand函数是随机数发生器的初始化函数。原型：void srand(unsigned int seed); srand和rand()配合使用产生伪随机数序列。</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], tmp[N]; <span class="comment">// 声明一个指定大小的数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid), <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j]; <span class="comment">//在这里l到r是闭区间，判断条件要取等号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">merge_sort</span>(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val; //规定链表的值</span></span><br><span class="line"><span class="comment"> *     ListNode *next;//规定链表一个指针，指向下一个链表的存储空间</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;//构造函数，定义一个存储的值为0，指向NULL的新结点</span></span><br><span class="line"><span class="comment"> *     // ListNode *dummyNode = new ListnNode(0);是新建结点的方式</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;; //记得结构体和类后面要跟分号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergesort</span><span class="params">(ListNode *&amp;head)</span> </span>&#123; <span class="comment">//这里记得head加上引用</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            pre = slow;<span class="comment">//慢指针的前驱</span></span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = <span class="literal">NULL</span>;<span class="comment">//将慢指针前一个结点的next置为空，慢指针前面要断开</span></span><br><span class="line">        ListNode *l = <span class="built_in">mergesort</span>(head);<span class="comment">//将左边链表分开</span></span><br><span class="line">        ListNode *r = <span class="built_in">mergesort</span>(slow);<span class="comment">//将右边链表分开</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(l,r);<span class="comment">//分开后的每一个链表都会运行merge进行合并</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode *<span class="title">merge</span><span class="params">(ListNode *l, ListNode *r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//合并有序链表</span></span><br><span class="line">        <span class="comment">//1. 新建dummy结点：左边声明指针 = 右边new一片空间出来</span></span><br><span class="line">        <span class="comment">//2.在左右都不为空时，谁小谁往cur后面接，注意cur接了结点之后要往后走一步</span></span><br><span class="line">        <span class="comment">//3.没有空的直接补到后面就好。return一点不能在里面的大括号里，要在函数域里</span></span><br><span class="line">        ListNode *dummyNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode *cur = dummyNode;</span><br><span class="line">        <span class="keyword">while</span>(l != <span class="literal">NULL</span> &amp;&amp; r != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l-&gt;val &lt; r-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = l;</span><br><span class="line">                l = l-&gt;next;</span><br><span class="line">                cur = cur-&gt;next; <span class="comment">//这一步容易掉，记得cur也要跟进指针</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = r;</span><br><span class="line">                r = r-&gt;next;</span><br><span class="line">                cur = cur-&gt;next; <span class="comment">//这一步容易掉，记得cur也要跟进指针</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cur-&gt;next = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cur-&gt;next = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//1. 通过快慢指针找到中点，一个走两步一个走一步</span></span><br><span class="line">    <span class="comment">//2. 再拆开，递归1，拆到最小的L链表和R链表</span></span><br><span class="line">    <span class="comment">//3. 再合并，比较值合并链表</span></span><br><span class="line">    <span class="comment">//新建一个链表的时候可以用dummy结点</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergesort</span>(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="返回倒数第k大的数"><a href="#返回倒数第k大的数" class="headerlink" title="返回倒数第k大的数"></a>返回倒数第k大的数</h2><p>acm 模式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> q[N], k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> q[l];</span><br><span class="line">    <span class="type">int</span> pos = <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>) + l;</span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[pos];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)<span class="comment">// 最后循环结束的时候i比j大，j指向的是q[pos]</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sl = j - l + <span class="number">1</span>; <span class="comment">//左边一共有sl个数</span></span><br><span class="line">    <span class="keyword">if</span>(k &lt;= sl) <span class="keyword">return</span> <span class="built_in">quick_sort</span>(l, j, k);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quick_sort</span>(j + <span class="number">1</span>, r, k - sl);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">quick_sort</span>(<span class="number">0</span>, n - <span class="number">1</span>, k));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">quickselect</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="built_in">randomPartition</span>(nums, l, r);<span class="comment">//这里这个函数的功能是：让返回的pos值前面都比pos小，后面的值都比pos大</span></span><br><span class="line">        <span class="keyword">if</span>(pos == index) &#123;<span class="comment">//这里相当于剪枝，</span></span><br><span class="line">        <span class="comment">//每一次循环都能保证pos处的值就是排序完整后这个位置上应该的值</span></span><br><span class="line">        <span class="comment">//如果index比pos小，就直接不管比pos大的部分了</span></span><br><span class="line">            <span class="keyword">return</span> nums[pos];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pos &lt; index) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">quickselect</span>(nums, pos + <span class="number">1</span>, r, index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">quickselect</span>(nums, l, pos - <span class="number">1</span>, index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">randomPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> q = <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>) + l;</span><br><span class="line">        <span class="built_in">swap</span>(nums[q], nums[r]);<span class="comment">//选中一个值当r，如果不随机，就直接到partition</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">partition</span>(nums, l, r);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> x = nums[r];</span><br><span class="line">        <span class="type">int</span> i = l - <span class="number">1</span>;<span class="comment">//i指向的值永远比x小，所以每次找到了比x小的值才会i++</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n = l;n &lt; r;n++) &#123;<span class="comment">//因为r是x值的位置，所以不要循环到r</span></span><br><span class="line">            <span class="keyword">if</span>(nums[n] &lt; x) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[n]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i + <span class="number">1</span>], nums[r]);<span class="comment">//最后记得把x值换过来</span></span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;<span class="comment">//返回对比的中间值的位置，中间值左边的数都比它小，右边的值都比它大</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickselect</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, nums.<span class="built_in">size</span>() - k );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/10/python%E7%9F%A5%E8%AF%86%E7%82%B9-%E5%88%87%E7%89%87%E4%B8%8E%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="篮球架上打砖块">
      <meta itemprop="description" content="Apodidae">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Upperlan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/10/python%E7%9F%A5%E8%AF%86%E7%82%B9-%E5%88%87%E7%89%87%E4%B8%8E%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">python知识点-切片与索引</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-10 20:03:14 / 修改时间：22:07:20" itemprop="dateCreated datePublished" datetime="2022-03-10T20:03:14+08:00">2022-03-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一些记一下更方便的特性"><a href="#一些记一下更方便的特性" class="headerlink" title="一些记一下更方便的特性"></a>一些记一下更方便的特性</h2><p>Python的列表list或者字符串str和C一样是从0开始的。所以当我们使用列表时</p>
<p><code>my_list[:3]</code>就是返回前三个对象，也就是一个<strong>前闭后开</strong>区间。因此在使用时，需要返回前n个元素，就直接<code>[:n]</code>即可。在此之上如果想把这个列表分割成两个不重叠的部分，写成<code>my_list[:n]</code>,<code>my_list[n:]</code>即可。</p>
<p>在计算切片或区间长度时区间<code>[3:6]</code>的长度就是后者-前者，即6-3=3。</p>
<h2 id="对象切片"><a href="#对象切片" class="headerlink" title="对象切片"></a>对象切片</h2><p><code>s[a:b:c]</code>意思是在a和b为之间以c为间隔取值。如果c为负值，则从b开始反向取值到a。</p>
<h3 id="多维切片与省略"><a href="#多维切片与省略" class="headerlink" title="多维切片与省略"></a>多维切片与省略</h3><p><code>[]</code>运算符里可以用逗号隔开进行索引，或者切片，NumPy也可以用这个特性。二维的numpy.ndarray就可以用<code>a[i, j]</code>这种形式来获取。或者<code>a[m:n, k:l]</code>的方式来获得二维切片。</p>
<p>省略的正确书写方法是三个英语句号<code>...</code>,不是Unicdoe里的半个省略号『…』。</p>
<p>如果有四位数组x，则<code>x[i, ...]</code>和<code>x[i, :, :, :]</code>是一个意思。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">l = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">l[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">l[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">20</span>,<span class="number">30</span>]</span><br><span class="line">l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">del</span> l[<span class="number">5</span>:<span class="number">7</span>]</span><br><span class="line">l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">l[<span class="number">3</span>::<span class="number">2</span>] = [<span class="number">11</span>,<span class="number">22</span>] <span class="comment"># 从下标3开始，算上下标为3的元素，每过2个元素选一个</span></span><br><span class="line">l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">22</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<h2 id="对序列使用"><a href="#对序列使用" class="headerlink" title="对序列使用+=,*="></a>对序列使用<code>+=</code>,<code>*=</code></h2><p>一个序列乘以一个整数，会产生一个新序列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] * <span class="number">5</span></span><br><span class="line">l</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<h3 id="由序列组成的列表"><a href="#由序列组成的列表" class="headerlink" title="由序列组成的列表"></a><strong>由序列组成的列表</strong></h3><p>如果要初始化一个嵌套着几个列表的列表，会有一些小问题。</p>
<h4 id="序列的别名与元组的相对不可变性"><a href="#序列的别名与元组的相对不可变性" class="headerlink" title="序列的别名与元组的相对不可变性"></a>序列的别名与元组的相对不可变性</h4><p>因为python语言中变量用<code>=</code>把一个变量x赋值给另外一个变量y时，即<code>y = x</code>时，不是C++中先声明一个新的变量，在给这个新的变量赋值，而是吧这个变量的引用赋给目标对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">a.append(<span class="number">4</span>)</span><br><span class="line">b</span><br><span class="line">-&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>在这里，如果用<code>is</code>运算符，如<code>a is b</code>判断的是a和b是不是指向内存中的同一片空间，（个人看法）即这两个变量中存储的是某个特定的内存地址，类似于C++中的指针，是相同存储空间的不同别名。而<code>==</code>就是比较值是否相同。</p>
<p>在复制列表时，默认是浅复制，即只是给同一个数据又新增了一个别名。一个相关示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="number">3</span>,[<span class="number">66</span>,<span class="number">55</span>,<span class="number">44</span>], (<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>)]</span><br><span class="line">l2 = <span class="built_in">list</span>(l1)</span><br><span class="line">l1.append(<span class="number">100</span>)</span><br><span class="line">l1[<span class="number">1</span>].remove(<span class="number">55</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;l1: &quot;</span>,l1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;l2: &quot;</span>,l2)</span><br></pre></td></tr></table></figure>
<p><img src="image-20220310214345242-6919826.png" alt="image-20220310214345242"></p>
<p>这里l2只是新建了一个list对象，内部存储的是元素的引用，所以l1[1]的改变会导致l2[1]一起变。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l2[<span class="number">1</span>] += [<span class="number">33</span>,<span class="number">22</span>]</span><br><span class="line">l2[<span class="number">2</span>] += (<span class="number">10</span>,<span class="number">11</span>)</span><br></pre></td></tr></table></figure>
<p><img src="image-20220310214636842.png" alt="image-20220310214636842"></p>
<p>这里的<code>()</code>运算符是改变的元组，对元组进行增量赋值时（<code>+=</code>），元组改变就会新建一个新的元组来存储新的元素。</p>
<h3 id="初始化一个三个列表包含三个元素的二维数组"><a href="#初始化一个三个列表包含三个元素的二维数组" class="headerlink" title="初始化一个三个列表包含三个元素的二维数组"></a>初始化一个三个列表包含三个元素的二维数组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">board=[[<span class="string">&#x27;_&#x27;</span>] * <span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="image-20220310215417642-6920459.png" alt="image-20220310215417642"></p>
<p>如果用<code>*</code>,就会出问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">board=[[<span class="string">&#x27;_&#x27;</span>] * <span class="number">3</span>]*<span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="image-20220310215526530-6920528.png" alt="image-20220310215526530"></p>
<p>其实list中三个元素都是指向同一个list数组。要注意这个问题</p>
<h2 id="NumPy数组的索引与切片"><a href="#NumPy数组的索引与切片" class="headerlink" title="NumPy数组的索引与切片"></a>NumPy数组的索引与切片</h2><p>除了满足list切片的一些应用外，还有一些其他需要注意的地方。</p>
<p><a target="_blank" rel="noopener" href="https://numpy.org/doc/stable/user/basics.indexing.html#basics-indexing">https://numpy.org/doc/stable/user/basics.indexing.html#basics-indexing</a></p>
<p>多维数组索引</p>
<p><img src="image-20220310220401796.png" alt="image-20220310220401796"></p>
<p><img src="image-20220310220530962-6921132.png" alt="image-20220310220530962"></p>
<p>待续</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-%E5%85%B3%E4%BA%8E%E5%8F%82%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%90%84%E7%A7%8D%E7%9A%84%E5%90%84%E7%A7%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="篮球架上打砖块">
      <meta itemprop="description" content="Apodidae">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Upperlan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-%E5%85%B3%E4%BA%8E%E5%8F%82%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%90%84%E7%A7%8D%E7%9A%84%E5%90%84%E7%A7%8D/" class="post-title-link" itemprop="url">深度学习基础-关于参数初始化的各种</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-08 20:32:12" itemprop="dateCreated datePublished" datetime="2022-03-08T20:32:12+08:00">2022-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-09 10:37:31" itemprop="dateModified" datetime="2022-03-09T10:37:31+08:00">2022-03-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">深度学习基础知识</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="参数初始化"><a href="#参数初始化" class="headerlink" title="参数初始化"></a>参数初始化</h2><p>目的：让深度学习模型在训练过程中梯度不为零，可能会加快梯度下降的收敛速度，降低训练错误的概率。</p>
<p>为了达到这个目的，初始化需要满足的条件：</p>
<ol>
<li>各层的激活值不会出现饱和迹象。（当输入过大或过小，激活函数的导数几乎为零，即梯度基本为0，称为饱和）</li>
<li>各层的激活值不为0.</li>
<li>尽量使各个层的激活值的方差保持一致。</li>
<li>尽量使各个层对  状态的梯度  的方差保持一致</li>
</ol>
<h2 id="几种初始化方式"><a href="#几种初始化方式" class="headerlink" title="几种初始化方式"></a>几种初始化方式</h2><ol>
<li>预训练模型</li>
<li>随机初始化：使权重分布符合正态分布，在训练深度神经网络时可能会造成梯度消失或者梯度爆炸（网络层数太深，梯度容易一直变大或者一直变小）</li>
<li>xavier初始化：基本思想事保持输入和输出的方差的一致，避免了所有的输出值都趋向于0；</li>
<li>kaiming初始化：何恺明提出的一种针对Relu的初始化方法，思想是在Relu网络中，假设有一半的神经元被激活,另一半为0。保持方差不变，只需要在xavier基础上除以2即可。</li>
</ol>
<h2 id="为什么不能全0初始化"><a href="#为什么不能全0初始化" class="headerlink" title="为什么不能全0初始化"></a>为什么不能全0初始化</h2><p>如果权重是0，那么中间层的输出是输入数据乘权重，就也是0且相等。神经网络计算出来的输出值是一样的，那么神经网络反向传播算法计算出来的梯度也是一样，参数更新值也一样。所以不管再训练多少次，这些隐藏层梯度都是一样，和线性模型就没有区别了。</p>
<h2 id="全部初始化为一样的值"><a href="#全部初始化为一样的值" class="headerlink" title="全部初始化为一样的值"></a>全部初始化为一样的值</h2><p>和上述一样，最后输出对于每一个参数反向传播的梯度都一样，相当于一个线性模型</p>
<h2 id="初始化为小的随机数"><a href="#初始化为小的随机数" class="headerlink" title="初始化为小的随机数"></a>初始化为小的随机数</h2><p>是打破网络对称性的一个普遍的解决办法。神经元一开始的权重值是随机的，所以梯度反向传播时会有不同的更新。看起来初始化的值类似于</p>
<script type="math/tex; mode=display">
\mathbf{w} =0.01 \times np.random.randn(D,H)</script><p><img src="image-20220308213348126-6746429.png" alt="image-20220308213348126"></p>
<p>0.01会试w变小，w很大时会导致神经元输出很大，再通过激活函数后容易梯度消失，饱和。当然如果太小，输出接近激活函数在负方向接近饱和，也容易梯度消失。</p>
<h2 id="预训练"><a href="#预训练" class="headerlink" title="预训练"></a>预训练</h2><p>只谈finetune策略</p>
<ol>
<li>把预训练模型当做权重初始化权重，对整个网络进行完全训练，精度比2高很多。</li>
<li>训练一些层而冻结其他层，一般较低层学习的是通用特征，较高层适用的是逻辑含义更复杂的抽象特征。如果模型很大，数据集不大，会冻结更多层以免过拟合。如果数据很多，模型不大，就可以训练更多层。一般只训练最后的分类层</li>
<li>冻结卷积块，即卷积层，池化层等堆积的一个卷积模块。这种情况适用于训练、冻结平衡的极端情况。</li>
</ol>
<h2 id="为什么深度学习模型难训练"><a href="#为什么深度学习模型难训练" class="headerlink" title="为什么深度学习模型难训练"></a>为什么深度学习模型难训练</h2><p>1.梯度消失</p>
<p>梯度反向传播的过程中越来越小，前面层比后面层学的慢，所以学习会卡住。反向传播过程中前面的层的梯度收到后面所有层的影响，如果梯度值很小，更新信息在传播中指数形式衰减，发生梯度消失。</p>
<p>可能会由：</p>
<p>学习率大小，网络初始化参数，激活函数的边缘效应（饱和）</p>
<p>2.梯度爆炸</p>
<p>梯度也可能在传播中指数增大，导致权重大幅度更新，甚至溢出，变成NaN值，无法更新</p>
<p>3.权重矩阵退化导致模型的有效自由度变小。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/07/%E5%85%B3%E4%BA%8EBatch-Normalization%E7%9A%84%E5%90%84%E7%A7%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="篮球架上打砖块">
      <meta itemprop="description" content="Apodidae">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Upperlan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/%E5%85%B3%E4%BA%8EBatch-Normalization%E7%9A%84%E5%90%84%E7%A7%8D/" class="post-title-link" itemprop="url">深度学习基础-关于Normalization的各种</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-07 20:49:15" itemprop="dateCreated datePublished" datetime="2022-03-07T20:49:15+08:00">2022-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 13:59:29" itemprop="dateModified" datetime="2022-06-06T13:59:29+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">深度学习基础知识</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="归一化（Normalization）"><a href="#归一化（Normalization）" class="headerlink" title="归一化（Normalization）"></a>归一化（Normalization）</h1><p>目的：</p>
<ol>
<li>应用层面需要统一量纲</li>
<li>在使用梯度下降发求解最优化问题时，归一化或标准化后可以加快梯度下降的求解速度，即提升收敛速度</li>
<li>可以避免神经元饱和。神经元的激活在0或1时会饱和，这些区域梯度几乎为0，这样的话在反向传播的时候局部梯度也会接近0。因此归一化可以有效缓解梯度消失</li>
<li>避免数据中小的数值被大数值吞噬，也避免数值太大引发的数值问题。（输入图像的值）</li>
</ol>
<h2 id="为什么要归一化"><a href="#为什么要归一化" class="headerlink" title="为什么要归一化"></a>为什么要归一化</h2><p>假设w1在[-10,10],w2在[-100,100]，梯度每次都前进一个单位，则w1在搜索全局最优时会相对来说走的更『快』。即提高了收敛速度</p>
<h2 id="归一化类型"><a href="#归一化类型" class="headerlink" title="归一化类型"></a>归一化类型</h2><h3 id="线性归一化"><a href="#线性归一化" class="headerlink" title="线性归一化"></a>线性归一化</h3><script type="math/tex; mode=display">
x^{'}=\frac{x-min(x)}{max(x)-min(x)}</script><p><img src="image-20220307211017670-6658619.png" alt="image-20220307211017670"></p>
<h2 id="标准归一化"><a href="#标准归一化" class="headerlink" title="标准归一化"></a>标准归一化</h2><script type="math/tex; mode=display">
x^{'}=\frac{x-\mu}{\sigma}</script><p><img src="image-20220307211225372-6658746.png" alt="image-20220307211225372"></p>
<p>归一化后均值为0，标准差为1，$ \mu $ 为左右样本数据的均值，$\sigma$ 是所有样本数据的标准差。</p>
<h1 id="批归一化（Batch-Normalization）"><a href="#批归一化（Batch-Normalization）" class="headerlink" title="批归一化（Batch Normalization）"></a>批归一化（Batch Normalization）</h1><p>在网络中间对数据进行归一化</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>减少对超参数的依赖，某些情况下可以取消Dropout方法或者L2正则项参数</li>
<li>减少对学习率的要求（加强对学习率参数的鲁棒性）</li>
<li>破坏原来的数据分布，一定程度上缓解过拟合，防止每批训练中某一个样本经常被选中</li>
<li>减少梯度消失（数据分布奇怪使激活函数输入接近0或者1，梯度很小）</li>
</ol>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>$x_{i}$是上一层的输出结果，B和Y是学习参数</p>
<ol>
<li>计算上一层输出数据的均值</li>
</ol>
<script type="math/tex; mode=display">
\mu _{\beta}=\frac{1}{m} \sum_{i=1}^{m}\left ( x_{i} \right)</script><p><img src="image-20220307212515863-6659517.png" alt="image-20220307212515863"></p>
<ol>
<li>计算上一层输出数据的标准差<script type="math/tex; mode=display">
\sigma_{\beta}^{2}=\frac{1}{m} \sum_{i=1}^{m}(x_{i}-\mu _{\beta})^{2}</script></li>
</ol>
<p><img src="image-20220307212905080-6659746.png" alt="image-20220307212905080"></p>
<ol>
<li><p>进行归一化处理，得到</p>
<script type="math/tex; mode=display">
x_{i}=\frac{x_{i}+\mu _{\beta}}{\sqrt{\sigma_{\beta}^{2}+\epsilon}}</script><p><img src="image-20220307213044587.png" alt="image-20220307213044587"></p>
<p>分母加一个极小值防止除0</p>
</li>
<li><p>重构</p>
<script type="math/tex; mode=display">
y_{i}=\gamma \hat{x_{i}}+\beta</script><p><img src="image-20220307213242003-6659962.png" alt="image-20220307213242003"></p>
<p>gamma和beta是可学习参数。此时的均值是计算所有批次的mu_{beta}值的平均值得到的，标准差是每个批次的标准差的无偏估计。</p>
</li>
</ol>
<h2 id="和组归一化比较（Group-Normalization）"><a href="#和组归一化比较（Group-Normalization）" class="headerlink" title="和组归一化比较（Group Normalization）"></a>和组归一化比较（Group Normalization）</h2><p>如果batch比较小，导致估计的值和整个数据集的真实均值方差差距较大，BN的误差就会很大。</p>
<p>GN是将通道（channel）分成组，在每组内计算归一化的均值和方差，其准确度在各种批量大小下都很稳定</p>
<h2 id="和权重归一化比较（weight-normalization）"><a href="#和权重归一化比较（weight-normalization）" class="headerlink" title="和权重归一化比较（weight normalization）"></a>和权重归一化比较（weight normalization）</h2><p>WN是对网络权重W进行归一化，适用于RNN，因为RNN处理的队列是变长的，基于时间状态计算，很难保存每个状态下的均值和方差，效率很低。</p>
<h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p> 适用于batch较大，数据分布比较接近的场景，不适用于动态网络和RNN结构。</p>
<ul>
<li>允许较大的学习率</li>
<li>减弱对初始化的强依赖性，降低权重初始化的困难</li>
<li>保持隐藏层中数值的均值，方差不变，控制数据的分布范围，避免梯度消失和梯度爆炸</li>
<li>BN可以起到和dropout一样的正则化效果，在正则化方面，一般全连接层用dropout,卷积层拥BN</li>
<li>缓解内部协变量偏移问题，增加训练速度</li>
</ul>
<h3 id="BN存在的问题"><a href="#BN存在的问题" class="headerlink" title="BN存在的问题"></a>BN存在的问题</h3><ul>
<li>每次是在一个batch上计算均值、方差，如果batch size太小，则计算的均值、方差不足以代表整个数据分布。</li>
<li>batch size太大：会超过内存容量；需要跑更多的epoch，导致总训练时间变长；会直接固定梯度下降的方向，导致很难更新。</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h2 id="梯度方向推导"><a href="#梯度方向推导" class="headerlink" title="梯度方向推导"></a>梯度方向推导</h2><p><img src="118059082-39d1a500-b3c2-11eb-80f8-75f2bf677451.png" alt="image"></p>
<p>背诵版本：</p>
<p><img src="118059220-9208a700-b3c2-11eb-841f-73781fa93342.png" alt="image"></p>
<p>训练和测试时的区别：</p>
<p><img src="68747470733a2f2f67697465652e636f6d2f6c6562686f7279692f506963476f506963747572654265642f7261772f6d61737465722f696d672f32303231303830333232353131312e706e67.png" alt="image-20210803225110049"></p>
<h2 id="常用的归一化层"><a href="#常用的归一化层" class="headerlink" title="常用的归一化层"></a>常用的归一化层</h2><p><img src="68747470733a2f2f66696c65732e6d646e6963652e636f6d2f757365722f363933352f37383432636533652d613630662d346333372d623532302d3938383531353337663136642e706e67.png" alt="img"></p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013289254/article/details/99690730">深度学习中的五种归一化（BN、LN、IN、GN和SN）方法简介</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liuxiao214/article/details/81037416">BatchNormalization、LayerNormalization、InstanceNorm、GroupNorm、SwitchableNorm总结</a></p>
</li>
</ul>
<h1 id="BN代码实现，以及多卡训练的sync-bn"><a href="#BN代码实现，以及多卡训练的sync-bn" class="headerlink" title="BN代码实现，以及多卡训练的sync_bn"></a>BN代码实现，以及多卡训练的sync_bn</h1><p>用numpy实现BN：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> module <span class="keyword">import</span> Layers</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BatchNormlization</span>(<span class="title class_ inherited__">Layers</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    https://blog.csdn.net/weixin_44754861/article/details/108343938?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-5.pc_relevant_paycolumn_v3&amp;spm=1001.2101.3001.4242.4&amp;utm_relevant_index=7</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, x,eps =<span class="number">1e-7</span>, momentum =<span class="number">0.9</span>, mode = <span class="string">&quot;train&quot;</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(BatchNormlization).__init__(name)</span><br><span class="line">        self.eps =eps</span><br><span class="line">        self.<span class="built_in">input</span> = x</span><br><span class="line">        n, c, h, w = x.shape</span><br><span class="line">        self.momentum = momentum</span><br><span class="line">        <span class="comment"># 相同batch里不同样本的相同的通道来计算均值和方差</span></span><br><span class="line">        self.running_mean = np.zeros(c)</span><br><span class="line">        self.running_var = np.zeros(c)</span><br><span class="line">        self.gamma = np.random(c)</span><br><span class="line">        self.beta =np.random(c)</span><br><span class="line">        self.mode = mode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_dim</span>(<span class="params">x, dim</span>):</span><br><span class="line">        <span class="keyword">return</span> np.expand_dims(x, axis=dim) <span class="comment"># batch </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self</span>):</span><br><span class="line">        ib, ic, ih, iw = self.<span class="built_in">input</span>.shape</span><br><span class="line"></span><br><span class="line">        self.<span class="built_in">input</span> = self.<span class="built_in">input</span>.transpose(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>).reshape([ic, -<span class="number">1</span>]) <span class="comment"># n,c,h,w -&gt;c, n*h*w</span></span><br><span class="line">        <span class="keyword">if</span> self.mode ==<span class="string">&quot;train&quot;</span>:</span><br><span class="line">            self.var = np.sqrt(self.var +self.eps) <span class="comment"># </span></span><br><span class="line">            self.mean = np.mean(self.<span class="built_in">input</span>, axis=<span class="number">0</span>) <span class="comment"># 每个channel的均值</span></span><br><span class="line">            self.mean = self.add_dim(self.mean, <span class="number">1</span>) <span class="comment"># 与后面的self.input 维度一致</span></span><br><span class="line">            self.var = np.var(self.<span class="built_in">input</span>, axis=<span class="number">0</span>) <span class="comment">#每个channel的方差</span></span><br><span class="line">            self.var = self.add_dim(self.var , <span class="number">1</span>)</span><br><span class="line">            self.gamma = self.add_dim(self.gamma, <span class="number">1</span>)</span><br><span class="line">            self.beta = self.add_dim(self.beta, <span class="number">1</span>)</span><br><span class="line">            self.running_mean = self.momentum * self.running_mean + (<span class="number">1</span>-self.momentum) *self.mean</span><br><span class="line">            self.running_var = self.momentum * self.running_var + (<span class="number">1</span>-self.momentum) *self.var</span><br><span class="line">            self.input_ = (self.<span class="built_in">input</span> -  self.running_mean)/(self.running_var + self.eps)</span><br><span class="line">            dout = (self.input_*self.gamma +self.beta ).reshape(ic,ib, ih, iw).transpose(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">            self.cache = (self.input_, self.gamma, (self.<span class="built_in">input</span> - self.running_mean, self.running_var + self.eps))</span><br><span class="line">        <span class="keyword">elif</span> self.mode ==<span class="string">&quot;test&quot;</span>:</span><br><span class="line">            x_hat = (self.<span class="built_in">input</span> - self.running_mean) / (np.sqrt(self.running_var + self.eps))</span><br><span class="line">            dout = self.gamma * x_hat + self.beta</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Invalid forward batch normlization mode&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> dout, self.cache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self, dout</span>):</span><br><span class="line">        N, D = dout.shape</span><br><span class="line">        x_, gamma, x_minus_mean, var_plus_eps =self.cache</span><br><span class="line"></span><br><span class="line">        <span class="comment"># calculate gradients</span></span><br><span class="line">        dgamma = np.<span class="built_in">sum</span>(x_ * dout, axis=<span class="number">0</span>)</span><br><span class="line">        dbeta = np.<span class="built_in">sum</span>(dout, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        dx_ = np.matmul(np.ones((N,<span class="number">1</span>)), gamma.reshape((<span class="number">1</span>, -<span class="number">1</span>))) * dout</span><br><span class="line">        dx = N * dx_ - np.<span class="built_in">sum</span>(dx_, axis=<span class="number">0</span>) - x_ * np.<span class="built_in">sum</span>(dx_ * x_, axis=<span class="number">0</span>)</span><br><span class="line">        dx *= (<span class="number">1.0</span>/N) / np.sqrt(var_plus_eps)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dx, dgamma, dbeta</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, lr, dgamma, dbeta</span>):</span><br><span class="line">        self.gamma -= dgamma *lr</span><br><span class="line">        self.beta -= dbeta*lr</span><br></pre></td></tr></table></figure>
<p>BN 的性能和 batch size 有很大的关系。batch size 越大，BN 的统计量也会越准。然而像检测这样的任务，占用显存较高，一张显卡往往只能拿较少的图片（比如 2 张）来训练，这就导致 BN 的表现变差。一个解决方式是 SyncBN：所有卡共享同一个 BN，得到全局的统计量。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/337732517">PyTorch 源码解读之 BN &amp; SyncBN：BN 与 多卡同步 BN 详解</a></li>
</ul>
<p>单卡上的 BN 会计算该卡对应输入的均值、方差，然后做 Normalize；SyncBN 则需要得到全局的统计量，也就是“所有卡上的输入”对应的均值、方差。一个简单的想法是分两个步骤：</p>
<ol>
<li>每张卡单独计算其均值，然后做一次同步，得到全局均值</li>
<li>用全局均值去算每张卡对应的方差，然后做一次同步，得到全局方差</li>
</ol>
<p>但两次同步会消耗更多时间，事实上一次同步就可以实现 </p>
<p><img src="v2-98c5ec4adfd6b827e25127af0d0ba988_720w.jpg" alt="img"></p>
<h2 id="Layer-Normalization"><a href="#Layer-Normalization" class="headerlink" title="Layer Normalization"></a>Layer Normalization</h2><h3 id="LN为了解决什么问题？"><a href="#LN为了解决什么问题？" class="headerlink" title="LN为了解决什么问题？"></a>LN为了解决什么问题？</h3><p>如果一个神经元的输入分布在神经网络中是动态变化的，比如循环神经网络（RNN），那么无法应用BN操作。因此，针对BN不适用于深度不固定的网络（RNN，sequeece长度不一致）的问题，LN针对单个训练样本进行归一化操作，即对每一个样本中多个通道（channel）进行归一化操作。</p>
<p>LN针对单个样本进行归一化操作。具体来说，对于输入<img src="关于Batch-Normalization的各种/image-20220606133317938-4493599.png" alt="image-20220606133317938">,LN对每个样本的C、H、W维度上的数据求均值和方差，保留N维度。LN中不同的输入样本有不同的均值和方差。</p>
<p><img src="关于Batch-Normalization的各种/image-20220606133711568-4493833.png" alt="image-20220606133711568"></p>
<script type="math/tex; mode=display">
\mu_n(x)=\frac{1}{CHW}\sum_{c=1}^{C}\sum_{h=1}^{H}\sum_{w=1}^{W}x_{nchw}</script><p><img src="关于Batch-Normalization的各种/image-20220606133753105-4493874.png" alt="image-20220606133753105"></p>
<h3 id="LN的优势"><a href="#LN的优势" class="headerlink" title="LN的优势"></a>LN的优势</h3><p>不需要批训练，在单条数据内部机就能归一化。不依赖batch_size和输入sequence的长度，因此可以用于batch size为1和RNN中。LN用于RNN效果比较明显，但是在CNN上，效果不如BN。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># feature1 = np.array([[[0, 1], [1, -1]], [[-1, 0], [0, 2]]])</span></span><br><span class="line"><span class="comment"># feature2 = np.array([[[1, 0], [3, 1]], [[0, 1], [4, -1]]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Examples::</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; input = torch.randn(20, 5, 10, 10)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; # With Learnable Parameters</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; m = nn.LayerNorm(input.size()[1:])</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; # Without Learnable Parameters</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; m = nn.LayerNorm(input.size()[1:], elementwise_affine=False)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; # Normalize over last two dimensions</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; m = nn.LayerNorm([10, 10])</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; # Normalize over last dimension of size 10</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; m = nn.LayerNorm(10)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; # Activating the module</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; output = m(input)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">sample1 = torch.tensor([[[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>]], [[-<span class="number">1</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>]]],dtype=torch.float32)</span><br><span class="line">sample2 = torch.tensor([[[<span class="number">0</span>, -<span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>]], [[<span class="number">0</span>, -<span class="number">1</span>], [<span class="number">3</span>, <span class="number">1</span>]]],dtype=torch.float32)</span><br><span class="line">ln = nn.LayerNorm([<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],elementwise_affine=<span class="literal">False</span>)</span><br><span class="line">output1 = ln(sample1)</span><br><span class="line">output2 = ln(sample2)</span><br><span class="line"><span class="built_in">print</span>(output1)</span><br><span class="line"><span class="comment"># print(output2)</span></span><br><span class="line"></span><br><span class="line">mean = np.mean(sample1.numpy())</span><br><span class="line">var = np.var(sample1.numpy())</span><br><span class="line">output3 = (sample1.numpy()-mean)/np.sqrt(var+<span class="number">1e-5</span>)</span><br><span class="line"><span class="built_in">print</span>(mean)</span><br><span class="line"><span class="built_in">print</span>(var)</span><br><span class="line"><span class="built_in">print</span>(output3)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/07/Python%E7%9F%A5%E8%AF%86%E7%82%B9-%E8%A3%85%E9%A5%B0%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="篮球架上打砖块">
      <meta itemprop="description" content="Apodidae">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Upperlan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/Python%E7%9F%A5%E8%AF%86%E7%82%B9-%E8%A3%85%E9%A5%B0%E5%99%A8/" class="post-title-link" itemprop="url">Python知识点-装饰器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-07 19:45:31" itemprop="dateCreated datePublished" datetime="2022-03-07T19:45:31+08:00">2022-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-10 20:03:51" itemprop="dateModified" datetime="2022-03-10T20:03:51+08:00">2022-03-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="实现一个简单的装饰器"><a href="#实现一个简单的装饰器" class="headerlink" title="实现一个简单的装饰器"></a>实现一个简单的装饰器</h3><p>一句话总结：把别装饰的函数替换成新函数，二者接受相同的参数，一般情况下返回被装饰的函数本该返回的值，同时还会做一些额外操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个简单的装饰器，输出函数的运行时间</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clock</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">clocked</span>(<span class="params">*args</span>): <span class="comment">#*args的用法：当传入的参数个数未知，且不需要知道参数名称时。</span></span><br><span class="line">      <span class="comment">#**args的用法：当传入的参数个数未知，但需要知道参数的名称时(立马想到了字典，即键值对)</span></span><br><span class="line">        begin = time.perf_counter() <span class="comment"># 调用func时的时间</span></span><br><span class="line">        result = func(*args) <span class="comment">#运行被装饰函数</span></span><br><span class="line">        elapsed = time.perf_counter() - begin <span class="comment"># 函数运行时间</span></span><br><span class="line">        name = func.__name__ <span class="comment"># 得到被装饰函数名</span></span><br><span class="line">        arg_str = <span class="string">&#x27;,&#x27;</span>.join(<span class="built_in">repr</span>(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args) <span class="comment"># 显示被装饰函数的传入参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[%0.8fs] %s(%s) -&gt; %r&#x27;</span> % (elapsed, name, arg_str, result)) </span><br><span class="line">        <span class="comment"># func运行后，输出格式是[时间] 函数名（传入参数）-&gt; 函数结果</span></span><br><span class="line">        <span class="keyword">return</span> result <span class="comment"># 记得返回结果！</span></span><br><span class="line">    <span class="keyword">return</span> clocked <span class="comment"># 被装饰函数已经被换成了一个新的函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用装饰器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> clockdeco <span class="keyword">import</span> clock <span class="comment"># 直接import</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">snooze</span>(<span class="params">seconds</span>):</span><br><span class="line">    time.sleep(seconds)</span><br><span class="line"></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">factorial</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n*factorial(n-<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span> * <span class="number">40</span>, <span class="string">&#x27;Calling snooze(.123)&#x27;</span>)</span><br><span class="line">snooze(<span class="number">.123</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span> * <span class="number">40</span>, <span class="string">&#x27;Calling factorial(6)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;6! = &#x27;</span>, factorial(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">**************************************** Calling snooze(<span class="number">.123</span>)</span><br><span class="line">[<span class="number">0.12749738</span>s] snooze(<span class="number">0.123</span>) -&gt; <span class="literal">None</span></span><br><span class="line">**************************************** Calling factorial(<span class="number">6</span>)</span><br><span class="line">[<span class="number">0.00000154</span>s] factorial(<span class="number">1</span>) -&gt; <span class="number">1</span></span><br><span class="line">[<span class="number">0.00010962</span>s] factorial(<span class="number">2</span>) -&gt; <span class="number">2</span></span><br><span class="line">[<span class="number">0.00018708</span>s] factorial(<span class="number">3</span>) -&gt; <span class="number">6</span></span><br><span class="line">[<span class="number">0.00026196</span>s] factorial(<span class="number">4</span>) -&gt; <span class="number">24</span></span><br><span class="line">[<span class="number">0.00049425</span>s] factorial(<span class="number">5</span>) -&gt; <span class="number">120</span></span><br><span class="line">[<span class="number">0.00076513</span>s] factorial(<span class="number">6</span>) -&gt; <span class="number">720</span></span><br><span class="line"><span class="number">6</span>! =  <span class="number">720</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<p>但此时如果访问被装饰函数的<code>__name__</code>和<code>__doc__</code>时就被clocked遮盖了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">snooze.__name__</span><br><span class="line"><span class="string">&#x27;clocked&#x27;</span></span><br></pre></td></tr></table></figure>
<p>可以用functools模块中的functools.wraps来构建行为良好的解释器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个简单的装饰器，输出函数的运行时间</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clock</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">clocked</span>(<span class="params">*args, **kwargs</span>): <span class="comment">#*args的用法：当传入的参数个数未知，且不需要知道参数名称时。</span></span><br><span class="line">        <span class="comment">#**args的用法：当传入的参数个数未知，但需要知道参数的名称时(立马想到了字典，即键值对)</span></span><br><span class="line">        begin = time.time() <span class="comment"># 调用func时的时间</span></span><br><span class="line">        result = func(*args, **kwargs) <span class="comment">#运行被装饰函数</span></span><br><span class="line">        elapsed = time.time() - begin <span class="comment"># 函数运行时间</span></span><br><span class="line">        name = func.__name__ <span class="comment"># 得到被装饰函数名</span></span><br><span class="line">        arg_lst = []</span><br><span class="line">        <span class="keyword">if</span> args:</span><br><span class="line">            arg_lst.append(<span class="string">&#x27;,&#x27;</span>.join(<span class="built_in">repr</span>(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args))</span><br><span class="line">        <span class="keyword">if</span> kwargs:</span><br><span class="line">            pairs = [<span class="string">&#x27;%s=%r&#x27;</span> % (k, w) <span class="keyword">for</span> k, w <span class="keyword">in</span> <span class="built_in">sorted</span>(kwargs.items())]</span><br><span class="line">            arg_lst.append(<span class="string">&#x27;,&#x27;</span>.join(pairs))</span><br><span class="line">        arg_str = <span class="string">&#x27;,&#x27;</span>.join(arg_lst) <span class="comment"># 显示被装饰函数的传入参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[%0.8fs] %s(%s) -&gt; %r&#x27;</span> % (elapsed, name, arg_str, result)) </span><br><span class="line">        <span class="comment"># func运行后，输出格式是[时间] 函数名（传入参数）-&gt; 函数结果</span></span><br><span class="line">        <span class="keyword">return</span> result <span class="comment"># 记得返回结果！</span></span><br><span class="line">    <span class="keyword">return</span> clocked <span class="comment"># 被装饰函数已经被换成了一个新的函数</span></span><br></pre></td></tr></table></figure>
<h3 id="叠放装饰器"><a href="#叠放装饰器" class="headerlink" title="叠放装饰器"></a>叠放装饰器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@d1</span></span><br><span class="line"><span class="meta">@d2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;f&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">f() = d1(d2(f))</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/07/Vision-Transformer%E5%A4%84%E7%90%86%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E5%9B%BE%E5%83%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="篮球架上打砖块">
      <meta itemprop="description" content="Apodidae">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Upperlan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/Vision-Transformer%E5%A4%84%E7%90%86%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E5%9B%BE%E5%83%8F/" class="post-title-link" itemprop="url">Vision Transformer处理恶意软件图像</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-07 12:06:39 / 修改时间：20:43:10" itemprop="dateCreated datePublished" datetime="2022-03-07T12:06:39+08:00">2022-03-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A7%91%E7%A0%94%E4%B8%8E%E8%AE%BA%E6%96%87/" itemprop="url" rel="index"><span itemprop="name">科研与论文</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h1><p>将恶意软件的PE十六进制机器码转换成序列，再根据ASCII码表将序列值转化成像素点的数值，最后用多种方法填充成一幅图像，供Vision Transformer模型进行分类。</p>
<h1 id="1-简要前言：转换成图像的意义"><a href="#1-简要前言：转换成图像的意义" class="headerlink" title="1.简要前言：转换成图像的意义"></a>1.简要前言：转换成图像的意义</h1><p>可以利用视觉领域先进的模型与算法，更好的提取PE恶意软件十六进制代码里的特征。</p>
<p><img src="image-20220307121458807-6626500.png" alt="image-20220307121458807"></p>
<p>上图就是我们直接读取可执行PE文件的十六进制代码的结果。最左边一列是这些代码在虚拟内存中的地址，右边是每个地址存储的待执行代码。很明显几乎不可能直观的看出来这些代码的逻辑和操作。而如果用机器学习进行分类，就需要很多关于此类数据的先验知识对这些数据进行特征提取或降维。而深度学习模型的一个特点就是能够找到众多输入数据中所包含的特征，如图像分类问题中，CNN有能力识别到指定图片中目标对象的类别。因此直觉上深度学习模型是处理此类问题十分有效的工具。</p>
<p>而深度学习模型的输入数据一般是统一成一个指定类型的数据。目前图像领域里有很多sota模型可以对图像类数据的特征进行提取，分类，因此如果能让输入数据具备类似图像上的特征，即像素点数据分布的特征，那么就可以利用视觉类深度学习模型来处理恶意软件的分类问题。所以如何将恶意软件进行图像化就是一个很重要的问题了。</p>
<p>使用视觉类DL模型的另外一个原因是恶意软件的序列并不是严格意义上的时间序列，而是包含了丰富的语义特征的序列，就像NLP里单词和单词之间，单词与句子之间的语义一样。用于NLP模型的恶意软件数据集很难构建出来，因为需要大量的可执行文件反汇编，逆向工程的先验知识。因此图像类深度学习模型，或者由NLP领域发展而来的Vision Transformer模型是目前我实验中比较有效的模型。</p>
<h1 id="2-Vision-Transformer特点"><a href="#2-Vision-Transformer特点" class="headerlink" title="2.Vision Transformer特点"></a>2.Vision Transformer特点</h1><p>Vision Transformer模型的特点是和self attention模块的功能高度相关的。从宏观上来说，self-attention layer能够并行输入一个sequence，输出一个sequence，<strong>它的每一个输出都看过了整个的输入sequence，这一点与bi-directional RNN相同。但是神奇的地方是：它的每一个输出都可以并行化计算。</strong></p>
<p><img src="image-20220307134209708-6631731.png" alt="image-20220307134209708"></p>
<p>用CNN，你确实也可以做到输入是一个sequence，输出是另外一个sequence。但是，表面上CNN和Vision Transformer可以做到相同的输入和输出，但是CNN只能考虑非常有限的内容。比如在我们下图中CNN的filter只考虑了3个vector，不像RNN可以考虑之前的所有vector。但是CNN也不是没有办法考虑很长时间的dependency的，你只需要堆叠filter，多堆叠几层，上层的filter就可以考虑比较多的资讯，比如，第二层的filter (蓝色的三角形)看了6个vector，所以，只要叠很多层，就能够看很长时间的资讯。</p>
<p>做CNN的时候是只考虑感受野红框里面的资讯，而不是图片的全局信息。所以CNN可以看作是一种简化版本的self-attention。</p>
<p>或者可以反过来说，self-attention是一种复杂化的CNN，在做CNN的时候是只考虑感受野红框里面的资讯，而感受野的范围和大小是由人决定的。但是self-attention由attention找到相关的pixel，就好像是感受野的范围和大小是自动被学出来的，所以CNN可以看做是self-attention的特例，如图所示。</p>
<p><img src="v2-f28a8b0295863ab78d92a281ae55fce2_720w.jpg" alt="img"></p>
<p><img src="v2-f268035371aa22a350a317fc237a04f7_720w.jpg" alt="img"></p>
<p>既然self-attention是更广义的CNN，则这个模型更加flexible。而我们认为，一个模型越flexible，训练它所需要的数据量就越多，所以在训练self-attention模型时就需要更多的数据，论文 ViT 中有印证，它需要的数据集是有3亿张图片的JFT-300，而如果不使用这么多数据而只使用ImageNet，则性能不如CNN。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/06/Swin-Transformer%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="篮球架上打砖块">
      <meta itemprop="description" content="Apodidae">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Upperlan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/06/Swin-Transformer%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Swin Transformer笔记-Shifted机制与MSA机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-06 16:12:19" itemprop="dateCreated datePublished" datetime="2022-03-06T16:12:19+08:00">2022-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-06 11:52:02" itemprop="dateModified" datetime="2022-04-06T11:52:02+08:00">2022-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A7%91%E7%A0%94%E4%B8%8E%E8%AE%BA%E6%96%87/" itemprop="url" rel="index"><span itemprop="name">科研与论文</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文来自：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/367111046">https://zhuanlan.zhihu.com/p/367111046</a></p>
<p>我加上一些代码的注释方便阅读</p>
<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="9da511d843648230e72d5dc78e58a148-6556114.png" alt="9da511d843648230e72d5dc78e58a148"></p>
<p>一共包含4个Stage，每个stage都会缩小输入特征图的分辨率，像CNN一样逐层扩大感受野。框架代码大致如下，省略了一些参数与层的细节。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SwinTransformer</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">...</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># absolute position embedding</span></span><br><span class="line">        <span class="keyword">if</span> self.ape: <span class="comment"># 是否加入位置编码</span></span><br><span class="line">            self.absolute_pos_embed = nn.Parameter(torch.zeros(<span class="number">1</span>, num_patches, embed_dim))</span><br><span class="line">            <span class="comment"># 每个head的shape都是num_patches * embed_dim</span></span><br><span class="line">        self.pos_drop = nn.Dropout(p=drop_rate)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># build layers</span></span><br><span class="line">        self.layers = nn.ModuleList()</span><br><span class="line">        <span class="keyword">for</span> i_layer <span class="keyword">in</span> <span class="built_in">range</span>(self.num_layers):</span><br><span class="line">            layer = BasicLayer(...)</span><br><span class="line">            self.layers.append(layer)</span><br><span class="line"></span><br><span class="line">        self.norm = norm_layer(self.num_features)</span><br><span class="line">        self.avgpool = nn.AdaptiveAvgPool1d(<span class="number">1</span>)</span><br><span class="line">        self.head = nn.Linear(self.num_features, num_classes) <span class="keyword">if</span> num_classes &gt; <span class="number">0</span> <span class="keyword">else</span> nn.Identity()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward_features</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.patch_embed(x) <span class="comment"># 先取得图象块的embeddings</span></span><br><span class="line">        <span class="keyword">if</span> self.ape: <span class="comment"># 位置编码是否需要</span></span><br><span class="line">            x = x + self.absolute_pos_embed</span><br><span class="line">        x = self.pos_drop(x) <span class="comment"># dropout层</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers:</span><br><span class="line">            x = layer(x)</span><br><span class="line"></span><br><span class="line">        x = self.norm(x)  <span class="comment"># B L C</span></span><br><span class="line">        x = self.avgpool(x.transpose(<span class="number">1</span>, <span class="number">2</span>))  <span class="comment"># B C L</span></span><br><span class="line">        x = torch.flatten(x, <span class="number">1</span>) <span class="comment"># 展平</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.forward_features(x)</span><br><span class="line">        x = self.head(x) <span class="comment"># 线性层</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<p>其中有几个地方处理方法与ViT不同：</p>
<ul>
<li>ViT在输入会给embedding进行位置编码。而Swin-T这里则是作为一个<strong>可选项</strong>（<code>self.ape</code>），Swin-T是在计算Attention的时候做了一个<code>相对位置编码</code></li>
<li>ViT会单独加上一个可学习参数，作为分类的token。而Swin-T则是<strong>直接做平均</strong>，输出分类，有点类似CNN最后的全局平均池化层</li>
</ul>
<p>接下来我们看下各个组件的构成</p>
<h2 id="Patch-Embedding"><a href="#Patch-Embedding" class="headerlink" title="Patch Embedding"></a><strong>Patch Embedding</strong></h2><p>在输入进Block前，我们需要将图片切成一个个patch，然后嵌入向量。</p>
<p>具体做法是对原始图片裁成一个个 <code>patch_size * patch_size</code>的窗口大小，然后进行嵌入。</p>
<p>这里可以通过二维卷积层，<strong>将stride，kernelsize设置为patch_size大小</strong>。设定输出通道来确定嵌入向量的大小。最后将H,W维度展开，并移动到第一维度，这里的处理与ViT是一样的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PatchEmbed</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, img_size=<span class="number">224</span>, patch_size=<span class="number">4</span>, in_chans=<span class="number">3</span>, embed_dim=<span class="number">96</span>, norm_layer=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        img_size = to_2tuple(img_size) <span class="comment"># -&gt;  将int类型的size转换成tuple类型数据:(img_size, img_size)</span></span><br><span class="line">        patch_size = to_2tuple(patch_size) <span class="comment"># -&gt; (patch_size, patch_size)</span></span><br><span class="line">        patches_resolution = [img_size[<span class="number">0</span>] // patch_size[<span class="number">0</span>], img_size[<span class="number">1</span>] // patch_size[<span class="number">1</span>]]<span class="comment"># patch的行，列数</span></span><br><span class="line">        self.img_size = img_size</span><br><span class="line">        self.patch_size = patch_size</span><br><span class="line">        self.patches_resolution = patches_resolution</span><br><span class="line">        self.num_patches = patches_resolution[<span class="number">0</span>] * patches_resolution[<span class="number">1</span>] <span class="comment"># 一共多少个patches</span></span><br><span class="line"></span><br><span class="line">        self.in_chans = in_chans <span class="comment"># 输入通道数</span></span><br><span class="line">        self.embed_dim = embed_dim <span class="comment"># 一个嵌入向量的维度，即一个patch的数据展平后通过嵌入层线性映射的目标向量维度</span></span><br><span class="line"></span><br><span class="line">        self.proj = nn.Conv2d(in_chans, embed_dim, kernel_size=patch_size, stride=patch_size) <span class="comment"># 逐行逐个块取线性映射</span></span><br><span class="line">        <span class="keyword">if</span> norm_layer <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: <span class="comment"># layer norm层</span></span><br><span class="line">            self.norm = norm_layer(embed_dim)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.norm = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># 假设采取默认参数</span></span><br><span class="line">        x = self.proj(x) <span class="comment"># 出来的是(N, 96, 224/4, 224/4) </span></span><br><span class="line">        x = torch.flatten(x, <span class="number">2</span>) <span class="comment"># 把HW维展开，(N, 96, 56*56)</span></span><br><span class="line">        x = torch.transpose(x, <span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># 把通道维放到最后 (N, 56*56, 96)</span></span><br><span class="line">        <span class="keyword">if</span> self.norm <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            x = self.norm(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<h2 id="Patch-Merging"><a href="#Patch-Merging" class="headerlink" title="Patch Merging"></a><strong>Patch Merging</strong></h2><p>该模块的作用是在每个Stage开始前做降采样，用于缩小分辨率，调整通道数 进而形成层次化的设计，同时也能节省一定运算量。</p>
<blockquote>
<p>在CNN中，则是在每个Stage开始前用<code>stride=2</code>的卷积/池化层来降低分辨率。</p>
</blockquote>
<p>每次降采样是两倍，因此<strong>在行方向和列方向上，间隔2选取元素</strong>。</p>
<p>然后拼接在一起作为一整个张量，最后展开。<strong>此时通道维度会变成原先的4倍</strong>（因为H,W各缩小2倍），此时再通过一个<strong>全连接层再调整通道维度为原来的两倍</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PatchMerging</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_resolution, dim, norm_layer=nn.LayerNorm</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.input_resolution = input_resolution</span><br><span class="line">        self.dim = dim</span><br><span class="line">        self.reduction = nn.Linear(<span class="number">4</span> * dim, <span class="number">2</span> * dim, bias=<span class="literal">False</span>)</span><br><span class="line">        self.norm = norm_layer(<span class="number">4</span> * dim)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        x: B, H*W, C</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        H, W = self.input_resolution</span><br><span class="line">        B, L, C = x.shape <span class="comment"># L就等于num_patches</span></span><br><span class="line">        <span class="keyword">assert</span> L == H * W, <span class="string">&quot;input feature has wrong size&quot;</span></span><br><span class="line">        <span class="keyword">assert</span> H % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> W % <span class="number">2</span> == <span class="number">0</span>, <span class="string">f&quot;x size (<span class="subst">&#123;H&#125;</span>*<span class="subst">&#123;W&#125;</span>) are not even.&quot;</span></span><br><span class="line"></span><br><span class="line">        x = x.view(B, H, W, C) <span class="comment"># 将特征图再分成按patch为单位，长为W，高为H的形状排列</span></span><br><span class="line">				<span class="comment"># 对原图进行取样，降低image_size</span></span><br><span class="line">        x0 = x[:, <span class="number">0</span>::<span class="number">2</span>, <span class="number">0</span>::<span class="number">2</span>, :]  <span class="comment"># B H/2 W/2 C</span></span><br><span class="line">        x1 = x[:, <span class="number">1</span>::<span class="number">2</span>, <span class="number">0</span>::<span class="number">2</span>, :]  <span class="comment"># B H/2 W/2 C</span></span><br><span class="line">        x2 = x[:, <span class="number">0</span>::<span class="number">2</span>, <span class="number">1</span>::<span class="number">2</span>, :]  <span class="comment"># B H/2 W/2 C</span></span><br><span class="line">        x3 = x[:, <span class="number">1</span>::<span class="number">2</span>, <span class="number">1</span>::<span class="number">2</span>, :]  <span class="comment"># B H/2 W/2 C</span></span><br><span class="line">        x = torch.cat([x0, x1, x2, x3], -<span class="number">1</span>)  <span class="comment"># B H/2 W/2 4*C</span></span><br><span class="line">        x = x.view(B, -<span class="number">1</span>, <span class="number">4</span> * C)  <span class="comment"># B H/2*W/2 4*C size是原来的二分之一，通道数是原来的2倍</span></span><br><span class="line"></span><br><span class="line">        x = self.norm(x)</span><br><span class="line">        x = self.reduction(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<p>下面是一个示意图（输入张量N=1, H=W=8, C=1，不包含最后的全连接层调整）</p>
<p><img src="f26297bb391b288a896c6519b141a19f-6559133.png" alt="f26297bb391b288a896c6519b141a19f"></p>
<p><img src="v2-f9c4e3d69da7508562358f9c3f683c63_1440w.png" alt="img"></p>
<blockquote>
<p>个人感觉这像是PixelShuffle的反操作</p>
</blockquote>
<h2 id="Window-Partition-Reverse"><a href="#Window-Partition-Reverse" class="headerlink" title="Window Partition/Reverse"></a><strong>Window Partition/Reverse</strong></h2><p><code>window partition</code>函数是用于对张量划分窗口，指定窗口大小。将原本的张量从 <code>N H W C</code>, 划分成 <code>num_windows*B, window_size, window_size, C</code>，其中 <code>num_windows = H*W / window_size</code>，即窗口的个数，这里的窗口是由patches为单位组成的。而<code>window reverse</code>函数则是对应的逆过程。这两个函数会在后面的<code>Window Attention</code>用到。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">window_partition</span>(<span class="params">x, window_size</span>):</span><br><span class="line">    B, H, W, C = x.shape</span><br><span class="line">    x = x.view(B, H // window_size, window_size, W // window_size, window_size, C)</span><br><span class="line">    windows = x.permute(<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>).contiguous().view(-<span class="number">1</span>, window_size, window_size, C)</span><br><span class="line">    <span class="keyword">return</span> windows <span class="comment"># (num_windows*B, window_size, window_size, C)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">window_reverse</span>(<span class="params">windows, window_size, H, W</span>):</span><br><span class="line">    B = <span class="built_in">int</span>(windows.shape[<span class="number">0</span>] / (H * W / window_size / window_size))</span><br><span class="line">    x = windows.view(B, H // window_size, W // window_size, window_size, window_size, -<span class="number">1</span>)</span><br><span class="line">    x = x.permute(<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>).contiguous().view(B, H, W, -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<h2 id="Window-Attention"><a href="#Window-Attention" class="headerlink" title="Window Attention"></a><strong>Window Attention</strong></h2><p>这是这篇文章的关键。传统的Transformer都是<strong>基于全局来计算注意力的</strong>，因此计算复杂度十分高。而Swin Transformer则将<strong>注意力的计算限制在每个窗口内</strong>，进而减少了计算量。</p>
<p>我们先简单看下公式</p>
<script type="math/tex; mode=display">
Attention\left ( Q,K,T\right )=Softmax\left ( \frac{QK^{T}}{\sqrt{d}+B}\right )V</script><p><img src="eaff53eb1815f6e3c84d3a7b36783701.png" alt="eaff53eb1815f6e3c84d3a7b36783701"></p>
<p>主要区别是在原始计算Attention的公式中的Q,K时<strong>加入了相对位置编码</strong>。后续实验有证明相对位置编码的加入提升了模型性能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WindowAttention</span>(nn.Module):</span><br><span class="line">    <span class="string">r&quot;&quot;&quot; Window based multi-head self attention (W-MSA) module with relative position bias.</span></span><br><span class="line"><span class="string">    It supports both of shifted and non-shifted window.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        dim (int): Number of input channels.</span></span><br><span class="line"><span class="string">        window_size (tuple[int]): The height and width of the window.(int, int)</span></span><br><span class="line"><span class="string">        num_heads (int): Number of attention heads.</span></span><br><span class="line"><span class="string">        qkv_bias (bool, optional):  If True, add a learnable bias to query, key, value. Default: True</span></span><br><span class="line"><span class="string">        qk_scale (float | None, optional): Override default qk scale of head_dim ** -0.5 if set</span></span><br><span class="line"><span class="string">        attn_drop (float, optional): Dropout ratio of attention weight. Default: 0.0</span></span><br><span class="line"><span class="string">        proj_drop (float, optional): Dropout ratio of output. Default: 0.0</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, dim, window_size, num_heads, qkv_bias=<span class="literal">True</span>, qk_scale=<span class="literal">None</span>, attn_drop=<span class="number">0.</span>, proj_drop=<span class="number">0.</span></span>):</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.dim = dim</span><br><span class="line">        self.window_size = window_size  <span class="comment"># Wh, Ww 和前面的patch size区分</span></span><br><span class="line">        self.num_heads = num_heads <span class="comment"># nH</span></span><br><span class="line">        head_dim = dim // num_heads <span class="comment"># 每个注意力头对应的通道数</span></span><br><span class="line">        self.scale = qk_scale <span class="keyword">or</span> head_dim ** -<span class="number">0.5</span> <span class="comment"># (前面公式的根号d)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># define a parameter table of relative position bias</span></span><br><span class="line">        self.relative_position_bias_table = nn.Parameter(</span><br><span class="line">            torch.zeros((<span class="number">2</span> * window_size[<span class="number">0</span>] - <span class="number">1</span>) * (<span class="number">2</span> * window_size[<span class="number">1</span>] - <span class="number">1</span>), num_heads))  </span><br><span class="line">        <span class="comment"># 设置一个形状为（2*(Wh-1) * 2*(Ww-1), nH）的可学习变量，用于后续的位置编码</span></span><br><span class="line">  </span><br><span class="line">        self.qkv = nn.Linear(dim, dim * <span class="number">3</span>, bias=qkv_bias) <span class="comment"># qkv三个向量的计算综合到一起</span></span><br><span class="line">        self.attn_drop = nn.Dropout(attn_drop)</span><br><span class="line">        self.proj = nn.Linear(dim, dim)</span><br><span class="line">        self.proj_drop = nn.Dropout(proj_drop)</span><br><span class="line"></span><br><span class="line">        trunc_normal_(self.relative_position_bias_table, std=<span class="number">.02</span>)</span><br><span class="line">        self.softmax = nn.Softmax(dim=-<span class="number">1</span>)</span><br><span class="line">     <span class="comment"># 相关位置编码...</span></span><br></pre></td></tr></table></figure>
<p>下面把涉及到相关位置编码的逻辑给单独拿出来，这部分比较绕</p>
<p>首先QK计算出来的Attention张量形状为<code>(numWindows*B, num_heads, window_size*window_size, window_size*window_size)</code>。</p>
<p>我们利用<code>torch.arange</code>和<code>torch.meshgrid</code>函数生成对应的坐标，这里我们以<code>windowsize=2</code>为例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">coords_h = torch.arange(self.window_size[<span class="number">0</span>])</span><br><span class="line">coords_w = torch.arange(self.window_size[<span class="number">1</span>])</span><br><span class="line">coords = torch.meshgrid([coords_h, coords_w]) <span class="comment"># -&gt; 2*(wh, ww)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  (tensor([[0, 0],</span></span><br><span class="line"><span class="string">           [1, 1]]), </span></span><br><span class="line"><span class="string">   tensor([[0, 1],</span></span><br><span class="line"><span class="string">           [0, 1]]))</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>然后堆叠起来，展开为一个二维向量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">coords = torch.stack(coords)  <span class="comment"># 2, Wh, Ww</span></span><br><span class="line">coords_flatten = torch.flatten(coords, <span class="number">1</span>)  <span class="comment"># 2, Wh*Ww</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[0, 0, 1, 1],</span></span><br><span class="line"><span class="string">        [0, 1, 0, 1]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>利用广播（broadcast）机制，分别在第一维，第二维，插入一个维度，进行广播相减，得到 <code>2, wh*ww, wh*ww</code>的张量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">relative_coords_first = coords_flatten[:, :, <span class="literal">None</span>]  <span class="comment"># 2, wh*ww, 1</span></span><br><span class="line">relative_coords_second = coords_flatten[:, <span class="literal">None</span>, :] <span class="comment"># 2, 1, wh*ww</span></span><br><span class="line">relative_coords = relative_coords_first - relative_coords_second <span class="comment"># 最终得到 2, wh*ww, wh*ww 形状的张量</span></span><br></pre></td></tr></table></figure>
<p>因为采取的是相减，所以得到的索引是从负数开始的，<strong>我们加上偏移量，让其从0开始</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">relative_coords = relative_coords.permute(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>).contiguous() <span class="comment"># Wh*Ww, Wh*Ww, 2</span></span><br><span class="line">relative_coords[:, :, <span class="number">0</span>] += self.window_size[<span class="number">0</span>] - <span class="number">1</span></span><br><span class="line">relative_coords[:, :, <span class="number">1</span>] += self.window_size[<span class="number">1</span>] - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>后续我们需要将其展开成一维偏移量。而对于(1，2）和（2，1）这两个坐标。在二维上是不同的，<strong>但是通过将x,y坐标相加转换为一维偏移的时候，他的偏移量是相等的</strong>。</p>
<p><img src="v2-5b1f589ca71a4bc406a266296025b4b4_1440w.jpg" alt="img"></p>
<p>所以最后我们对其中做了个乘法操作，以进行区分</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">relative_coords[:, :, <span class="number">0</span>] *= <span class="number">2</span> * self.window_size[<span class="number">1</span>] - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><img src="v2-0c99206fb39da67bae3415a650c38742_1440w.png" alt="img"></p>
<p>然后再最后一维上进行求和，展开成一个一维坐标，并注册为一个不参与网络学习的变量</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">relative_position_index = relative_coords.sum(-1)  # Wh*Ww, Wh*Ww</span><br><span class="line">self.register_buffer(&quot;relative_position_index&quot;, relative_position_index)</span><br></pre></td></tr></table></figure>
<p>接着我们看前向代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, mask=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        x: input features with shape of (num_windows*B, N, C)</span></span><br><span class="line"><span class="string">        mask: (0/-inf) mask with shape of (num_windows, Wh*Ww, Wh*Ww) or None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    B_, N, C = x.shape</span><br><span class="line">    </span><br><span class="line">    qkv = self.qkv(x).reshape(B_, N, <span class="number">3</span>, self.num_heads, C // self.num_heads).permute(<span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    q, k, v = qkv[<span class="number">0</span>], qkv[<span class="number">1</span>], qkv[<span class="number">2</span>]  <span class="comment"># make torchscript happy (cannot use tensor as tuple)</span></span><br><span class="line"></span><br><span class="line">    q = q * self.scale</span><br><span class="line">    attn = (q @ k.transpose(-<span class="number">2</span>, -<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    relative_position_bias = self.relative_position_bias_table[self.relative_position_index.view(-<span class="number">1</span>)].view(</span><br><span class="line">        self.window_size[<span class="number">0</span>] * self.window_size[<span class="number">1</span>], self.window_size[<span class="number">0</span>] * self.window_size[<span class="number">1</span>], -<span class="number">1</span>)  <span class="comment"># Wh*Ww,Wh*Ww,nH</span></span><br><span class="line">    relative_position_bias = relative_position_bias.permute(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>).contiguous()  <span class="comment"># nH, Wh*Ww, Wh*Ww</span></span><br><span class="line">    attn = attn + relative_position_bias.unsqueeze(<span class="number">0</span>) <span class="comment"># (1, num_heads, windowsize, windowsize)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: <span class="comment"># 下文会分析到</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        attn = self.softmax(attn)</span><br><span class="line"></span><br><span class="line">    attn = self.attn_drop(attn)</span><br><span class="line"></span><br><span class="line">    x = (attn @ v).transpose(<span class="number">1</span>, <span class="number">2</span>).reshape(B_, N, C)</span><br><span class="line">    x = self.proj(x)</span><br><span class="line">    x = self.proj_drop(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<ul>
<li>首先输入张量形状为 <code>numWindows*B, window_size * window_size, C</code>（后续会解释）</li>
<li>然后经过<code>self.qkv</code>这个全连接层后，进行reshape，调整轴的顺序，得到形状为<code>3, numWindows*B, num_heads, window_size*window_size, c//num_heads</code>，并分配给<code>q,k,v</code>。</li>
<li>根据公式，我们对<code>q</code>乘以一个<code>scale</code>缩放系数，然后与<code>k</code>（为了满足矩阵乘要求，需要将最后两个维度调换）进行相乘。得到形状为<code>(numWindows*B, num_heads, window_size*window_size, window_size*window_size)</code>的<code>attn</code>张量</li>
<li>之前我们针对位置编码设置了个形状为<code>(2*window_size-1*2*window_size-1, numHeads)</code>的可学习变量。我们用计算得到的相对编码位置索引<code>self.relative_position_index</code>选取，得到形状为<code>(window_size*window_size, window_size*window_size, numHeads)</code>的编码，加到<code>attn</code>张量上</li>
<li>暂不考虑mask的情况，剩下就是跟transformer一样的softmax，dropout，与<code>V</code>矩阵乘，再经过一层全连接层和dropout</li>
</ul>
<h2 id="Shifted-Window-Attention"><a href="#Shifted-Window-Attention" class="headerlink" title="Shifted Window Attention"></a><strong>Shifted Window Attention</strong></h2><p>前面的Window Attention是在每个窗口下计算注意力的，为了更好的和其他window进行信息交互，Swin Transformer还引入了shifted window操作。</p>
<p><img src="v2-07a98325a29db1da6521e4ddaaed3c88_1440w.jpg" alt="img"></p>
<p>左边是没有重叠的Window Attention，而右边则是将窗口进行移位的Shift Window Attention。可以看到移位后的窗口包含了原本相邻窗口的元素。但这也引入了一个新问题，即<strong>window的个数翻倍了</strong>，由原本四个窗口变成了9个窗口。</p>
<p>在实际代码里，我们是<strong>通过对特征图移位，并给Attention设置mask来间接实现的</strong>。能在<strong>保持原有的window个数下</strong>，最后的计算结果等价。</p>
<p><img src="v2-84b7dd5ba83bf0c686a133dec758d974_1440w.jpg" alt="img"></p>
<h2 id="特征图移位操作"><a href="#特征图移位操作" class="headerlink" title="特征图移位操作"></a><strong>特征图移位操作</strong></h2><p>代码里对特征图移位是通过<code>torch.roll</code>来实现的，下面是示意图</p>
<p><img src="v2-7b594ca54a3cfac5370d8fef2be6f768_1440w.jpg" alt="img"></p>
<blockquote>
<p>如果需要<code>reverse cyclic shift</code>的话只需把参数<code>shifts</code>设置为对应的正数值。</p>
</blockquote>
<h2 id="Attention-Mask"><a href="#Attention-Mask" class="headerlink" title="Attention Mask"></a><strong>Attention Mask</strong></h2><p>我认为这是Swin Transformer的精华，通过设置合理的mask，让<code>Shifted Window Attention</code>在与<code>Window Attention</code>相同的窗口个数下，达到等价的计算结果。</p>
<p>首先我们对Shift Window后的每个窗口都给上index，并且做一个<code>roll</code>操作（window_size=2, shift_size=-1）</p>
<p><img src="v2-d80364e0b73c60bcd8a60bbd91cfbaeb_1440w.jpg" alt="img"></p>
<p>我们希望在计算Attention的时候，<strong>让具有相同index QK进行计算，而忽略不同index QK计算结果</strong>。</p>
<p>最后正确的结果如下图所示</p>
<p><img src="v2-e72bf67b5cbcc27e2d2640bcd3522d0e_1440w.jpg" alt="img"></p>
<p>而要想在原始四个窗口下得到正确的结果，我们就必须给Attention的结果加入一个mask（如上图最右边所示）</p>
<p>相关代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> self.shift_size &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># calculate attention mask for SW-MSA</span></span><br><span class="line">    H, W = self.input_resolution</span><br><span class="line">    img_mask = torch.zeros((<span class="number">1</span>, H, W, <span class="number">1</span>))  <span class="comment"># 1 H W 1</span></span><br><span class="line">    h_slices = (<span class="built_in">slice</span>(<span class="number">0</span>, -self.window_size),</span><br><span class="line">                <span class="built_in">slice</span>(-self.window_size, -self.shift_size),</span><br><span class="line">                <span class="built_in">slice</span>(-self.shift_size, <span class="literal">None</span>))</span><br><span class="line">    w_slices = (<span class="built_in">slice</span>(<span class="number">0</span>, -self.window_size),</span><br><span class="line">                <span class="built_in">slice</span>(-self.window_size, -self.shift_size),</span><br><span class="line">                <span class="built_in">slice</span>(-self.shift_size, <span class="literal">None</span>))</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> h_slices:</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> w_slices:</span><br><span class="line">            img_mask[:, h, w, :] = cnt</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    mask_windows = window_partition(img_mask, self.window_size)  <span class="comment"># nW, window_size, window_size, 1</span></span><br><span class="line">    mask_windows = mask_windows.view(-<span class="number">1</span>, self.window_size * self.window_size)</span><br><span class="line">    attn_mask = mask_windows.unsqueeze(<span class="number">1</span>) - mask_windows.unsqueeze(<span class="number">2</span>)</span><br><span class="line">    attn_mask = attn_mask.masked_fill(attn_mask != <span class="number">0</span>, <span class="built_in">float</span>(-<span class="number">100.0</span>)).masked_fill(attn_mask == <span class="number">0</span>, <span class="built_in">float</span>(<span class="number">0.0</span>))</span><br></pre></td></tr></table></figure>
<p>以上图的设置，我们用这段代码会得到这样的一个mask</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">tensor([[[[[   0.,    0.,    0.,    0.],</span><br><span class="line">           [   0.,    0.,    0.,    0.],</span><br><span class="line">           [   0.,    0.,    0.,    0.],</span><br><span class="line">           [   0.,    0.,    0.,    0.]]],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         [[[   0., -100.,    0., -100.],</span><br><span class="line">           [-100.,    0., -100.,    0.],</span><br><span class="line">           [   0., -100.,    0., -100.],</span><br><span class="line">           [-100.,    0., -100.,    0.]]],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         [[[   0.,    0., -100., -100.],</span><br><span class="line">           [   0.,    0., -100., -100.],</span><br><span class="line">           [-100., -100.,    0.,    0.],</span><br><span class="line">           [-100., -100.,    0.,    0.]]],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         [[[   0., -100., -100., -100.],</span><br><span class="line">           [-100.,    0., -100., -100.],</span><br><span class="line">           [-100., -100.,    0., -100.],</span><br><span class="line">           [-100., -100., -100.,    0.]]]]])</span><br></pre></td></tr></table></figure>
<p>在之前的window attention模块的前向代码里，包含这么一段</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    nW = mask.shape[<span class="number">0</span>]</span><br><span class="line">    attn = attn.view(B_ // nW, nW, self.num_heads, N, N) + mask.unsqueeze(<span class="number">1</span>).unsqueeze(<span class="number">0</span>)</span><br><span class="line">    attn = attn.view(-<span class="number">1</span>, self.num_heads, N, N)</span><br><span class="line">    attn = self.softmax(attn)</span><br></pre></td></tr></table></figure>
<p>将mask加到attention的计算结果，并进行softmax。mask的值设置为-100，softmax后就会忽略掉对应的值</p>
<h2 id="Transformer-Block整体架构"><a href="#Transformer-Block整体架构" class="headerlink" title="Transformer Block整体架构"></a><strong>Transformer Block整体架构</strong></h2><p><img src="v2-b1f64ea254af2c7b1cdbaf9288731371_1440w.jpg" alt="img"></p>
<p>两个连续的Block架构如上图所示，需要注意的是一个Stage包含的Block个数必须是偶数，因为需要交替包含一个含有<code>Window Attention</code>的Layer和含有<code>Shifted Window Attention</code>的Layer。</p>
<p>我们看下Block的前向代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">    H, W = self.input_resolution</span><br><span class="line">    B, L, C = x.shape</span><br><span class="line">    <span class="keyword">assert</span> L == H * W, <span class="string">&quot;input feature has wrong size&quot;</span></span><br><span class="line"></span><br><span class="line">    shortcut = x</span><br><span class="line">    x = self.norm1(x)</span><br><span class="line">    x = x.view(B, H, W, C)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># cyclic shift</span></span><br><span class="line">    <span class="keyword">if</span> self.shift_size &gt; <span class="number">0</span>:</span><br><span class="line">        shifted_x = torch.roll(x, shifts=(-self.shift_size, -self.shift_size), dims=(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        shifted_x = x</span><br><span class="line"></span><br><span class="line">    <span class="comment"># partition windows</span></span><br><span class="line">    x_windows = window_partition(shifted_x, self.window_size)  <span class="comment"># nW*B, window_size, window_size, C</span></span><br><span class="line">    x_windows = x_windows.view(-<span class="number">1</span>, self.window_size * self.window_size, C)  <span class="comment"># nW*B, window_size*window_size, C</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># W-MSA/SW-MSA</span></span><br><span class="line">    attn_windows = self.attn(x_windows, mask=self.attn_mask)  <span class="comment"># nW*B, window_size*window_size, C</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># merge windows</span></span><br><span class="line">    attn_windows = attn_windows.view(-<span class="number">1</span>, self.window_size, self.window_size, C)</span><br><span class="line">    shifted_x = window_reverse(attn_windows, self.window_size, H, W)  <span class="comment"># B H&#x27; W&#x27; C</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># reverse cyclic shift</span></span><br><span class="line">    <span class="keyword">if</span> self.shift_size &gt; <span class="number">0</span>:</span><br><span class="line">        x = torch.roll(shifted_x, shifts=(self.shift_size, self.shift_size), dims=(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x = shifted_x</span><br><span class="line">    x = x.view(B, H * W, C)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># FFN</span></span><br><span class="line">    x = shortcut + self.drop_path(x)</span><br><span class="line">    x = x + self.drop_path(self.mlp(self.norm2(x)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<p>整体流程如下</p>
<ul>
<li>先对特征图进行LayerNorm</li>
<li>通过<code>self.shift_size</code>决定是否需要对特征图进行shift</li>
<li>然后将特征图切成一个个窗口</li>
<li>计算Attention，通过<code>self.attn_mask</code>来区分<code>Window Attention</code>还是<code>Shift Window Attention</code></li>
<li>将各个窗口合并回来</li>
<li>如果之前有做shift操作，此时进行<code>reverse shift</code>，把之前的shift操作恢复</li>
<li>做dropout和残差连接</li>
<li>再通过一层LayerNorm+全连接层，以及dropout和残差连接</li>
</ul>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a><strong>实验结果</strong></h2><p><img src="v2-bf00e048de979decd68ebc7c5372cb27_1440w.jpg" alt="img"></p>
<p>在ImageNet22K数据集上，准确率能达到惊人的86.4%。另外在检测，分割等任务上表现也很优异，感兴趣的可以翻看论文最后的实验部分。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>这篇文章创新点很棒，引入window这一个概念，将CNN的局部性引入，还能控制模型整体计算量。在Shift Window Attention部分，用一个mask和移位操作，很巧妙的实现计算等价。作者的代码也写得十分赏心悦目，推荐阅读！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/06/%E7%A7%91%E7%A0%94%E8%AE%BA%E6%96%87%E4%B9%A6%E5%86%99%E5%B0%8F%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="篮球架上打砖块">
      <meta itemprop="description" content="Apodidae">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Upperlan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/06/%E7%A7%91%E7%A0%94%E8%AE%BA%E6%96%87%E4%B9%A6%E5%86%99%E5%B0%8F%E8%AE%B0/" class="post-title-link" itemprop="url">科研论文书写小记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-06 13:28:37" itemprop="dateCreated datePublished" datetime="2022-03-06T13:28:37+08:00">2022-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-10 20:02:12" itemprop="dateModified" datetime="2022-03-10T20:02:12+08:00">2022-03-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A7%91%E7%A0%94%E4%B8%8E%E8%AE%BA%E6%96%87/" itemprop="url" rel="index"><span itemprop="name">科研与论文</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><p>来源：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/368677897">https://zhuanlan.zhihu.com/p/368677897</a></p>
<p><img src="v2-37eb4b8e53a842758725be0936c9a07e_720w.jpg" alt="img"></p>
<p>（一种很典型的行文方式：把所有工作摊煎饼地摆出来，反正我列出来了，哪个有用你自己找)</p>
<p>“做这个工作的有ABCD, A 做了xxx，B做了xxx，C和D做了xxx” ——类似的句式，<strong>不要再这样写啦</strong>。写相关工作的时候，作者应该是充当一种指路人，或者说书人的角色：在详细介绍核心内容之前，<strong>把故事背景在读者面前慢慢地，有条理地展开</strong>。</p>
<p>所以，你需要把面前的相关文献们，用一条线串起来，来向读者展现它们之间，以及和自己工作之间的关联。这些逻辑可能是递进的：<strong>例如文章ABC开创了某个领域，DEF在这个问题领域提出了集中思路，GHI则是在各个思路下的改进——那么我们就可以先说用总领的话来叙述ABC，然后用并列的方式讲DEF，最后可以一笔带过GHI</strong>（如果它们不是那么重要的话）。</p>
<p>这些逻辑可能是并列的：例如文章ABC用了X技术来解决某个问题，DEF用了Y技术，而GHI则用了DrustZ的技术——那么我们可以使用分条列举的方式，先写”为了解决某个问题，大家采用了不同的方法“，然后列出1）X技术[ABC] 2）Y技术[DEF] 3) DrustZ的技术[GHI] 。这样把类似的文章集中起来，大家看着也顺溜。</p>
<p>还有些其他不怎么常见的逻辑顺序，比如分-总（例如先有零散的工作，后来有一篇文献把它们综合了起来）。但是当我们意识到文献内在的逻辑顺序，并且把它们按照逻辑列举出来的时候，就已经比许多论文的相关文献高出了不止一个档次：）</p>
<p>更加高级的写作方式，则是与其列举文献，更像是让文献为作者自己的陈述服务。你在阅读的过程中，很难感觉到作者在刻意塞进一些文献来充数；相反，作者是在整理自己的思路，顺便引用了关键的文献来加以佐证。</p>
<p>开头不要直接列别人的文章，先概括地说一下这个段落的主题；写完一个小部分，不要立即跳到下一段开始写另一个部分，而是在末尾写一个过渡句：“以上就是人们在X领域的研究，但是随着Y技术的进步，更多的人把目光转移到了Z上”，“对于Y技术在X领域的研究已经介绍许多，但在另一个Z方面，相同的技术也有许多应用”。拿出小学作文满分的本领来！</p>
<p>我老板写Related Work有一个习惯，从来不会在大标题下什么都不写就直接跳到第一个小标题（例如上边那个反例）。在大标题的下面，用一些总领的语言来概括+引出接下来的小章节，其实也是一个很好的过渡方式。一切为了读者服务！</p>
<p><img src="v2-cafd63855ff2e5659ed60614d4280d62_720w.jpg" alt="img"></p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>作者：平海鸥鸣<br>链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/406397855">https://zhuanlan.zhihu.com/p/406397855</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p><strong>将研究成果和研究目的联系起来</strong><br>Simple statistical analysis was used to …<br>The next question asked the informants …<br>To assess X, the Y questionnaire was used.<br>Changes in X and Y were compared using …<br>Regression analysis was used to predict the …<br>To distinguish between these two possibilities, …<br>The first set of analyses examined the impact of … </p>
<p><strong>描述图标中的研究成果</strong><br>As shown in Figure 1,<br>As can be seen from the table (above),<br>From the graph above we can see that<br>It can be seen from the data in Table 1 that </p>
<p>It is apparent from this table that very few …<br>The most interesting aspect of this graph is …<br>In Fig.10 there is a clear trend of decreasing …<br>What is striking about the figures in this table is …<br>What is interesting about the data in this table is that …<br>The differences between X and Y are highlighted in Table 4.<br>From the chart, it can be seen that by far the greatest demand is for …<br>From this data, we can see that Study 2 resulted in the lowest value of … </p>
<p><strong>只是描述研究结果</strong><br><strong>正面的</strong><br>The mean score for X was …<br>Further analysis showed that …<br>Further statistical tests revealed …<br>A two-way ANOVA revealed that …<br>On average, Xs were shown to have …<br>Strong evidence of X was found when …<br>This result is significant at the p = 0.05 level.<br>The results, as shown in Table 1, indicate that …<br>A positive correlation was found between X and Y.<br>There was a significant positive correlation between … </p>
<p><strong>负面的</strong><br>No difference greater than X was observed.<br>No significant differences were found between …<br>None of these differences were statistically significant.<br>No significant difference between the two groups was evident.<br>No significant reduction in X was found compared with placebo.<br>No evidence was found for non-linear associations between X and Y.<br>No significant correlation was found between X scores and the Y scores (p = .274) </p>
<p><strong>将之前的结果（正面的或负面的）——进行简单的现象描述</strong><br>Stimulation of X cells with Y did not increase the …<br>With successive increases in intensity of the X, the Y moved further to …<br>Following the addition of X, a significant increase (<em>P</em>&lt;0.05) in the Y was recorded.<br>When X cells were stimulated with Y, no significant difference in the number of Z was detected. </p>
<p><strong>如果发现有意思的结果</strong></p>
<p>This result is somewhat counterintuitive.<br>Interestingly, this correlation is related to …<br>The more surprising correlation is with the …<br>Surprisingly, only a minority of respondents …<br>The most surprising aspect of the data is in the …<br>The correlation between X and Y is interesting because …<br>The most striking result to emerge from the data is that …<br>Interestingly, there were also differences in the ratios of …<br>The single most striking observation to emerge from the data comparison was … </p>
<p><strong>然后，就开始说我们的对自己研究结果的解释</strong><br>This result may be explained by the fact that …<br>There are, however, other possible explanations.<br>These relationships may partly be explained by …<br>There are several possible explanations for this result.<br>A possible explanation for these results may be the lack of adequate …<br>These differences can be explained in part by the proximity of X and Y. </p>
<p><strong>描述另一个实验结果</strong></p>
<p>A comparison of the two results reveals …<br>Turning now to the experimental evidence on …<br>Comparing the two results, it can be seen that …<br>The next section of the survey was concerned with …<br>In the final part of the survey, respondents were asked … </p>
<p><strong>最后肯定就是对现有研究工作进行的总结</strong></p>
<p>Overall, these results indicate that …<br>In summary, these results show that …<br>In summary, for the informants in this study, …<br>Together these results provide important insights into …<br>Taken together, these results suggest that there is an association between …<br>The results in this chapter indicate that … The next chapter, therefore, moves on to discuss the …</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/06/ATSS%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-Anchor-based%E5%92%8CAnchor-free%E6%A8%A1%E5%9E%8B%E5%85%B3%E9%94%AE%E5%B7%AE%E5%BC%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="篮球架上打砖块">
      <meta itemprop="description" content="Apodidae">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Upperlan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/06/ATSS%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-Anchor-based%E5%92%8CAnchor-free%E6%A8%A1%E5%9E%8B%E5%85%B3%E9%94%AE%E5%B7%AE%E5%BC%82/" class="post-title-link" itemprop="url">ATSS论文笔记:Anchor-based和Anchor-free模型关键差异</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-06 11:42:13 / 修改时间：11:58:22" itemprop="dateCreated datePublished" datetime="2022-03-06T11:42:13+08:00">2022-03-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/" itemprop="url" rel="index"><span itemprop="name">目标检测</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>论文: Bridging the Gap Between Anchor-based and Anchor-free Detection via Adaptive Training Sample Selection</p>
<p>简述：论文指出one-stage anchor-based和center-based anchor-free检测算法间的差异主要来自于正负样本的选择，基于此提出ATSS(Adaptive Training Sample Selection)方法，该方法能够<strong>自动根据GT的相关统计特征选择合适的anchor box作为正样本</strong>，在<strong>不带来额外计算量和参数</strong>的情况下，能够大幅提升模型的性能，十分有用。</p>
<p>背景：RetinaNet是一个anchor-based检测模型，FCOS是一个anchor-free检测模型，两者有三点不同：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>RetinaNet</th>
<th>FCOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.每个位置的anchor数</td>
<td>RetinaNet每个grid cell有几个anchor box</td>
<td>FCOS每个位置只根据一个anchor point来回归bbox</td>
</tr>
<tr>
<td>2.正负样本的定义不同</td>
<td>根据IoU来区分正副样本</td>
<td>根据选择样本的空间和规模限制（即gt框中心周围的一部分区域的点作为正样本。）</td>
</tr>
<tr>
<td>3.回归的对象不同</td>
<td>回归anchor box的偏移值</td>
<td>回归点到bbox四条边的距离</td>
</tr>
</tbody>
</table>
</div>
<p>实验中FCOS比RetinaNet的效果要好</p>
<p>实验：论文选取<strong>anchor-based方法RetinaNet</strong>和<strong>anchor-free方法FCOS</strong>进行对比，主要对比正负样本定义和回归开始状态的差异，将RetinaNet的anchor数改为1降低差异性，方便与FCOS比较，后续会测试anchor数带来的作用。</p>
<p>首先将FCOS上有的tricks加在RetinaNet上</p>
<p><img src="image-20220306115011025-6538616.png" alt="image-20220306115011025"></p>
<p>现在FCOS和RetinaNet只有两个不同：</p>
<p>1.正负样本的分配</p>
<p>2.回归对象的不同</p>
<p>而此时FCOS比RetinaNet高0.8个点，所以再验证这两个不同的影响：</p>
<p><img src="image2022-2-11_16-10-11.png" alt="image2022-2-11_16-10-11"></p>
<p>又上图得RetinaNet将IoU阈值分配正负样本（与yolov3相同）换成点和区域分配正负样本时，涨点了，而FCOS使用IoU阈值时反而掉点了</p>
<p>后续实验验证回归对象的时候发现对象不同几乎不影响mAP。</p>
<p>因此作者得出结论：</p>
<p>FCOS的表现比RetinaNet要好主要是因为FCOS的正负样本分配策略更好。</p>
<p>因此对于anchor-based模型，为了消除anchor超参数的影响，提出</p>
<p><strong>Adaptive Training Sample Selection (ATSS)</strong></p>
<p>自动根据物体的统计特征划分正负样本，几乎没有任何超参数。</p>
<p><img src="image-20220306115249710-6538771.png" alt="image-20220306115249710"></p>
<p>先选出每一层的所有预测框中与真实框L2距离最小的k个预测框，计算这些预测框与每一个gt框的IoU，统计这些IoU值的均值m和均方差v，则IoU阈值t=m+v。如果一个预测框与某个gt框的阈值大于t，则为正样本，否则为负样本。</p>
<p>m：为了有合适数目的正样本，如果m很大，说明有许多高质量的预测框，则IoU阈值应该更大；如果m比较小，说明预测框的质量不太好，IoU阈值应该更小</p>
<p>v：如果v较小，说明有几个特征层都适合完成当前的检测任务，所以m+v的值更小，则选取更多正样本；如果v较大，则说明有某些特定的特征层更适合完成当前目标的检测任务，所以IoU阈值更大，来选取更合适的特征层上的检测框</p>
<p>根据统计学理论，IoU值在阈值t以上的预测框大概在16%左右，每个目标物体大概会分配 （0.2 <em> k </em> 特征层数 ）个正样本。该方法只引入了一个超参数k，而且k对结果的影响并不大，一般设置为9，因此本算法可以近似看做不增加超参数。</p>
<p><img src="image-20220306115325575-6538806.png" alt="image-20220306115325575"></p>
<ul>
<li>将RetinaNet中的正负样本替换为ATSS，AP提升了2.9%，这样的性能提升几乎是没有任何额外消耗的</li>
<li>在FCOS上的应用主要用两种：lite版本采用ATSS的思想，从选取GT内的anchor point改为选取每层离GT最近的top $k$个候选anchor point，提升了0.8%AP；full版本将FCOS的anchor point改为长宽为$8S$的anchor box来根据ATSS选择正负样本，但仍然使用原始的回归方法，提升了1.4%AP。两种方法找到的anchor point在空间位置上大致相同，但是在FPN层上的选择不太一样。从结果来看，自适应的选择方法比固定的方法更有效</li>
</ul>
<p>这里的RetinaNet只用了一个anchor box，如果使用多个anchor box，结果如下：</p>
<p><img src="image-20220306115542160-6538944.png" alt="image-20220306115542160"></p>
<p>Imprs为用在了FCOS中的提升手段。从结果来看，在每个位置设定多个anchor box是无用的操作，关键在于选择合适的正样本</p>
<p>论文结论：</p>
<p>1.这两种方法之间的本质区别是<strong>正负训练样本的选择</strong>，这导致了它们之间的性能差距。如果他们在训练期间选择相同的正负样本，无论是回归anchor bbox或anchor point，最终表现都没有明显的差距。</p>
<p>2.通过一系列实验，可以得出结论，没有必要在图像上每个位置设置多个anchor box来检测物体。</p>
<p>3.相同的主干网络下，ATSS方法能够大幅增加准确率，十分有效</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/05/docker%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="篮球架上打砖块">
      <meta itemprop="description" content="Apodidae">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Upperlan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/05/docker%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">docker常用操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-05 22:18:54 / 修改时间：22:20:25" itemprop="dateCreated datePublished" datetime="2022-03-05T22:18:54+08:00">2022-03-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E4%BD%9C%E5%B8%B8%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">工作常用</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="docker操作"><a href="#docker操作" class="headerlink" title="docker操作"></a>docker操作</h1><h2 id="docker基本命令"><a href="#docker基本命令" class="headerlink" title="docker基本命令"></a>docker基本命令</h2><ul>
<li>查看容器镜像列表 docker images</li>
<li>查看当前所有正在运行的容器 docker ps  (查看所有容器，包括运行和停止的。t)<h4 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h4></li>
<li>将网上或者别的服务器上的docker镜像拉到本地。例如： docker pull uber/horovod:0.15.1-tf1.11.0-torch0.4.1-py3.</li>
</ul>
<h4 id="docker-push"><a href="#docker-push" class="headerlink" title="docker push"></a>docker push</h4><ul>
<li><p>上传docker镜像(注意上传镜像统一格式，yq01-aip-m12-tianzhi14.yq01.baidu.com/[Name]:tagls<br>$ docker push yq01-aip-m12-tianzhi14.yq01.baidu.com/lvhaijun/tsm_horovod:0.15.0-tf1.11.0-torch0.4.1-py2.7</p>
</li>
<li><p>建立一个带gpu驱动的容器：</p>
</li>
<li>nvidia-docker run -e PASSWORD=tianzhi05 —network=host —shm-size=32g —name=haijunlv -v /home/ssd1/lvhaijun:/home/lvhaijun -it haijun_tf1.11_torch0.4_py2.7:latest /bin/bash 注意建立容器时请一定将—name 带上，用以区分创建者。无名字的/默认名字的，如果容器在被杀掉概不负责</li>
</ul>
<p>-e：设置环境变量<br>—network：将容器联网<br>—shm-size：/dev/shm/的大小（共享内存）<br>—name：给容器命名<br>-v：将宿主机目录挂载进docker，冒号左边是Host的路径，右边是容器内的路径<br>-it：指示Docker分配连接到容器的伪TTY<br>-p: 指定端口映射，格式为：主机(宿主)端口:容器端口<br>最后是镜像名称:镜像版本</p>
<p>$docker run —runtime=nvidia —shm-size=32g —name=dingzhenkai -p 8017:8017 -v /home/dingzhenkai:/home/dingzhenkai -it registry.baidubce.com/rudder/train_basic/paddle2.1.2-gpu-cuda10.1-cudnn7:basic /bin/bash</p>
<p>注意建立容器时请一定将—name 带上，用以区分创建者。</p>
<ul>
<li><p>退出容器： exit （杀死该容器进程） Control + p+ q (不kill 进程， 只退出当前容器，高频使用)</p>
</li>
<li><p>重新进行一个运行中的容器 docker attach CONTAINER_ID</p>
</li>
<li>从容器进程中创建一个容器进程(某进程死机后可用此方法再创建进程，查看死机进程状况) docker exec -it CONTAINER_ID bash</li>
<li>重新启动一个停止的容器 docker start CONTAINER_ID</li>
<li>docker 容器删除 docker container rm CONTAINER_ID </li>
<li>docker 镜像删除 docker image rm IMAGE_ID</li>
<li>docker rename 重命名</li>
<li>docker exec —privileged -u root -it container-id bash root权限进入容器</li>
<li>docker system df -v 查看容器占用空间</li>
<li>批量静止容器删除 #删除所有未运行的容器（已经运行的删除不了，未运行的就一起被删除了） sudo docker rm $(sudo docker ps -a -q)</li>
<li>docker 服务重启 service docker restart</li>
<li>docker 容器保存成镜像 doker commit <container_id> new_image_name:tag</li>
<li>镜像保存到本地 docker save image_name -o 本地路径/—.tar</li>
<li>镜像从本地加载 docker load -i 本地路径/—.tar</li>
<li>Dead 容器删除:<br>$ docker rm $(docker ps —all -q -f status=dead)</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/intro/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/intro/">1</a><a class="page-number" href="/intro/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/intro/page/4/">4</a><a class="extend next" rel="next" href="/intro/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">篮球架上打砖块</p>
  <div class="site-description" itemprop="description">Apodidae</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">篮球架上打砖块</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '[object Object]';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
