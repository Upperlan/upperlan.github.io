<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Apodidae">
<meta property="og:type" content="website">
<meta property="og:title" content="Upperlan">
<meta property="og:url" content="http://example.com/intro/page/3/index.html">
<meta property="og:site_name" content="Upperlan">
<meta property="og:description" content="Apodidae">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="篮球架上打砖块">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/intro/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Upperlan</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Upperlan</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/10/%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%BA%AB%E4%BD%93%E7%B4%A0%E8%B4%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="篮球架上打砖块">
      <meta itemprop="description" content="Apodidae">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Upperlan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/10/%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E8%BA%AB%E4%BD%93%E7%B4%A0%E8%B4%A8/" class="post-title-link" itemprop="url">训练计划-身体素质</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-10 14:35:17" itemprop="dateCreated datePublished" datetime="2022-01-10T14:35:17+08:00">2022-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-06 13:45:14" itemprop="dateModified" datetime="2022-03-06T13:45:14+08:00">2022-03-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%94%B7%E5%A3%AB%E4%BC%91%E9%97%B2/" itemprop="url" rel="index"><span itemprop="name">男士休闲</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="腿部力量-弹跳爆发Day（周一周四）"><a href="#腿部力量-弹跳爆发Day（周一周四）" class="headerlink" title="腿部力量+弹跳爆发Day（周一周四）"></a>腿部力量+弹跳爆发Day（周一周四）</h3><p>-深蹲4x8（四组每组八下）</p>
<p>每组做完接超级组 深蹲跳 8下（可选择负重）全力跳！</p>
<p>*重量选择自己做八下比较吃力的重量</p>
<p>-负重健步行走 4x16（16步）</p>
<p>每组做完接超级组 健步跳8-10下 全力跳！挑战自己！</p>
<p>-硬拉 4x6-8</p>
<p>每组做完接低高度跳台阶 12-20次 尽可能连续跳跃 不间断 每次一落地就立刻再次跳起来</p>
<p>-推车冲刺 大约30米 或篮球场距离</p>
<p>紧接着徒手冲刺跑回来</p>
<p>做3-5组 每个来回算一组</p>
<p>（假设没有推车的话 就全部徒手冲刺）</p>
<p>全力百分之百速度冲！挑战自己！</p>
<p>-引体抬腿 3x8</p>
<p>（做不到的话 就竭尽所能 做不了的话也竭尽所能努力尝试！挑战自己！）</p>
<p>-平板支撑 两分钟 就一组 </p>
<p>（做不到两分钟的话 就做到自己的极限！竭尽所能！能做到三分钟或更多的话欢迎去挑战！挑战自己！！）</p>
<h3 id="胸背Day-（周二周五）"><a href="#胸背Day-（周二周五）" class="headerlink" title="胸背Day （周二周五）"></a>胸背Day （周二周五）</h3><p>-卧推 3x8 （你做八组比较吃力的重量 但又不是力竭）</p>
<p>-引体向上 3x8 （做不到那么多的话 就做到自己力竭 竭尽全力！做不了引体向上的话 就每次都努力尝试做 或者用辅助带 挑战自己！）</p>
<p>-斜侧推 3x8-12 三组 每组8到12 </p>
<p>-Row 往下拉的器械 3x8 （最后一下 拉下来后多停两秒）</p>
<p>-Cable Chest Press 3x8-12 </p>
<p>每组结束后紧接着做俯卧撑 8-10下</p>
<p>-Row 平拉的器械 3x8 （最后一下 拉下来后停两秒）</p>
<p>-负重引体抬腿 3x8-12（太难的话 可以选择不负重）</p>
<p>-负重仰卧起坐 3x8-12（太难的话 可以选择不负重）</p>
<h3 id="麒麟臂Day（周三周六）"><a href="#麒麟臂Day（周三周六）" class="headerlink" title="麒麟臂Day（周三周六）"></a>麒麟臂Day（周三周六）</h3><p>-哑铃Curl 3x8-10 掌控好节奏 别太快！</p>
<p>-三头Press Down 3x10-12 </p>
<p>-肩部推杠铃 3x8</p>
<p>-杠铃Curl 3x8</p>
<p>-三头Extension 3x12 左右各12</p>
<p>-飞鸟肩 3x8-12</p>
<p>-抬腿卷腹50 紧接 仰卧抬腿 30 紧接 仰卧剪刀腿 50 一组</p>
<p>-滚轮 3x10</p>
<p>周日休息</p>
<p>*休息非常重要！这才是你的身体真正开始进化的时刻！</p>
<p>多！ 拉！ 抻！</p>
<p>*平时多尝试扣篮或最大化摸高，任何时间任何地点，尤其是各种训练后，多跳多跳多全力跳！从摸篮网、篮板、篮筐开始 一步一步到扣篮，根据自己的能力挑战自己，往高了够！多跳！！努力让自己变得兴奋，激活自己的中枢神经区！</p>
<p>*多 拉 抻！恢复与健康是关键！尤其是训练后！这非常重要！！</p>
<p>*饮食：如果你要减脂肪塑形的话 不要吃面包、饮料、甜品、冰淇淋、油炸、猪肉 多吃蔬菜、绿菜、鸡肉、适当的米饭、豆、适当的牛羊肉、水果、大量的白水；如果你是要增肌的话 而且还是作为篮球运动员 送给你两个字：多！吃！别管吃什么 只要不是太过多的垃圾食品 或过多的甜的 多！吃！！</p>
<p>PAIN IS MY FUEL.</p>
<p><a target="_blank" rel="noopener" href="https://v.youku.com/v_show/id_XMzgwMzI1ODk0OA==.html?spm=a2h3j.8428770.3416059.1">https://v.youku.com/v_show/id_XMzgwMzI1ODk0OA==.html?spm=a2h3j.8428770.3416059.1</a></p>
<p>密码：HangtimeStrong</p>
<p>注意大小写</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/02/YOLO%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="篮球架上打砖块">
      <meta itemprop="description" content="Apodidae">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Upperlan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/02/YOLO%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">YOLO系列模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-02 20:40:25" itemprop="dateCreated datePublished" datetime="2021-11-02T20:40:25+08:00">2021-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-14 17:23:41" itemprop="dateModified" datetime="2022-03-14T17:23:41+08:00">2022-03-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/" itemprop="url" rel="index"><span itemprop="name">目标检测</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<h3 id="几个宏观上的理解"><a href="#几个宏观上的理解" class="headerlink" title="几个宏观上的理解"></a>几个宏观上的理解</h3><ul>
<li>从直觉上理解，两阶段模型做了粗挑+精挑的操作。 那在目标物体的召回率上会有所下降，在精确率上会有所提升。<br>单阶段模型只有一个阶段，在物体的召回率上会比较高，但在精确率上会有所下降。</li>
<li>业务上会根据需求来挑模型，如果要求高精度，就用frcnn，精度和性能平衡，就用yolo。</li>
</ul>
<h2 id="YOLOv1"><a href="#YOLOv1" class="headerlink" title="YOLOv1"></a>YOLOv1</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>YOLO是一个单独的end-to-end网络，其本质是吧目标检测问题当做一个回归问题去解决。</p>
<p>整体模型图如下：</p>
<p><img src="image-20220305211422793.png" alt="image-20220305211422793"></p>
<h4 id="backbone"><a href="#backbone" class="headerlink" title="backbone"></a>backbone</h4><p>基于GoogLeNet model，24个卷积层和两个全连接层，前20层在image1000上预训练，然后连上剩下的卷积层和全连接层再训练。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>是一个unified模型即整体性-&gt;把识别bbox，识别标签两个功能集成到一个网络中</p>
</li>
<li><p>训练时能够看到整个图片-&gt;即端到端，输出层是从整个特征图，其中每个位置上的通道就反应了这个位置的图像特征，因此yolo会比rcnn更少犯背景识别错误<br>注解：和两阶段检测模型不同，两阶段模型是先筛选ROI区域，此时卷积还不够深，还比较浅所以容易误识别背景为目标提取出来了；单阶段模型输出的特征图反应的是感受野区域上与目标物体相关的信息，输出时层数更深，所以对背景和物体的分辨能力更强，不容易犯背景误识别的错误。</p>
</li>
<li><p>学习的是总体上的特征-&gt;对于输入的鲁棒性强</p>
</li>
<li><p>虽然精度离其他模型还有一些差距，但是贵在快</p>
</li>
</ul>
<p>最后训练完备的模型推理时的输出：</p>
<ul>
<li><p>输入：原始图像resize后的图像</p>
</li>
<li><p>输出：物体位置和类别</p>
</li>
</ul>
<p><strong>注意：</strong> RCNN系列模型是将检测模块分为两部分，物体类别是一个分类问题；物体位置（即求bbox）是个回归问题</p>
<h4 id="2-1输入输出定义"><a href="#2-1输入输出定义" class="headerlink" title="2.1输入输出定义"></a>2.1输入输出定义</h4><p>输入：一个batch的image，shape是[batch_size,3,448,448]</p>
<p>输出：shape是[batch_size，Bboxs * 5 + Classes，size， size]</p>
<p>把图像分成S * S个grid cell，当有物体的中心落到一个cell中时（怎么判断？-&gt;confidence值），这个cell就要负责检测这个物体。每个cell要预测B个bbox，每个bbox都有一个相应的confidence</p>
<p>预测时，每个Bounding box包含五个数据值：</p>
<ul>
<li><p>x,y为当前格子预测到的物体的bbox中心位置坐标。</p>
</li>
<li><p>w和y为这个格子的高度和宽度</p>
</li>
<li><p>confidence反应当前bbox包含物体的置信概率</p>
</li>
</ul>
<p>confidence = P(object) * IOU(交并比)</p>
<p>若包含物体，P（）=1，否则为0。所以预测时输出的p值就是预测了这个bbox和object的IoU</p>
<p>每个grid cell预测C个种类，每个种类有个概率P值，每个grid cell只输出一组预测值</p>
<p>条件概率P（class i | Object）这个概率是基于grid cell包含object的概率为前提的，所以P（class i）=P（class i | Object）* P（object）</p>
<p>最后得到class-specific confidence = P（class i） * IOU，这个值说明了box中出现相应类的概率，也表征了预测的bbox对目标的拟合程度</p>
<p>所以输出的维数是S <em> S </em> （B * 5 + C）</p>
<p>在test时，在object所在的grid cell，yolo每次都会预测许多bbox，每个预测bbox都包含了一个预测的IOU大小，选取有更大IOU的bbox就会被选出来成为检测出来的框，预测的类别是每个grid cell中最大的那个Ci值</p>
<h4 id="2-2-损失函数"><a href="#2-2-损失函数" class="headerlink" title="2.2 损失函数"></a>2.2 损失函数</h4><p>损失分为两部分，bbox和种类预测。如果设为相同比重来构成总得损失函数不太理想-&gt;因为有的grid cell并不包含有效内容-&gt;影响了（overpower）包含目标物体的cell的梯度信息，导致confidence很低，所以将bbox损失的权重调整为5，confidence损失的权重调整为0.5。（应该是调出来的值）这样的直接结果就是大bbox中小的偏差相对于小bbox中小的偏差对损失影响较小。-&gt;为了实现这个目的，我们预测的值是width和height值的平方根</p>
<p><img src="image-20220314150921131-7241762.png" alt="image-20220314150921131"></p>
<h3 id="3训练过程"><a href="#3训练过程" class="headerlink" title="3训练过程"></a>3训练过程</h3><p>YOLO模型训练分为两步：</p>
<p>1）预训练。使用ImageNet 1000类数据训练YOLO网络的前20个卷积层+1个average池化层+1个全连接层。训练图像分辨率resize到224x224。训练一周，单个corp（应该是边框预测）88% top5准确率</p>
<p>2）用步骤1）得到的前20个卷积层网络参数来初始化YOLO模型前20个卷积层的网络参数，加四个卷积层和两个全连接层，随机初始化这几层的权重，然后用VOC 20类标注数据进行YOLO模型训练。为提高图像精度，在训练检测模型时，将输入图像分辨率resize到448x448。</p>
<p>3）最后一层的输出是归一化后的width和height，x，y</p>
<p>NOTE：只有当object在相应cell中时才会有分类损失，也只有最高IOU的predictor找到后才会有bbox相应的损失惩罚</p>
<p>训练时一开始学习率要小一点，慢慢升高，最后再降下来</p>
<p>使用了dropout来尽量避免过拟合</p>
<p>非极大抑制（non-maximal suppression）解决检测结果中，有多个区域重叠问题，增大了ap</p>
<h4 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a>Limitation</h4><p>由于空间约束的原因，很难识别小的成群的目标</p>
<p>采用的特征相对比较粗糙</p>
<p>对于小目标的的识别可能定位不太准确</p>
<h4 id="模型对比"><a href="#模型对比" class="headerlink" title="模型对比"></a>模型对比</h4><p>RCNN使用一个region proposals来候选出待识别的对象，再用selective Search来生成大概2k个bbox，通过一个cnn来提取特征，再用svm对特征进行分类评分，再用线性模型调整bbox，非极大抑制来减少多重框，每个阶段都要单独调参，但是精度相对比较高。yolo一般就生成98个bbox，速度会快很多，而且是一个unified模型，运行也很快。</p>
<p>相对来说能够减少将背景误识别成object的概率</p>
<h2 id="YoloV2（Yolo9000）"><a href="#YoloV2（Yolo9000）" class="headerlink" title="YoloV2（Yolo9000）"></a>YoloV2（Yolo9000）</h2><p>存在的问题：相比于f-rcnn，预测框不准，不全，</p>
<h3 id="改良步骤："><a href="#改良步骤：" class="headerlink" title="改良步骤："></a>改良步骤：</h3><p>1.加了BN层：mAp加了2%，丢掉了dropout</p>
<p>2.分类器：用了在ImageNet上预训练的模型。原始的分类器是在224 <em> 224的图像上预训练，然后检测448 </em> 448的图像，现在改成预训练后先在448 * 448的图上fine-tune。这个操作加了%4的mAP</p>
<p>3.卷积的过程中加入了anchor box：yolov1单纯在卷积层之后使用全链接层才获取特征。现在移除全连接层，变成了对每个anchor box的种类和目标位置进行预测，目标检测依然是预测P值和框的属性值，类检测依然是预测此处物体的类别。简而言之，就是v1是对每个grid预测一次种类，现在是对每个anchor预测一次种类。对原始数据集里的框框大小来一次k均值分类来选出频率最高的几种框框类型。</p>
<p><strong>=================================</strong></p>
<p><strong>名词解释：</strong></p>
<p>anchor box：原本一个格子只能检测出一个对象，anchor box能让一个格子检测出多个对象。预先定义几个不懂形状的anchor box。假设普通yolo中一个bbox的预测输出y包含object的中心位置（横纵坐标x，y），bbox的宽和高（w，h），是否存在object的置信概率p，各个类别的预测值（n种类别就有n个输出）。那么普通yolo对于一个bbox的预测输出就是5+n维数据。</p>
<p>而anchor是对多个bbox进行预测，假设预测m个bbox，则输出y为m * (5+n)维数据。每5+n维数据都与一个bbox相关联。</p>
<p>所以现在就是根据object中心点分配到一个格子中，然后看gt和每个anchor bbox的IOU，选取IOU最大的anchor bbox来预测。</p>
<p><strong>=================================</strong></p>
<p>4.anchor box遇到的问题</p>
<p>5.直接位置预测：直接预测x，y坐标时可能会出现预测的坐标在grid cell以外的情况，不稳定，所以改成预测下图中的t值，</p>
<p><img src="anchor_offset.png" alt="image-20220305205145344"></p>
<p>预测框就是在anchor box的基础上进行微调</p>
<p>6.更精细的特征：用了一个passingthrough layer重排特征，有利于小目标识别</p>
<p>7.多重大小图像训练：所以虽然每个batch之内图像的尺寸必须是相同的，但是不同的batch之间图像的尺寸是不受限于框架的。YOLOv2便是基于这点实现了其训练过程中的多尺度。</p>
<p>8.语义分层： 在预测物体的类别时，我们遍历整个WordTree，在每个分割中采用最高的置信度路径，直到分类概率小于某个阈值（源码给的是0.6）时，然后预测结果，可以检测coco中没有的标签，类似于一种半监督学习</p>
<h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>Darknet-19</p>
<p>包括了19个卷积层和5个maxpooling层</p>
<p><img src="darknet.png" alt="image-20220305205225977"></p>
<p><img src="image-20220314155601017-7244563.png" alt="image-20220314155601017"></p>
<p>route层就是将两个或多个卷积层的结果做拼接</p>
<p>这里再放一张和yolov1标注的对比</p>
<p><img src="image-20220314155700031-7244621.png" alt="image-20220314155700031"></p>
<h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><h4 id="训练分类"><a href="#训练分类" class="headerlink" title="训练分类"></a>训练分类</h4><p>预训练，ImageNet 1000训练160个epochs。</p>
<p>fine tune，由原来的224变成448</p>
<h4 id="训练检测"><a href="#训练检测" class="headerlink" title="训练检测"></a>训练检测</h4><p>去掉最后一个卷积层，加了三个3 <em> 3 卷积层，每个卷积层后有一个1 </em> 1 的卷积层输出我们想要的结果</p>
<h3 id="loss"><a href="#loss" class="headerlink" title="loss"></a>loss</h3><p><img src="image-20220314155726577-7244651.png" alt="image-20220314155726577"></p>
<h2 id="Yolov3"><a href="#Yolov3" class="headerlink" title="Yolov3"></a>Yolov3</h2><p>先放一张网络结构图</p>
<p><img src="image-20220314155800077-7244681.png" alt="image-20220314155800077"></p>
<p>1.多尺度预测，步长不同，预测物体尺寸不同</p>
<p>2.既发挥了深层网络的语义特化抽象特征（大目标），又利用了浅层网络的细粒度的底层特征（小目标）。</p>
<h3 id="bbox预测"><a href="#bbox预测" class="headerlink" title="bbox预测"></a>bbox预测</h3><p>预测的参数还是和V2相似，但是目标检测分数（类似于IOU，表征这个bbox是否是目标bbox）改成了用逻辑回归来输出，如果有一个bbox比其他所有bbox覆盖的gt面积更多的话，他的值就是1</p>
<h3 id="网络设计"><a href="#网络设计" class="headerlink" title="网络设计"></a>网络设计</h3><h4 id="backbone-1"><a href="#backbone-1" class="headerlink" title="backbone"></a>backbone</h4><p>Darknet-53</p>
<h4 id="多尺度预测FPN-feature-pyramid-network"><a href="#多尺度预测FPN-feature-pyramid-network" class="headerlink" title="多尺度预测FPN(feature pyramid network)"></a>多尺度预测FPN(feature pyramid network)</h4><p>当前层的feature map会对更高层的feature map进行上采样，并加以利用。这是一个有跨越性的设计。因为有了这样一个结构，当前的feature map就可以获得更高层，更抽象的信息，这样的话低阶特征与高阶特征就有机融合起来了，提升检测精度。</p>
<p><img src="image-20220314160013157-7244814.png" alt="image-20220314160013157"></p>
<p>步幅越大，特征图尺寸越小，每个像素点感受野很大，有丰富的高层语义信息，容易检测到大目标，但是对小目标识别效果不太好，小目标需要在尺寸较大的特征图上面建立预测输出。</p>
<p>在目标检测中，解决这一问题的方式是，将高层级的特征图尺寸放大之后跟低层级的特征图进行融合，得到的新特征图既能包含丰富的语义信息，又具有较多的像素点，能够描述更加精细的结构。</p>
<p>深层一般具有更丰富的语义信息，但精度低，稍微浅一点的层含的语义信息会少一些，但是精度高。所以把高层的特征图通过卷积，upsample后与稍微低一点的层拼接，就有比较丰富的语义，p1和p2在空间和语义含义上都更具有优越性</p>
<h3 id="目标检测模型模块化"><a href="#目标检测模型模块化" class="headerlink" title="目标检测模型模块化"></a>目标检测模型模块化</h3><p><img src="image-20220314160406858-7245052.png" alt="image-20220314160406858"></p>
<p>yolov3开始基本上可以将目标检测模型分成backbone，Neck，head这几个大的模块，backbone是用来学习目标对象特征的基础，neck主要是关于模型多尺度识别的结构，head在其他模型上有开启下游任务的结构，也有anchor-free系列模型会在head上做一些设计</p>
<h3 id="模型输出"><a href="#模型输出" class="headerlink" title="模型输出"></a>模型输出</h3><p><img src="image-20220314160454314-7245095.png" alt="image-20220314160454314"></p>
<p>输出的是特征图，不是原来yolov1输出的序列，在每个特征图上，根据步长大小在每个相应感受野的point上生成三个预测框，每个预测框包括bbox位置信息，objectness物体是否存在置信度，以及物体类别的置信度</p>
<h4 id="类别置信度"><a href="#类别置信度" class="headerlink" title="类别置信度"></a>类别置信度</h4><p>类别置信度表示检测到的对象属于某个类别的概率（如狗、猫、香蕉、汽车等）。YOLO v3 使用 sigmoid 函数。因为对类别分数执行 softmax 操作的前提是类别是互斥的。简言之，如果对象属于一个类别，那么必须确保其不属于另一个类别。这在我们设置检测器的 COCO 数据集上是正确的。但是，当出现类别「女性」（Women）和「人」（Person）时，该假设不可行。这就是作者选择不使用 Softmax 激活函数的原因。</p>
<h4 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h4><p><img src="image-20220314160946001-7245388.png" alt="image-20220314160946001"></p>
<h3 id="正负样本分配"><a href="#正负样本分配" class="headerlink" title="正负样本分配"></a>正负样本分配</h3><p><img src="image-20220314161210057-7245531.png" alt="image-20220314161210057"></p>
<p>在训练过程中，论文上表达的是，模型会先根据在每个grid cell上预先设计好的anchor与gt框做IOU计算，然后选择某个步长上的某个特定的grid cell上的特定的bbox作为这个gt框的正样本（因此正样本很少），其余的检测框中，如果有检测框与gt框的IOU比较大（如大于0.7），就直接标记为负（这样其实漏掉了很多检测很好的样本，过于依赖先验知识了）</p>
<h2 id="Yolov3的一些代码逻辑"><a href="#Yolov3的一些代码逻辑" class="headerlink" title="Yolov3的一些代码逻辑"></a>Yolov3的一些代码逻辑</h2><p>yolov3对图像实现目标检测目标，其模型本质的功能是基于输入的图像生成对该图像上检测目标的标签的值。</p>
<p>假设一张图像被分成13 * 13 = 169个grid cells，每个cell生成3个anchor box</p>
<p>标签的值包括：bbox的位置相对值，objectness值，类别预测值。</p>
<p>特点：通过算数转换，模型计算损失时所有的标签值序列里每一个值都是由sigmoid输出0-1之间的相对值。</p>
<p>输入的单个样本：一张图像</p>
<p>对应标签：由图像生成anchor box 数据，每个anchor box数据包括上述标签的值，即每个图片的标签包含是13 <em> 13 </em> 3 <em> （4+1+clsss）个0-1之间的值，因此我们的模型输出也是13 </em> 13 <em> 3 </em> （4+1+clsss）个0-1之间的值，后续我们通过iou计算，objectness阈值，nms等处理我们模型输出的值，得到较为直观的结果。</p>
<p>所以yolov3整体的流程为：</p>
<p>图像数据resize-&gt;图像增广-&gt;图像上anchor box标签生成-&gt;将输入样本和其标签对应起来-&gt;输入模型-&gt;输出数据后选择正负样本与检测框计算loss，处理，根据模型输出计算出预测框的xywh，种类等</p>
<h3 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1 预处理"></a>1 预处理</h3><h4 id="1-1-图像读取"><a href="#1-1-图像读取" class="headerlink" title="1.1 图像读取"></a>1.1 图像读取</h4><p>用cv包读取后resize成416（为了让图像中心正好有一个grid cell），通道顺序注意一下，加一个batch_size通道,顺便归一化，把图像数值化成tensor变成相应框架的变量。</p>
<h4 id="1-2-anchor-box的生成与标注标签"><a href="#1-2-anchor-box的生成与标注标签" class="headerlink" title="1.2 anchor box的生成与标注标签"></a>1.2 anchor box的生成与标注标签</h4><h5 id="anchor-box标签生成"><a href="#anchor-box标签生成" class="headerlink" title="anchor box标签生成"></a>anchor box标签生成</h5><p>其实就是需要给每个grid cell生成指定的height和width的anchor box。bbox所需的参数即xywh：中心坐标和长宽数据。而在实际生成预测框时这四个数据都要进行一定程度的改变来指向特定物体</p>
<h5 id="划分单位size的grid-cell"><a href="#划分单位size的grid-cell" class="headerlink" title="划分单位size的grid cell"></a>划分单位size的grid cell</h5><p>列数：</p>
<script type="math/tex; mode=display">m = \frac{height}{size}</script><p>行数：</p>
<script type="math/tex; mode=display">n = \frac{width}{size}</script><h5 id="针对objectness单独的理解"><a href="#针对objectness单独的理解" class="headerlink" title="针对objectness单独的理解"></a>针对objectness单独的理解</h5><p>针对每一个图，所有的anchor box放在一起相当于一个小的数据集，其中有一些样本的objectness标签为1，有一些样本的objectness标签为0。让模型学习类似f（box参数+图像）=objectness这样的函数关系，从而让模型能够预测anchor box的objectness值</p>
<p>这里的标签是计算出来的，计算方法是计算每个anchor box和每个gt物体框的iou，同一个物体中心只存在于一个grid cell，iou超过阈值且最大的那个anchor box标签为1，超过阈值但不是最大的box标签为-1（不参加训练objectness模型），剩下的标签为0。所以同一个物体只能选一个anchor box打上objectness = 1的标签。将图像数据和box的参数作为输入，objectness值作为输出进行训练，让模型学习类似f（box参数+图像）=objectness这样的函数关系，所以训练好的抽象模型就可以根据输入的图像数据和box参数判断objectness的值。</p>
<p>当一个框的objectness为0或-1时，不用再去标注下面的box标签参数了。</p>
<h5 id="由anchor-box到预测框：中心坐标"><a href="#由anchor-box到预测框：中心坐标" class="headerlink" title="由anchor box到预测框：中心坐标"></a>由anchor box到预测框：中心坐标</h5><p>因为每个objectness = 1的anchor box都是批量生成好的，不可能和物体恰好重合，所以检测时肯定会微调，由anchor box到检测的bbox。此时为了方便，技术单位统一变成grid cell的size，所以x行，y列的位置坐标其实为 <script type="math/tex">(x + \sigma(t_{x})) \times size</script> 和 <script type="math/tex">(y + \sigma(t_{y})) \times size</script> 其中 $\sigma()$ 可以是一个sigmoid函数，输出是0到1之间的数。因此我们可以通过改变 $\sigma()$ 来改变anchor的中心坐标，且保证中心坐标一定在规定的grid cell里面。</p>
<h5 id="由anchor-box的-p-w-p-h-到预测框：w-h"><a href="#由anchor-box的-p-w-p-h-到预测框：w-h" class="headerlink" title="由anchor box的 $p_{w}$,$p_{h}$ 到预测框：w,h"></a>由anchor box的 $p_{w}$,$p_{h}$ 到预测框：w,h</h5><script type="math/tex; mode=display">w = p_{w}e^{t_{w}}</script><script type="math/tex; mode=display">h = p_{h}e^{t_{h}}</script><p>其中$t$是参数</p>
<h5 id="而anchor-box到预测框之间的这些参数就是我们模型希望能够预测的值"><a href="#而anchor-box到预测框之间的这些参数就是我们模型希望能够预测的值" class="headerlink" title="而anchor box到预测框之间的这些参数就是我们模型希望能够预测的值"></a>而anchor box到预测框之间的这些参数就是我们模型希望能够预测的值</h5><p>针对一个gt框，我们可以直接通过计算得到其中心坐标。通过上面的式子，我们可以得到真实中心坐标对应的$t$参数值，即成了我们训练的标签。通过巧妙的变换，我们将所有的值预测问题变成了一个预测某个0-1之间数值的问题，增强了模型的鲁棒性。</p>
<h5 id="模型功能"><a href="#模型功能" class="headerlink" title="模型功能"></a>模型功能</h5><p>样本：图像 + 每个objectness = 1的anchor box的四个参数值</p>
<p>标签：真实box计算出来的四个参数值-&gt;即表征真实box的位置</p>
<h5 id="预测标签"><a href="#预测标签" class="headerlink" title="预测标签"></a>预测标签</h5><p>抽象模型的训练集是只有objectness = 1的anchor box，数据是图像 + anchor box参数，标签是类别，训练后的目标是通过anchor box参数和图像就可以预测图像所属的标签。</p>
<h3 id="2-模型设计"><a href="#2-模型设计" class="headerlink" title="2 模型设计"></a>2 模型设计</h3><h4 id="2-1-backbone-ResNet"><a href="#2-1-backbone-ResNet" class="headerlink" title="2.1 backbone ResNet"></a>2.1 backbone ResNet</h4><h5 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h5><p>就通道数，卷积核，步长，padding，用的leakyRelu激活函数</p>
<h5 id="shortcut残差块"><a href="#shortcut残差块" class="headerlink" title="shortcut残差块"></a>shortcut残差块</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[shortcut]</span><br><span class="line"></span><br><span class="line">from=-3</span><br><span class="line"></span><br><span class="line">activation=linear</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>跳过连接与残差网络中使用的结构相似，参数 from 为-3 表示捷径层的输出会通过将之前层的和之前第三个层的输出的特征图与模块的输入相加而得出</p>
<h5 id="上采样upsample"><a href="#上采样upsample" class="headerlink" title="上采样upsample"></a>上采样upsample</h5><p>参数只有一个步幅</p>
<h5 id="路由层Route"><a href="#路由层Route" class="headerlink" title="路由层Route"></a>路由层Route</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[route]</span><br><span class="line"></span><br><span class="line">layers = -4</span><br><span class="line"></span><br><span class="line">[route]</span><br><span class="line"></span><br><span class="line">layers = -1, 61</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>路由层需要一些解释，它的参数 layers 有一个或两个值。当只有一个值时，它输出这一层通过该值索引的特征图。在我们的实验中设置为了-4，所以层级将输出路由层之前第四个层的特征图。</p>
<p>当层级有两个值时，它将返回由这两个值索引的拼接特征图。在我们的实验中为-1 和 61，因此该层级将输出从前一层级（-1）到第 61 层的特征图，并将它们按深度拼接。</p>
<p>按深度即对应位置的方块通道数增加</p>
<h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">x = np.random.randn(1, 3, 640, 640).astype(&#x27;float32&#x27;)</span><br><span class="line"></span><br><span class="line">x = paddle.to_tensor(x)</span><br><span class="line"></span><br><span class="line">C0, C1, C2 = backbone(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>指定输入数据的形状是(1,3,640,640)，则3个层级的输出特征图的形状分别是C0 (1, 1024, 20, 20)，C1(1,512,40,40)和C2(1,256,80,80)。</p>
<p>每个小方块区域产生K个预测框，每个预测框需要(5+C)个实数预测值，则每个像素点相对应的要有K(5+C)个实数。为了解决这一问题，对特征图进行多次卷积，并将最终的输出通道数设置为K(5+C)，即可将生成的特征图与每个预测框所需要的预测值对应起来。7</p>
<p>目的：保证为了针对输出和标签形成对应的loss。</p>
<h4 id="2-2-yolo层"><a href="#2-2-yolo层" class="headerlink" title="2.2 yolo层"></a>2.2 yolo层</h4><p>yolo层是检测层(一种head)，传入一个Backbone生成的特征图（如C0），每一个特征图表征了一种属性在指定grid cell位置的第k个预测框的第n个参数的预测值。在yolo层里输入和输出通道数不变。</p>
<p>输出的是一个route特征图和一个tip特征图，其中tip比route多经历一个卷积核为3的卷积层。然后tip特征图经过一个卷积核为1的卷积层就输出C0层的预测特征图P0.</p>
<p>x-&gt;(backbone)-&gt;C0-&gt;(yolo层)route-&gt;(conv2d)-&gt;tip-&gt;(conv2d)-&gt;P0</p>
<p>-&gt;C1</p>
<p>-&gt;C2</p>
<h3 id="正负样本标注细节：objecness标注"><a href="#正负样本标注细节：objecness标注" class="headerlink" title="正负样本标注细节：objecness标注"></a>正负样本标注细节：objecness标注</h3><p>首先基于原始图像的标注文件生成许多anchor box和相应标注。</p>
<p>Shape是[batch_size, rows, cols, anchors],就是单个图片分割成rows <em> cols个cell，每个cell生成K个anchors标注，因此单个图像一共生成rows</em>cols*K个anchor标注框。</p>
<p><strong>正样本标注</strong></p>
<p>这些标注中，每个真实框只有一个标注框与之对应，即生成的所有anchor box中与真实框IoU最大的anchor box标注为正</p>
<p><strong>负样本标注</strong></p>
<p>这些标注中，没有跟任何一个真实框匹配上的标注框都标记为负样本。</p>
<p>问题： objectness标注的是该anchor bbox包含物体的可能性，即训练时理论上正样本标注框对应的预测框应该是包含物体的，负样本标注框对应的预测框应该是不包含物体的。那么是不是<strong>所有标注为负样本的标注框对应的预测框都一定不包含物体</strong>呢？答案显然是否定的，依然有很多效果很好的预测框没有参与训练。这些框的处理规则是：</p>
<h4 id="忽略预测框中，与真实框-IoU-较大的负样本框"><a href="#忽略预测框中，与真实框-IoU-较大的负样本框" class="headerlink" title="忽略预测框中，与真实框**IoU**较大的负样本框"></a><strong>忽略预测框中，与真实框**</strong>IoU<strong>**较大的负样本框</strong></h4><p>首先选出IoU大于阈值的所有pred_box</p>
<p>选出跟真实框IoU大于指定阈值的预测，get_iou_above_thresh_inds(pred_box, gt_boxes, iou_threshold)，</p>
<p> pred_box：预测框，shape是batch_size, rows, cols, anchors，即按照特征图尺寸，每个位置都有K个预测的anchors。</p>
<p> gt_bboxes：真实框， shape相同，iou_threshold是阈值（0.7）。</p>
<p>1.取出对应位置的K个pred_box与相应位置的gt_boxes计算IoU，选出IoU&gt; iou_threshold的pred_boxes标记为1</p>
<p>2.将所有label_objectness &lt; 0.5的标注box选出来，索引为negative_indices,即没有和gt_bbox匹配上的标注框都已被标记为负样本。这些box本来是应该作为负样本参与损失函数objectness部分的构建，但是<strong>如果相应的**</strong>pred_box<strong><strong>有</strong></strong>IoU<strong>**和真实框很大的，标记为负样本显然会对模型的学习造成影响</strong>。因此这些选出来的bbox索引negative_indices 与1中得到的索引相乘，得到的就是既是没有与gt匹配上的样本，预测框又和gt有很大IoU，将这些框的索引标记为-1，不参与损失函数构建。</p>
<p>所以总结一下 yolov3在这个模块的特点是：<strong>按照经验设置**</strong>anchor <strong>box**</strong>，按照经验设置<strong>IoU</strong>阈值，按照经验忽略一些检测框。</p>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h3 id="loss-1"><a href="#loss-1" class="headerlink" title="loss"></a>loss</h3><p><img src="image-20220314163109996.png" alt="image-20220314163109996"></p>
<h3 id="3-输出变换"><a href="#3-输出变换" class="headerlink" title="3.输出变换"></a>3.输出变换</h3><h4 id="输出时3个预测图维度不同，先变换维度"><a href="#输出时3个预测图维度不同，先变换维度" class="headerlink" title="输出时3个预测图维度不同，先变换维度"></a>输出时3个预测图维度不同，先变换维度</h4><p>prediction（batch_size,第几个anchor box，bbox的几个参数）</p>
<p>从第三个维度里，原地取出x，y，confidence的预测值，取sigmoid值</p>
<p>x，y加上偏移：和grid cell的位置相关。</p>
<p>再根据w，h来调整anchor box</p>
<p>再原地将class的预测值通过sigmoid</p>
<p>最后将检测图的大小调整到和输入图像一致。</p>
<h4 id="执行nms（非极大值抑制）"><a href="#执行nms（非极大值抑制）" class="headerlink" title="执行nms（非极大值抑制）"></a>执行nms（非极大值抑制）</h4><p>取出一张图的bbox参数</p>
<p>先取出80个class的预测值，找出最大值，取出</p>
<h2 id="YOLOv4"><a href="#YOLOv4" class="headerlink" title="YOLOv4"></a>YOLOv4</h2><h3 id="Data-Augmentation"><a href="#Data-Augmentation" class="headerlink" title="Data Augmentation"></a>Data Augmentation</h3><h4 id="Cut-Mix"><a href="#Cut-Mix" class="headerlink" title="Cut Mix"></a>Cut Mix</h4><p>就是将一部分区域cut掉但不填充0像素而是随机填充训练集中的其他数据的区域像素值，分类结果按一定的比例分配，使得模型能够从一幅图像上的局部视图上识别出两个目标，提高训练的效率。</p>
<h4 id="Mosaic-Mix"><a href="#Mosaic-Mix" class="headerlink" title="Mosaic Mix"></a>Mosaic Mix</h4><p>四个图mix，可以显著减少有的模型对大batch size的需求（coco）</p>
<h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><h4 id="backbone：CSPDarknet53"><a href="#backbone：CSPDarknet53" class="headerlink" title="backbone：CSPDarknet53"></a>backbone：CSPDarknet53</h4><p>目的：减少部分多余的梯度信息</p>
<p>作者认为现在的网络计算量大是由于在网络优化的过程中重复的梯度信息。作者将一个stage的头尾两部分的特征图集成起来，来解决这个问题，减少了至少20%的计算量，网络效果与之前相当甚至超过，而且CSP结构可以和其他网络结构结合，</p>
<p>使用了mish层作为激活函数，原因是在小于0的部分有更多梯度信息</p>
<h5 id="Weighted-Residual-Connections-WRC-："><a href="#Weighted-Residual-Connections-WRC-：" class="headerlink" title="Weighted-Residual-Connections (WRC)："></a>Weighted-Residual-Connections (WRC)：</h5><p>残差块里残差部分变成两个连续Conv-BN-ReLUs。</p>
<h5 id="Cross-mini-Batch-Normalization-CmBN"><a href="#Cross-mini-Batch-Normalization-CmBN" class="headerlink" title="Cross mini-Batch Normalization (CmBN)"></a>Cross mini-Batch Normalization (CmBN)</h5><h4 id="Neck：SPP-PAN"><a href="#Neck：SPP-PAN" class="headerlink" title="Neck：SPP + PAN"></a>Neck：SPP + PAN</h4><p>PAN其实就是在FPN自深到浅的concat之后再加上一个自浅到深的concat。</p>
<p>SPP（spatial pyramid pooling）特点：</p>
<ul>
<li><p>不管输入尺寸是怎样的，SPP可以产生固定大小的输出</p>
</li>
<li><p>使用多个窗口</p>
</li>
<li><p>SPP可以使用同一图像不同尺寸作为输入，得到同样长度的池化特征。</p>
</li>
</ul>
<p>根据输入和输入图像的尺寸来设计滑动窗口的尺寸和步长，从而保证不同的输入有相同的输出</p>
<p>保留原图片的尺寸对实验的特征提取和结果都很重要。</p>
<p>简单一点就是目标检测时把最后一个卷积特征图上ROI拿出来，经过SPP之后不同大小的ROI区域图像变成相同大小的数据输入到全连接层</p>
<p>实验证明：</p>
<p>对尺度的改变具有更强的鲁棒性，能提高准确率</p>
<p>而且是pooling层，对网络结构没有影响</p>
<h3 id="loss-2"><a href="#loss-2" class="headerlink" title="loss"></a>loss</h3><p>MSE损失函数存在的问题：将中心点坐标作为独立的变量对待</p>
<p>（1）bounding box regression损失</p>
<p>（2）置信度损失</p>
<p>（3）分类损失</p>
<h4 id="IOU-loss"><a href="#IOU-loss" class="headerlink" title="IOU loss"></a>IOU loss</h4><script type="math/tex; mode=display">L_{IOU}=1-IOU(A,B)</script><p>但这个损失函数知道bbox重叠的时候管用，不重叠的话iou=0，没有梯度</p>
<h4 id="GIOU"><a href="#GIOU" class="headerlink" title="GIOU"></a>GIOU</h4><script type="math/tex; mode=display">L_{GIOU}=1-IOU(A,B)+|C-A\bigcup B|/C</script><p>Generallized IOU loss,IOU LOSS加了一个惩罚项，惩罚项是大框框C中非AB部分面积和大框框面积的比，当然loss越小越好，具体是GIOU先增大预测框的大小来找真实框，找到后再优化，但问题在于这个找真实框的时间可能会很久，需要比较长的收敛速度</p>
<p><img src="GIOU.png" alt="image-20220305205502841"></p>
<h4 id="DIOU"><a href="#DIOU" class="headerlink" title="DIOU"></a>DIOU</h4><p>D:distance，原理在于优化anchor中心和真实框中心的距离，这样可以收敛更快</p>
<script type="math/tex; mode=display">L_{GIOU}=1-IOU(A,B)+\rho (A_{ctr},B_{ctr})/c^{2}</script><p>A : 预测框， B：真实框</p>
<p>$A_{ctr}$: 预测框中心点坐标</p>
<p>$B_{ctr}$ ：真实框中心点坐标</p>
<p>$\rho (.)$是欧式距离的计算</p>
<p>c 为 A , B 最小包围框的对角线长度</p>
<p><img src="diou.png" alt="image-20220305205556281"></p>
<p>距离越远，DIOU越接近2，距离越近，DIOU越接近0。</p>
<h4 id="CIOU"><a href="#CIOU" class="headerlink" title="CIOU"></a>CIOU</h4><p>Complete IoU Loss</p>
<p>（1）重叠面积</p>
<p>（2）中心点距离</p>
<p>（3）长宽比</p>
<script type="math/tex; mode=display">L_{GIOU}=1-IOU(A,B)+\rho (A_{ctr},B_{ctr})/c^{2}+\alpha.v</script><h2 id="YOLOv5"><a href="#YOLOv5" class="headerlink" title="YOLOv5"></a>YOLOv5</h2><h3 id="网络结构和v4基本相同"><a href="#网络结构和v4基本相同" class="headerlink" title="网络结构和v4基本相同"></a>网络结构和v4基本相同</h3><h4 id="backbone-Neck"><a href="#backbone-Neck" class="headerlink" title="backbone + Neck"></a>backbone + Neck</h4><p>和v4一样，都是CSPDarknet + PAN</p>
<h1 id="明确每个trick目的是什么"><a href="#明确每个trick目的是什么" class="headerlink" title="明确每个trick目的是什么"></a>明确每个trick目的是什么</h1><p>一般目标检测模型的pipeline显示特征提取，而后是分类器或者定位器在特征空间中寻找需要的特征，一般是用滑动窗口扫描整张图像或者扫描图相中的子集</p>
<p>模型Head主要用于最终检测部分。它在特征图上应用锚定框，并生成带有类概率、对象得分和包围框的最终输出向量。</p>
<h2 id="通用API"><a href="#通用API" class="headerlink" title="通用API"></a>通用API</h2><h3 id="绘制anchor-box"><a href="#绘制anchor-box" class="headerlink" title="绘制anchor box"></a>绘制anchor box</h3><h4 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h4><p>中心点坐标：[x, y]</p>
<p>基准长度：length</p>
<p>尺寸比例：scales</p>
<p>长宽比例：ratios</p>
<p>原图尺寸：img_height,img_width</p>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>基准长度,尺寸,和长宽比得到anchor的长和宽</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h = length \times scales \times \sqrt[]&#123;ratios&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = length \times scales \div \sqrt[]&#123;ratios&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由中心点和w，h就可以确定anchor box的坐标和大小</p>
<p>然后传入已有的坐标轴即可</p>
<h3 id="计算iou"><a href="#计算iou" class="headerlink" title="计算iou"></a>计算iou</h3><h4 id="输入：-1"><a href="#输入：-1" class="headerlink" title="输入："></a>输入：</h4><p>xywh形式或者xyxy格式的两个box，即两个长度为4的数列</p>
<h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><p>IOU数值</p>
<h4 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h4><p>思想都是先取出相交处的左上和右下点的坐标，计算出相交面积，然后就好算了。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/01/Linux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="篮球架上打砖块">
      <meta itemprop="description" content="Apodidae">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Upperlan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/01/Linux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">Linux常用操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-01 22:22:17" itemprop="dateCreated datePublished" datetime="2021-11-01T22:22:17+08:00">2021-11-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-06 13:41:53" itemprop="dateModified" datetime="2022-03-06T13:41:53+08:00">2022-03-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E4%BD%9C%E5%B8%B8%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">工作常用</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><p>pwd：print work directory<br>ls : list file<br>ls -a<br>ls -ltr<br><code>mkdir &lt;directory&gt;</code>：创建目录<br><code>rmdir &lt;directory&gt;</code>:删除目录</p>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><p>移动和剪切：<br>cp 要复制的文件名或目录 目标目录<br>mv 要移动的文件名或目录 目标目录<br>mv 要被更改的文件名 更改后的文件名<br>删除文件：<br>rm 删除的文件名<br>rm -f 要删除的文件夹名<br>打印文件：cat 要输出的文件名<br>用cat复制一个文本并重命名：cat 要被重命名的文件 &gt; 重命名后的文件<br>看一个文件的前几行： head -n num 文件名<br>对比A和B文件：diff A B</p>
<h2 id="文件压缩"><a href="#文件压缩" class="headerlink" title="文件压缩"></a>文件压缩</h2><h3 id="tar文件"><a href="#tar文件" class="headerlink" title="tar文件"></a>tar文件</h3><p>打包：tar -zcvf<br>解压: tar -zxvf</p>
<h3 id="zip文件"><a href="#zip文件" class="headerlink" title="zip文件"></a>zip文件</h3><p>打包：zip 目标压缩包的名称 被压缩的文件1 被压缩的文件2</p>
<h2 id="man命令：忘记某个命令参数的含义了"><a href="#man命令：忘记某个命令参数的含义了" class="headerlink" title="man命令：忘记某个命令参数的含义了"></a>man命令：忘记某个命令参数的含义了</h2><p>man 对应的命令<br>man 5 配置文件的详细信息了</p>
<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>useradd 创建的用户名<br>userdel 删除的用户名<br>修改当前用户密码：passwd<br>修改其他用户密码（root）：passwd 用户名</p>
<h3 id="权限管理："><a href="#权限管理：" class="headerlink" title="权限管理："></a>权限管理：</h3><p>权限划分：-rwxrwxrwx-<br>前三位 文件归属人拥有的权限是什么<br>中间三位 归属的组，组员拥有的是什么<br>后三位 如果都不是以上人员，拥有的权限是什么<br>读权限 对应数字r=4<br>写权限 对应数字w=2<br>执行权限 对应数字x=1<br>修改权限chmod<br>chmod 750 filename<br>chmod -R 750 dirname<br>修改归属chown<br>修改归属人以及归属组：<br>chown user:group filename<br>chown -R user:group dirname</p>
<h2 id="文件修改"><a href="#文件修改" class="headerlink" title="文件修改"></a>文件修改</h2><p>sed -i ‘s/aaa/bbb/g’ filename<br>s代表替换，aaa代表替换前的原始字符，bbb代表替换后的字符，g代表的是所有文件全部修改</p>
<h3 id="删除文件内容"><a href="#删除文件内容" class="headerlink" title="删除文件内容"></a>删除文件内容</h3><p>删除前三行的内容：sed -i 1,3d filename<br>第一行到第三行全部删除，d就是删除的意思<br>删除第五行内容：sed -i 5d filename</p>
<h3 id="文本处理命令awk"><a href="#文本处理命令awk" class="headerlink" title="文本处理命令awk"></a>文本处理命令awk</h3><h4 id="按列输出"><a href="#按列输出" class="headerlink" title="按列输出"></a>按列输出</h4><p>awk ‘{print $2}’ filename //以空格为分隔符，输出第二列<br>awk ‘{print $NF}’ filename //以空格为分隔符，输出最后一列<br>awk -F ‘a’ ‘{print $2}’ filename //以a为分隔符，输出第二列<br>正则字符串匹配：<br>awk ‘$2 ~/th/ {print $2,$4}’ filename //第二列包含th字符时，输出第2，4列</p>
<h2 id="搜索查找命令"><a href="#搜索查找命令" class="headerlink" title="搜索查找命令"></a>搜索查找命令</h2><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>grep -n ‘t[ae]st’ filename //在filename中查找所有包含tast或者test的内容<br>grep abc -rl dirname // grep查找dirname中所有包含abc内容的文件，可以搜索代码的变量</p>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>find / -name filename // 从根目录下查找名为filename的文件<br>find / -name filename -type d //从根目录小查找文件名为filename的文件并且属性为目录的文件<br>find / -name filename -exec ls -l {} \; //查找文件名为filename的文件，并查看该文件的属性</p>
<h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><p>ping 网址 ：检测网络连通性<br>telnet  网址 端口 ：检测域名/IP和端口<br>netstat 各种网络相关信息，如网络连接，路由表，接口状态<br>ifconfig 查看网卡信息</p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>ps展示PID和cmd内容<br>ps -ef内容更丰富<br>top跳到一个新的页面，可以监控具体PID占用cpu，内存的情况<br>杀死进程<br>kill <pid><br>强制杀死<br>kill -9 <pid></p>
<h3 id="磁盘管理-1"><a href="#磁盘管理-1" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><p>df命令：显示磁盘分区上可以使用的磁盘空间<br>    df -lh:以GB，MB，KB的格式显示可以使用的分区<br>du命令：显示每个文件和目录的磁盘使用空间</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/13/STL%E5%BA%93%E5%86%85%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="篮球架上打砖块">
      <meta itemprop="description" content="Apodidae">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Upperlan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/13/STL%E5%BA%93%E5%86%85%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">STL库内容器的基本操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-13 13:59:06" itemprop="dateCreated datePublished" datetime="2021-10-13T13:59:06+08:00">2021-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-06 14:01:49" itemprop="dateModified" datetime="2022-03-06T14:01:49+08:00">2022-03-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>empty() 堆栈为空则返回真</p>
<p>pop() 移除栈顶元素 （删除）</p>
<p>push() 在栈顶增加元素 （增加）</p>
<p>size() 返回栈中元素数目</p>
<p>top() 返回栈顶元素，不删除（获取）</p>
<p>栈（stack）是限制插入和删除只能在一个位置上进行的线性表，该位置在表的末端，叫做栈顶。添加元素只能在尾节点后添加，删除元素只能删除尾节点，查看节点也只能查看尾节点。添加、删除、查看依次为入栈（push）、出栈（pop）、栈顶节点（top）。形象的说，栈是一个先进后出（LIFO）表，先进去的节点要等到后边进去的节点出来才能出来。</p>
<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><h3 id="基本函数实现"><a href="#基本函数实现" class="headerlink" title="基本函数实现"></a>基本函数实现</h3><p>1.push_back 在数组的最后添加一个数据<br>2.pop_back 去掉数组的最后一个数据<br>3.at 得到编号位置的数据<br>4.begin 得到数组头的指针<br>5.end 得到数组的最后一个单元+1的指针<br>6．front 得到数组头的引用<br>7.back 得到数组的最后一个单元的引用<br>8.max_size 得到vector最大可以是多大<br>9.capacity 当前vector分配的大小<br>10.size 当前使用数据的大小<br>11.resize 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值<br>12.reserve 改变当前vecotr所分配空间的大小<br>13.erase 删除指针指向的数据项<br>14.clear 清空当前的vector<br>15.rbegin 将vector反转后的开始指针返回(其实就是原来的end-1)<br>16.rend 将vector反转构的结束指针返回(其实就是原来的begin-1)<br>17.empty 判断vector是否为空<br>18.swap 与另一个vector交换数据</p>
<h4 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h4><ul>
<li>vector():创建一个空vector</li>
<li>vector(int nSize):创建一个vector,元素个数为nSize</li>
<li>vector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为t</li>
<li>vector(const vector&amp;):复制构造函数</li>
<li>vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中<h4 id="2-增加函数"><a href="#2-增加函数" class="headerlink" title="2.增加函数"></a>2.增加函数</h4></li>
<li>void push_back(const T&amp; x):向量尾部增加一个元素X</li>
<li>iterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素x</li>
<li>iterator insert(iterator it,int n,const T&amp; x):向量中迭代器指向元素前增加n个相同的元素x</li>
<li>iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</li>
</ul>
<h1 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h1><h3 id="deque的API"><a href="#deque的API" class="headerlink" title="deque的API"></a>deque的API</h3><h4 id="1-1deque构造函数"><a href="#1-1deque构造函数" class="headerlink" title="1.1deque构造函数"></a>1.1deque构造函数</h4><p>deque<T> deqT;//默认构造形式</p>
<p>deque(beg, end);//构造函数将[beg, end)区间中的元素拷贝给本身。</p>
<p>deque(n, elem);//构造函数将n个elem拷贝给本身。</p>
<p>deque(const deque &amp;deq);//拷贝构造函数。</p>
<h4 id="1-2-deque赋值操作"><a href="#1-2-deque赋值操作" class="headerlink" title="1.2 deque赋值操作"></a>1.2 deque赋值操作</h4><p>assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。</p>
<p>assign(n, elem);//将n个elem拷贝赋值给本身。</p>
<p>deque&amp; operator=(const deque &amp;deq); //重载等号操作符</p>
<p>swap(deq);// 将deq与本身的元素互换</p>
<h4 id="1-3-deque大小操作"><a href="#1-3-deque大小操作" class="headerlink" title="1.3 deque大小操作"></a>1.3 deque大小操作</h4><p>deque.size();//返回容器中元素的个数</p>
<p>deque.empty();//判断容器是否为空</p>
<p>deque.resize(num);//重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
<p>deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除。</p>
<h4 id="2-1-deque双端插入和删除操作"><a href="#2-1-deque双端插入和删除操作" class="headerlink" title="2.1 deque双端插入和删除操作"></a>2.1 deque双端插入和删除操作</h4><p>push_back(elem);//在容器尾部添加一个数据</p>
<p>push_front(elem);//在容器头部插入一个数据</p>
<p>pop_back();//删除容器最后一个数据</p>
<p>pop_front();//删除容器第一个数据</p>
<h4 id="2-2-deque数据存取"><a href="#2-2-deque数据存取" class="headerlink" title="2.2 deque数据存取"></a>2.2 deque数据存取</h4><p>at(idx);//返回索引idx所指的数据，如果idx越界，抛出out_of_range。</p>
<p>operator[];//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。</p>
<p>front();//返回第一个数据。</p>
<p>back();//返回最后一个数据</p>
<h4 id="2-3-deque插入操作"><a href="#2-3-deque插入操作" class="headerlink" title="2.3 deque插入操作"></a>2.3 deque插入操作</h4><p>insert(pos,elem);//在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p>
<p>insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</p>
<p>insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</p>
<h4 id="2-4-deque删除操作"><a href="#2-4-deque删除操作" class="headerlink" title="2.4 deque删除操作"></a>2.4 deque删除操作</h4><p>clear();//移除容器的所有数据</p>
<p>erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</p>
<p>erase(pos);//删除pos位置的数据，返回下一个数据的位置。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/12/C-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="篮球架上打砖块">
      <meta itemprop="description" content="Apodidae">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Upperlan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/12/C-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">C++类和对象笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-12 13:09:20" itemprop="dateCreated datePublished" datetime="2021-07-12T13:09:20+08:00">2021-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-06 13:41:25" itemprop="dateModified" datetime="2022-03-06T13:41:25+08:00">2022-03-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>面向对象的三大特性：封装，继承，多态</p>
<h3 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1 封装"></a>4.1 封装</h3><ul>
<li>将属性和行为作为一个整体，表现事物</li>
<li>将属性和行为加以权限控制<h4 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h4></li>
</ul>
<ol>
<li>public 内外都可以访问</li>
<li>protected 类内可以访问，类外不行</li>
<li>private 类内可以访问，类外不行</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//访问权限</span><br><span class="line">//1. public 内外都可以访问</span><br><span class="line">//2. protected 类内可以访问，类外不行,子类可访问</span><br><span class="line">//3. private 类内可以访问，类外不行。子类不可访问</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    string m_Name;</span><br><span class="line">protected:</span><br><span class="line">    string m_Car;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    int m_Password;</span><br><span class="line">public:</span><br><span class="line">    void func()</span><br><span class="line">    &#123;</span><br><span class="line">        m_Name = &quot;Eric&quot;;</span><br><span class="line">        m_Car = &quot;Benz&quot;;</span><br><span class="line">        m_Password = 123456;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    Person p1;</span><br><span class="line">    p1.m_Name = &quot;EricD&quot;;</span><br><span class="line">    //m_Car = &quot;Bmw&quot;;//不可访问</span><br><span class="line">    </span><br><span class="line">    p1.func();</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-1-2-struct和class曲别"><a href="#4-1-2-struct和class曲别" class="headerlink" title="4.1.2 struct和class曲别"></a>4.1.2 struct和class曲别</h4><p>默认的访问权限不同</p>
<ul>
<li>struct默认权限为公有</li>
<li>class默认权限为私有</li>
</ul>
<h4 id="4-1-3-成员属性设置为私有"><a href="#4-1-3-成员属性设置为私有" class="headerlink" title="4.1.3 成员属性设置为私有"></a>4.1.3 成员属性设置为私有</h4><p><strong>优点1：</strong>将所有成员属性设置为私有，可以自己控制读写权限<br><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//成员属性设置为私有</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void setName(string name)//赋予写权限</span><br><span class="line">    &#123;</span><br><span class="line">        m_Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    void setLover(string name)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Lover = name;</span><br><span class="line">    &#125;</span><br><span class="line">    string getName()</span><br><span class="line">    &#123;</span><br><span class="line">        return m_Name;</span><br><span class="line">    &#125;</span><br><span class="line">    int getAge()</span><br><span class="line">    &#123;</span><br><span class="line">        return m_Age;</span><br><span class="line">    &#125;</span><br><span class="line">    void setAge(int age)</span><br><span class="line">    &#123;</span><br><span class="line">        if(age &lt; 0 ||age &gt; 150)//检测数据的有效性</span><br><span class="line">        &#123;</span><br><span class="line">            m_Age = 0;</span><br><span class="line">            cout &lt;&lt; &quot;赋值有误&quot; &lt;&lt; endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    //string getLover()</span><br><span class="line">    //&#123;</span><br><span class="line">    //    return m_Lover;</span><br><span class="line">    //&#125;//没有这个函数，Lover就变成只写变量了</span><br><span class="line">private:</span><br><span class="line">//对读写权限的控制</span><br><span class="line">    string m_Name;</span><br><span class="line">    int m_Age;</span><br><span class="line">    string m_Lover;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    Person p;</span><br><span class="line">    p.setName(&quot;Eric&quot;);</span><br><span class="line">    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p.getName() &lt;&lt; endl;</span><br><span class="line">    p.setAge(1000);</span><br><span class="line">    cout &lt;&lt; &quot;年龄：&quot; &lt;&lt; p.getAge() &lt;&lt; endl;</span><br><span class="line">    p.setLover(&quot;Ding&quot;);</span><br><span class="line">    //cout &lt;&lt; &quot;Lover:&quot; &lt;&lt; p.getLover() &lt;&lt; endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h3><h4 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h4><p><strong>构造函数：</strong> 创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用。<br><code>类名（）&#123;&#125;</code><br>没有返回值，与类名相同，可以有参数，无需手动调用，系统会调用一次<br><strong>析构函数：</strong> 对象销毁前系统自动调用，执行一些清理工作。<br><code>~类名（）&#123;&#125;</code><br>与类名相同，在名称前加~。不能有参数，无返回值，无需手动调用，系统会调用一次</p>
<h4 id="4-2-2-构造函数的分类及调用"><a href="#4-2-2-构造函数的分类及调用" class="headerlink" title="4.2.2 构造函数的分类及调用"></a>4.2.2 构造函数的分类及调用</h4><p>两种分类方式，三种调用方式。<br>按参数分：有参构造，无参构造<br>按类型分：普通构造，拷贝构造<br>括号法，显示法，隐式转换法</p>
<h4 id="4-2-3-拷贝构造函数的调用时机"><a href="#4-2-3-拷贝构造函数的调用时机" class="headerlink" title="4.2.3 拷贝构造函数的调用时机"></a>4.2.3 拷贝构造函数的调用时机</h4><ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>值<strong>传递</strong>的方式给函数参数赋值</li>
<li>以值方式<strong>返回</strong>局部对象<h4 id="4-2-4构造函数调用规则"><a href="#4-2-4构造函数调用规则" class="headerlink" title="4.2.4构造函数调用规则"></a>4.2.4构造函数调用规则</h4>默认情况下，C++至少给一个类添加三个函数：</li>
</ul>
<ol>
<li>默认构造函数（无参，函数体为空）</li>
<li>默认析构函数（无参，函数体为空）</li>
<li>默认拷贝构造函数</li>
</ol>
<ul>
<li>如果用户定义有参构造函数，C++不再提供默认无参构造</li>
<li>如果用户定义拷贝构造函数，C++不再提供其他构造函数<h4 id="4-2-5-深拷贝与浅拷贝"><a href="#4-2-5-深拷贝与浅拷贝" class="headerlink" title="4.2.5 深拷贝与浅拷贝"></a>4.2.5 深拷贝与浅拷贝</h4>浅拷贝：简单的赋值拷贝操作<br>深拷贝：在堆区重新申请空间进行拷贝操作<strong>有指针的时候要注意</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//构造函数的调用规则</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Person()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person的默认构造函数调用&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Person(int a,int height)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Age = a;</span><br><span class="line">        m_Height = new int(height);</span><br><span class="line">        cout &lt;&lt; &quot;Person的有参构造函数调用&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //自己实现一个拷贝构造函数来解决浅拷贝带来的问题</span><br><span class="line">    Person(const Person &amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person的拷贝构造函数调用&quot; &lt;&lt; endl;</span><br><span class="line">        m_Age= p.m_Age;</span><br><span class="line">        //m_Height = p.m_Height;编译器默认实现就是这行代码</span><br><span class="line">        //深拷贝操作</span><br><span class="line">        m_Height = new int(*p.m_Height);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Person()</span><br><span class="line">    &#123;</span><br><span class="line">        //通常将堆区开辟的数据做释放操作</span><br><span class="line">        //浅拷贝带来的问题就是，堆区内存的重复释放</span><br><span class="line">        if(m_Height != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">             delete m_Height;</span><br><span class="line">            m_Height = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    int m_Age;</span><br><span class="line">    int *m_Height;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">    Person p1(18,160);</span><br><span class="line">    cout &lt;&lt; &quot;p1的年龄为 &quot; &lt;&lt; p1.m_Age &lt;&lt;  &quot; 身高为： &quot; &lt;&lt; *p1.m_Height &lt;&lt; endl;</span><br><span class="line">    Person p2(p1);</span><br><span class="line">     cout &lt;&lt; &quot;p2的年龄为&quot; &lt;&lt; p2.m_Age &lt;&lt;  &quot; 身高为： &quot; &lt;&lt; *p2.m_Height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    test01();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-2-6-初始化列表"><a href="#4-2-6-初始化列表" class="headerlink" title="4.2.6 初始化列表"></a>4.2.6 初始化列表</h4><strong>语法：</strong> 构造函数（）：属性1（值1），属性2（值2）…<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//初始化列表</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //传统初始化操作</span><br><span class="line">    // Person(int a,int b,int c)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     m_A = a;</span><br><span class="line">    //     m_B = b;</span><br><span class="line">    //     m_C = c;</span><br><span class="line">    // &#125;</span><br><span class="line">    //初始化列表初始化属性,注意冒号位置</span><br><span class="line">    Person(int a,int b,int c):m_A(a),m_B(b),m_C(c)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    int m_A;</span><br><span class="line">    int m_B;</span><br><span class="line">    int m_C;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">    Person p(1,2,3);</span><br><span class="line">    cout &lt;&lt; &quot;m_A = &quot; &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; p.m_B &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;m_C = &quot; &lt;&lt; p.m_C &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    test01();</span><br><span class="line">    </span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-2-7-类对象作为类成员"><a href="#4-2-7-类对象作为类成员" class="headerlink" title="4.2.7 类对象作为类成员"></a>4.2.7 类对象作为类成员</h4>C++类中的成员可以实另一个类的对象，我们称该成员为对象成员。<br>当其他类对象作为本类成员，构造时候先构造类对象，再构造自身。<br>析构函数调用正好相反，后构造的先释放，类似堆，后进先出。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">//类对象作为类成员,</span><br><span class="line">class Phone</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Phone (string pName)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Phone构造函数调用&quot; &lt;&lt; endl;</span><br><span class="line">        m_pName = pName;</span><br><span class="line">    &#125;</span><br><span class="line">    //手机品牌名称</span><br><span class="line">    ~Phone()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Phone析构函数调用&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    string m_pName;</span><br><span class="line">&#125;;</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Person(string name,string pName):m_Name(name) ,m_Phone(pName)//隐式转换法</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person构造函数调用&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Person()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person析构函数调用&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    string m_Name;</span><br><span class="line">    Phone m_Phone;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">    Person p(&quot;张三&quot;,&quot;iphone max&quot;);</span><br><span class="line">    cout &lt;&lt; p.m_Name &lt;&lt; &quot; 拿着： &quot; &lt;&lt; p.m_Phone.m_pName &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    test01();</span><br><span class="line">    </span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Phone构造函数调用</span><br><span class="line">Person构造函数调用</span><br><span class="line">张三 拿着： iphone max</span><br><span class="line">Person析构函数调用</span><br><span class="line">Phone析构函数调用</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure>
<h4 id="4-2-8-静态成员"><a href="#4-2-8-静态成员" class="headerlink" title="4.2.8 静态成员"></a>4.2.8 静态成员</h4>就是在成员变量和成员函数前加上关键字<strong>static</strong> ，称为静态成员</li>
</ul>
<ol>
<li>静态成员变量</li>
</ol>
<ul>
<li>所有对象共享同一份数据</li>
<li>在编译阶段分配内存</li>
<li>类内声明，类外初始化</li>
</ul>
<ol>
<li>静态成员函数</li>
</ol>
<ul>
<li>所有对象共享同一个函数</li>
<li>静态成员函数只能访问静态成员变量<h3 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++对象模型和this指针"></a>4.3 C++对象模型和this指针</h3><h4 id="4-3-1-成员变量和成员函数分开存储"><a href="#4-3-1-成员变量和成员函数分开存储" class="headerlink" title="4.3.1 成员变量和成员函数分开存储"></a>4.3.1 成员变量和成员函数分开存储</h4><h4 id="4-2-3-this指针概念"><a href="#4-2-3-this指针概念" class="headerlink" title="4.2.3 this指针概念"></a>4.2.3 this指针概念</h4>this指针指向被调用成员函数所属的对象<br>是隐含在每一个 非静态成员函数 体内的一种指针，不需要定义，直接使用就行，返回对象本身可以用<code>return *this;</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Person(int age)</span><br><span class="line">    &#123;</span><br><span class="line">        //this指针指向的是被调用的成员函数 所属的对象</span><br><span class="line">        this-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //如果这里返回的是Person不是Person&amp;，就会创建一个新的对象</span><br><span class="line">    Person&amp; PersonAddAge(Person &amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;age += p.age;</span><br><span class="line">        </span><br><span class="line">        //this是指向p2的指针，而*this是p2本体</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line">//解决名称冲突</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">    Person p1(18);</span><br><span class="line">    cout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">    Person p1(10);</span><br><span class="line">    Person p2(10);</span><br><span class="line">    //链式编程思想</span><br><span class="line">    p2.PersonAddAge(p1).PersonAddAge(p1).PersonAddAge(p1);</span><br><span class="line">    cout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    test02();</span><br><span class="line">    </span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-3-3-空指针访问成员函数"><a href="#4-3-3-空指针访问成员函数" class="headerlink" title="4.3.3 空指针访问成员函数"></a>4.3.3 空指针访问成员函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//空指针调用成员函数</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void showClassName()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;This is Person class!&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void showPersonAge()</span><br><span class="line">    &#123;</span><br><span class="line">        if (this == NULL)//提高代码的健壮性</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;age = &quot; &lt;&lt; m_Age &lt;&lt; endl;//其实这里的m_Age是this-&gt;m_Age的一种表达形式</span><br><span class="line">    &#125;</span><br><span class="line">    int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">    Person * p = NULL;</span><br><span class="line">    p-&gt;showClassName();</span><br><span class="line">    p-&gt;showPersonAge();</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    test01();</span><br><span class="line">    </span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-3-4-const修饰成员函数"><a href="#4-3-4-const修饰成员函数" class="headerlink" title="4.3.4 const修饰成员函数"></a>4.3.4 const修饰成员函数</h4></li>
</ul>
<p>常函数：</p>
<ul>
<li>成员函数加const后可以称为常函数</li>
<li>长函数类不可修改成员属性</li>
<li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li>
</ul>
<p>常对象：</p>
<ul>
<li>声明对象前加consy称为常对象</li>
<li><p>常对象只能调用常函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //this指针的本质 是指针常量，指针的指向是不可以修改的</span><br><span class="line">    //下面const类似于 const Person * const this;</span><br><span class="line">    //在成员函数后加const，修饰的是this指向，让指针指向的对象包含的成员值也不可修改</span><br><span class="line">    void showPerson() const</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;m_B = 10;</span><br><span class="line">        //this-&gt;m_A = 10;//左值不可修改</span><br><span class="line">        //this = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    void func()</span><br><span class="line">    &#123;</span><br><span class="line">        m_A = 10;</span><br><span class="line">    &#125;</span><br><span class="line">    int m_A;</span><br><span class="line">    mutable int m_B;//特殊变量，在常函数中也可以修改这个值，加关键字mutable</span><br><span class="line">&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line">//常对象</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">    const Person p;//在对象前加上const变为常对象</span><br><span class="line">    //p.m_A = 100;//不可修改</span><br><span class="line">    p.m_B = 100;//m_B是特殊值，在常对象下也可以修改</span><br><span class="line">    //常对象只能调用常函数（const只能调用const）</span><br><span class="line">    p.showPerson();</span><br><span class="line">    //p.func();//常对象不能调用普通成员函数，因为这样就可能修改成员属性了</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    test01();</span><br><span class="line">    </span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-4-友元"><a href="#4-4-友元" class="headerlink" title="4.4 友元"></a>4.4 友元</h3><p>有些私有属性想让类外一些特殊的函数或者类访问<br>三种实现：</p>
</li>
<li><p>全局函数做友元</p>
</li>
<li>类做友元</li>
<li>成员函数做友元<h4 id="4-4-1-全局函数做友元"><a href="#4-4-1-全局函数做友元" class="headerlink" title="4.4.1  全局函数做友元"></a>4.4.1  全局函数做友元</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//建筑物类</span><br><span class="line">class Building</span><br><span class="line">&#123;</span><br><span class="line">    //goodGay全局函数是Building好朋友，可以访问私有成员</span><br><span class="line">    friend void goodGay(Building *building);</span><br><span class="line">public:</span><br><span class="line">    Building()</span><br><span class="line">    &#123;</span><br><span class="line">        m_SittingRoom = &quot;客厅&quot;;</span><br><span class="line">        m_BedRoom = &quot;卧室&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    string m_SittingRoom;</span><br><span class="line">private:</span><br><span class="line">    string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line">void goodGay(Building *building)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;friend is visiting : &quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;friend is visiting : &quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">    Building building;</span><br><span class="line">    goodGay(&amp;building);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    test01();</span><br><span class="line">    </span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-4-2-类做友元"><a href="#4-4-2-类做友元" class="headerlink" title="4.4.2 类做友元"></a>4.4.2 类做友元</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">class Building;</span><br><span class="line">class GoodGay</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    GoodGay();</span><br><span class="line">    void visit();//参观函数，访问Building中的属性</span><br><span class="line">    </span><br><span class="line">    Building * building;</span><br><span class="line">    int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line">class Building</span><br><span class="line">&#123;</span><br><span class="line">    //告诉编译器GoodGay可以访问Building中的私有内容</span><br><span class="line">    friend class GoodGay;</span><br><span class="line">public:</span><br><span class="line">    Building();</span><br><span class="line">    string m_SittingRoom;</span><br><span class="line">private:</span><br><span class="line">    string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line">Building::Building()</span><br><span class="line">&#123;</span><br><span class="line">    m_SittingRoom = &quot;客厅&quot;;</span><br><span class="line">    m_BedRoom = &quot;卧室&quot;;</span><br><span class="line">&#125;</span><br><span class="line">GoodGay::GoodGay()</span><br><span class="line">&#123;</span><br><span class="line">    //创建一个建筑物对象</span><br><span class="line">    building = new Building;</span><br><span class="line">&#125;</span><br><span class="line">void GoodGay::visit()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;friend is visiting : &quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;friend is visiting : &quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">    GoodGay gg;</span><br><span class="line">    gg.visit();</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    test01();</span><br><span class="line">    </span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-4-3成员函数做友元"><a href="#4-4-3成员函数做友元" class="headerlink" title="4.4.3成员函数做友元"></a>4.4.3成员函数做友元</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">class Building;</span><br><span class="line">class GoodGay</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    GoodGay();</span><br><span class="line">    void visit();//参观函数，访问Building中的属性</span><br><span class="line">    void visit2();//不可访问Building中的属性</span><br><span class="line">    </span><br><span class="line">    Building * building;</span><br><span class="line">    int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line">class Building</span><br><span class="line">&#123;</span><br><span class="line">    //告诉编译器GoodGay类中的visit（）可以访问Building中的私有内容</span><br><span class="line">    friend void GoodGay::visit();</span><br><span class="line">public:</span><br><span class="line">    Building();</span><br><span class="line">    string m_SittingRoom;</span><br><span class="line">private:</span><br><span class="line">    string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line">Building::Building()</span><br><span class="line">&#123;</span><br><span class="line">    m_SittingRoom = &quot;客厅&quot;;</span><br><span class="line">    m_BedRoom = &quot;卧室&quot;;</span><br><span class="line">&#125;</span><br><span class="line">GoodGay::GoodGay()</span><br><span class="line">&#123;</span><br><span class="line">    //创建一个建筑物对象</span><br><span class="line">    building = new Building;</span><br><span class="line">&#125;</span><br><span class="line">void GoodGay::visit()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;visit is visiting : &quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;visit is visiting : &quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void GoodGay::visit2()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;visit2 is visiting : &quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    //cout &lt;&lt; &quot;friend is visiting : &quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">    GoodGay gg;</span><br><span class="line">    gg.visit();</span><br><span class="line">    gg.visit2();</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    test01();</span><br><span class="line">    </span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h3>对已有的运算符重新进行定义，赋予另一种功能，以适应不同的数据类型<h4 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载+"></a>4.5.1 加号运算符重载+</h4>实现两个自定义数据类型的相加运算<br>内置的数据类型的表达式是不能改变的<br><strong>不要滥用</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//加号运算符重载</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //1、成员函数实现重载</span><br><span class="line">    // Person operator+(Person &amp;p)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     Person temp;</span><br><span class="line">    //     temp.m_A = this-&gt;m_A + p.m_A;</span><br><span class="line">    //     temp.m_A = this-&gt;m_B + p.m_B;</span><br><span class="line">    //     return temp;</span><br><span class="line">    // &#125;</span><br><span class="line">    int m_A;</span><br><span class="line">    int m_B;</span><br><span class="line">&#125;;</span><br><span class="line">//2、全局函数重载+</span><br><span class="line">Person operator+(Person &amp;p1,Person &amp;p2)</span><br><span class="line">&#123;</span><br><span class="line">    Person temp;</span><br><span class="line">    temp.m_A = p1.m_A + p2.m_A;</span><br><span class="line">    temp.m_A = p1.m_B + p2.m_B;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line">//函数重载版本</span><br><span class="line">Person operator+(Person &amp;p1,int num)</span><br><span class="line">&#123;</span><br><span class="line">    Person temp;</span><br><span class="line">    temp.m_A = p1.m_A + num;</span><br><span class="line">    temp.m_A = p1.m_B + num;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">    Person p1;</span><br><span class="line">    p1.m_A = 10;</span><br><span class="line">    p1.m_B = 10;</span><br><span class="line">    Person p2;</span><br><span class="line">    p2.m_A = 10;</span><br><span class="line">    p2.m_B = 10;</span><br><span class="line">    //成员函数本质调用</span><br><span class="line">    //Person p3 = p1.operator+(p2);</span><br><span class="line">    //全局函数本质调用</span><br><span class="line">    //Person p3 = operator+(p1,p2);</span><br><span class="line">    Person p3 = p1 + p2;</span><br><span class="line">    //运算符重载也可以发生函数重载</span><br><span class="line">    Person p4 = p1 + 100;</span><br><span class="line">    cout &lt;&lt; &quot;p3.m_A = &quot; &lt;&lt; p3.m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;p3.m_A = &quot; &lt;&lt; p3.m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;p4.m_A = &quot; &lt;&lt; p4.m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;p4.m_A = &quot; &lt;&lt; p4.m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    test01();</span><br><span class="line">    </span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-5-2-左移运算符重载-lt-lt"><a href="#4-5-2-左移运算符重载-lt-lt" class="headerlink" title="4.5.2 左移运算符重载&lt;&lt;"></a>4.5.2 左移运算符重载&lt;&lt;</h4><strong>作用</strong> 输出自定义数据类型<br>Person p;<br><strong>cout &lt;&lt; p &lt;&lt; endl;</strong> <strong>怎么定义？</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//左移运算符重载</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    friend ostream &amp; operator&lt;&lt;(ostream &amp;cout, Person &amp;p);</span><br><span class="line">public:</span><br><span class="line">    Person (int a,int b)</span><br><span class="line">    &#123;</span><br><span class="line">        m_A = a;</span><br><span class="line">        m_B = b;</span><br><span class="line">    &#125;</span><br><span class="line">    // //利用成员函数重载 左移运算符 p.operator&lt;&lt;(cout) 简化版本p &lt;&lt; cout</span><br><span class="line">    // //不会利用成员函数重载&lt;&lt;运算符，因为无法实现cout在左侧</span><br><span class="line">    //     void operator&lt;&lt;(cout)</span><br><span class="line">    //     &#123;</span><br><span class="line">    //     &#125;</span><br><span class="line">private:</span><br><span class="line">    int m_A;</span><br><span class="line">    int m_B;</span><br><span class="line">&#125;;</span><br><span class="line">//只能用全局函数重载左移运算符</span><br><span class="line">ostream &amp; operator&lt;&lt;(ostream &amp;cout, Person &amp;p) //本质 opertor&lt;&lt;(cout,p) 简化cout &lt;&lt; p</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;m_A = &quot; &lt;&lt; p.m_A &lt;&lt; &quot; m_B = &quot; &lt;&lt; p.m_B &lt;&lt; endl;</span><br><span class="line">    return cout;</span><br><span class="line">&#125;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">    Person p(10,10);</span><br><span class="line">    // p.m_A = 10;</span><br><span class="line">    // p.m_B = 10;</span><br><span class="line">    cout &lt;&lt; p &lt;&lt; &quot;hello world!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    test01();</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载++"></a>4.5.3 递增运算符重载++</h4><strong>作用：</strong> 通过重载递增运算符，实现自己的整型数据<br><strong>前置递增返回引用，后置递增返回值</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//递增运算符重载</span><br><span class="line">class MyInteger</span><br><span class="line">&#123;</span><br><span class="line">    friend ostream &amp; operator&lt;&lt;(ostream &amp;cout,MyInteger myint);</span><br><span class="line">public:</span><br><span class="line">    MyInteger()</span><br><span class="line">    &#123;</span><br><span class="line">        m_Num = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    //重载前置++运算符</span><br><span class="line">   //为了一直对一个数据进行递增操作</span><br><span class="line">    MyInteger &amp;  operator++()</span><br><span class="line">    &#123;</span><br><span class="line">        m_Num++;</span><br><span class="line">        //将自身返回</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    //重载后置++运算符</span><br><span class="line">    //int代表占位参数，可以用于区分前置和后置</span><br><span class="line">    MyInteger operator++(int)</span><br><span class="line">    &#123;</span><br><span class="line">        //先 记录当时结果</span><br><span class="line">        MyInteger temp = *this;</span><br><span class="line">        //后 递增</span><br><span class="line">        m_Num++;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int m_Num;</span><br><span class="line">&#125;;</span><br><span class="line">//重载&lt;&lt;运算符</span><br><span class="line">ostream &amp; operator&lt;&lt;(ostream &amp;cout,MyInteger myint)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; myint.m_Num;</span><br><span class="line">    return cout;</span><br><span class="line">&#125;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">    MyInteger myint;</span><br><span class="line">    cout &lt;&lt; ++(++myint) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; myint &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">    MyInteger myint;</span><br><span class="line">    cout &lt;&lt; myint++ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; myint &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    test02();</span><br><span class="line">    </span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载="></a>4.5.4 赋值运算符重载=</h4>如果类中有属性指向堆区，做赋值操作是也会出现深浅拷贝问题</li>
</ul>
<h4 id="4-5-5关系运算符重载"><a href="#4-5-5关系运算符重载" class="headerlink" title="4.5.5关系运算符重载 == ,!="></a>4.5.5关系运算符重载 == ,!=</h4><h4 id="4-5-6函数调用运算符重载"><a href="#4-5-6函数调用运算符重载" class="headerlink" title="4.5.6函数调用运算符重载"></a>4.5.6函数调用运算符重载</h4><p>函数调用运算符（）也可以重载</p>
<h3 id="4-6-继承"><a href="#4-6-继承" class="headerlink" title="4.6 继承"></a>4.6 继承</h3><p>继承实现页面<br>减少重复代码<br>语法： class 子类 : 继承方式 父类<br>子类 也称为 派生类<br>父类，也称为 基类<br>公共页面类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//普通实现页面</span><br><span class="line">//Java页面</span><br><span class="line">class BasePage</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void header()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;首页、公开课、登录。。。。（公共头部）&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void footer()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;帮助中心，交流合作，站内地图。。。（公共尾部）&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void left()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Java、python、c++...(公共分类列表)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">// class Python</span><br><span class="line">// &#123;</span><br><span class="line">// public:</span><br><span class="line">//     void header()</span><br><span class="line">//     &#123;</span><br><span class="line">//         cout &lt;&lt; &quot;首页、公开课、登录。。。。（公共头部）&quot; &lt;&lt; endl;</span><br><span class="line">//     &#125;</span><br><span class="line">//     void footer()</span><br><span class="line">//     &#123;</span><br><span class="line">//         cout &lt;&lt; &quot;帮助中心，交流合作，站内地图。。。（公共尾部）&quot; &lt;&lt; endl;</span><br><span class="line">//     &#125;</span><br><span class="line">//     void left()</span><br><span class="line">//     &#123;</span><br><span class="line">//         cout &lt;&lt; &quot;Java、python、c++...(公共分类列表)&quot; &lt;&lt; endl;</span><br><span class="line">//     &#125;</span><br><span class="line">//     void content()</span><br><span class="line">//     &#123;</span><br><span class="line">//         cout &lt;&lt; &quot;Python学科视频&quot;&lt;&lt; endl;</span><br><span class="line">//     &#125;</span><br><span class="line">// &#125;;</span><br><span class="line">// class C</span><br><span class="line">// &#123;</span><br><span class="line">// public:</span><br><span class="line">//     void header()</span><br><span class="line">//     &#123;</span><br><span class="line">//         cout &lt;&lt; &quot;首页、公开课、登录。。。。（公共头部）&quot; &lt;&lt; endl;</span><br><span class="line">//     &#125;</span><br><span class="line">//     void footer()</span><br><span class="line">//     &#123;</span><br><span class="line">//         cout &lt;&lt; &quot;帮助中心，交流合作，站内地图。。。（公共尾部）&quot; &lt;&lt; endl;</span><br><span class="line">//     &#125;</span><br><span class="line">//     void left()</span><br><span class="line">//     &#123;</span><br><span class="line">//         cout &lt;&lt; &quot;Java、python、c++...(公共分类列表)&quot; &lt;&lt; endl;</span><br><span class="line">//     &#125;</span><br><span class="line">//     void content()</span><br><span class="line">//     &#123;</span><br><span class="line">//         cout &lt;&lt; &quot;C++学科视频&quot;&lt;&lt; endl;</span><br><span class="line">//     &#125;</span><br><span class="line">// &#125;;</span><br><span class="line">// 继承实现页面</span><br><span class="line">// 减少重复代码</span><br><span class="line">// 语法： class 子类 : 继承方式 父类</span><br><span class="line">// 子类 也称为 派生类</span><br><span class="line">// 父类，也称为 基类</span><br><span class="line">// 公共页面类</span><br><span class="line">class Java : public BasePage</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void content()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Java学科视频&quot;&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Python : public BasePage</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void content()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Python学科视频&quot;&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class C : public BasePage</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void content()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;C++学科视频&quot;&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Java下载视频页面如下&quot; &lt;&lt; endl;</span><br><span class="line">    Java ja;</span><br><span class="line">    ja.header();</span><br><span class="line">    ja.footer();</span><br><span class="line">    ja.left();</span><br><span class="line">    ja.content();</span><br><span class="line">    cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;Python下载视频页面如下&quot; &lt;&lt; endl;</span><br><span class="line">    Python py;</span><br><span class="line">    py.header();</span><br><span class="line">    py.footer();</span><br><span class="line">    py.left();</span><br><span class="line">    py.content();</span><br><span class="line">    cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;C++下载视频页面如下&quot; &lt;&lt; endl;</span><br><span class="line">    C c;</span><br><span class="line">    c.header();</span><br><span class="line">    c.footer();</span><br><span class="line">    c.left();</span><br><span class="line">    c.content();</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    test01();</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-6-2继承方式"><a href="#4-6-2继承方式" class="headerlink" title="4.6.2继承方式"></a>4.6.2继承方式</h4><p>即从父类继承的东西是子类的什么部分</p>
<ul>
<li>公共继承<br>private里面的子类都继承不到，public和protected都直接继承</li>
<li>保护继承<br>private里面的子类都继承不到，public和protected都继承为子类的protected</li>
<li>私有继承<br>private里面的子类都继承不到，public和protected都继承为子类的private<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Base1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int m_A;</span><br><span class="line">protected:</span><br><span class="line">    int m_B;</span><br><span class="line">private:</span><br><span class="line">    int m_C;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">//公共继承</span><br><span class="line">class Son1 : public Base1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void func()</span><br><span class="line">    &#123;</span><br><span class="line">        m_A = 10;//父类中的public，在子类中为public</span><br><span class="line">        m_B = 10;//父类中的protected,在子类中为protected</span><br><span class="line">        //m_C = 10;//父类中的private 子类访问不到</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//保护继承</span><br><span class="line">class Son2 : protected Base1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void func()</span><br><span class="line">    &#123;</span><br><span class="line">        m_A = 100;//父类中的public，在子类中为protected</span><br><span class="line">        m_B = 100;//父类中的protected,在子类中为protected</span><br><span class="line">        //m_C = 10;//父类中的private 子类访问不到</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//私有继承</span><br><span class="line">class Son3 : private Base1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void func()</span><br><span class="line">    &#123;</span><br><span class="line">        m_A = 100;//父类中的public，在子类中为private</span><br><span class="line">        m_B = 100;//父类中的protected,在子类中为private</span><br><span class="line">        //m_C = 10;//父类中的private 子类访问不到</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-6-3-继承中的对象模型"><a href="#4-6-3-继承中的对象模型" class="headerlink" title="4.6.3 继承中的对象模型"></a>4.6.3 继承中的对象模型</h4></li>
</ul>
<p>利用开发人员命令提示工具查看对象模型</p>
<p><img src="image-20220306131148803-6543510.png" alt="image-20220306131148803"></p>
<p>其实父类中所有的非静态成员属性都会被子类继承，私有成员属性被编译器隐藏了，因此访问不到，但是确实被继承了。</p>
<h4 id="4-6-4-继承中构造和析构顺序"><a href="#4-6-4-继承中构造和析构顺序" class="headerlink" title="4.6.4 继承中构造和析构顺序"></a>4.6.4 继承中构造和析构顺序</h4><p>子类继承父类后，当子类创建对象，也会调用父类的构造函数，到底先调用哪一个？<br>先父类的构造，再子类构造，然后析构子类，再析构父类，一个对应一个，一层一层来。</p>
<h4 id="4-6-5-继承同名成员的处理方式"><a href="#4-6-5-继承同名成员的处理方式" class="headerlink" title="4.6.5 继承同名成员的处理方式"></a>4.6.5 继承同名成员的处理方式</h4><ul>
<li>访问子类同名成员，直接访问就行</li>
<li>访问父类同名成员，需要加作用域<br><img src="image-20220306131211640-6543532.png" alt="image-20220306131211640"><br>子类中出现和父类同名的成员函数，子类成员会屏蔽所有父类的同名函数，如果想访问到被隐藏的，加作用域<br><img src="image-20220306131229790-6543551.png" alt="image-20220306131229790"></li>
</ul>
<h4 id="4-6-6-继承-同名静态成员的处理方式"><a href="#4-6-6-继承-同名静态成员的处理方式" class="headerlink" title="4.6.6 继承 同名静态成员的处理方式"></a>4.6.6 继承 同名静态成员的处理方式</h4><p>同上<br><img src="image-20220306131243461-6543564.png" alt="image-20220306131243461"></p>
<h4 id="4-6-7-继承-多继承语法"><a href="#4-6-7-继承-多继承语法" class="headerlink" title="4.6.7 继承 多继承语法"></a>4.6.7 继承 多继承语法</h4><p>相当于允许一个儿子有多个爹<br><strong>实际开发中不建议用多继承，容易有二义性</strong><br><img src="image-20220306131300369-6543581.png" alt="image-20220306131300369"><br>子类对象的size<br><img src="image-20220306131313569-6543594.png" alt="image-20220306131313569"></p>
<h4 id="4-6-7-继承-菱形继承语法"><a href="#4-6-7-继承-菱形继承语法" class="headerlink" title="4.6.7 继承 菱形继承语法"></a>4.6.7 继承 菱形继承语法</h4><p>两个派生类继承自同一个基类；又有一个子类继承两个派生类<br><img src="image-20220306131331048-6543612.png" alt="image-20220306131331048"><br>解决方案：虚继承<br><img src="image-20220306131342232-6543623.png" alt="image-20220306131342232"><br>这份数据就只有一份了<br>原理：虚继承把原本继承的各个基类的内部的变量值变成vbptr虚基类指针，指向唯一真实值<br><img src="image-20220306131355936-6543636.png" alt="image-20220306131355936"></p>
<h3 id="4-7-多态"><a href="#4-7-多态" class="headerlink" title="4.7 多态"></a>4.7 多态</h3><h4 id="4-7-1-多态的基本概念"><a href="#4-7-1-多态的基本概念" class="headerlink" title="4.7.1 多态的基本概念"></a>4.7.1 多态的基本概念</h4><p><strong>C++面向对象的三大特性之一</strong><br>多态分为两类</p>
<ul>
<li>静态多态：函数重载 运算符重载属于静态多态，服用函数名</li>
<li>动态多态：派生类和虚函数实现运行时多态</li>
</ul>
<p><strong>曲别：</strong></p>
<ul>
<li>静态多态的函数地址早绑定-编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定(虚函数)，运行阶段确定函数地址；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //虚函数</span><br><span class="line">    virtual void speak()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Cat : public Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    void speak()</span><br><span class="line">    &#123;</span><br><span class="line">    cout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Dog : public Animal &#123;</span><br><span class="line">    public:</span><br><span class="line">    </span><br><span class="line">    void speak()</span><br><span class="line">    &#123;</span><br><span class="line">    cout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//父类的引用接受子类的对象</span><br><span class="line">//地址早绑定 在编译阶段确定函数地址</span><br><span class="line">//如果想执行让猫说话，则不能提前绑定地址，地址晚绑定</span><br><span class="line">//满足条件：1、继承关系</span><br><span class="line">//2、子类要重写父类的虚函数（重载是函数名相同，参数不一样）</span><br><span class="line">//重写：函数返回值的类型，参数名称，参数列表完全相同</span><br><span class="line">//动态多态使用</span><br><span class="line">//父类指针或者引用，执行子类对象</span><br><span class="line">void doSpeak(Animal &amp;animal)</span><br><span class="line">&#123;</span><br><span class="line">    animal.speak();</span><br><span class="line">&#125;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">    Cat cat;</span><br><span class="line">    doSpeak(cat);</span><br><span class="line">    Dog dog;</span><br><span class="line">    doSpeak(dog);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    test01();</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>内部这样写，存储的会是虚函数（表）指针</p>
<p><img src="image-20220306131413183-6543654.png" alt="image-20220306131413183"><br>vfptr：virtual function pointer<br>指向一个<br>vftable虚函数表<br>表内部记录虚函数的地址</p>
<p>子类重写的父类虚函数<br>子类中的虚函数表 内部 会替换成 子类重写的虚函数的地址</p>
<p>当父类的指针或引用指向子类对象时，发生多态。<br><img src="image-20220306131432922-6543673.png" alt="image-20220306131432922"></p>
<p>用猫类的虚函数表替换继承自父类的虚函数表<br><img src="image-20220306131444142.png" alt="image-20220306131444142"></p>
<h4 id="4-7-2-多态案例-计算机类"><a href="#4-7-2-多态案例-计算机类" class="headerlink" title="4.7.2 多态案例-计算机类"></a>4.7.2 多态案例-计算机类</h4><p>案例描述：<br>分别利用普通写法和多态技术，设计及实现两个操作数进行运算的计算机类 </p>
<p>如果想扩展新的功能，需求修改源码<br>在真实的开发中，提倡开闭原则<br>对扩展进行开发，对修改进行关闭</p>
<p>多态的好处：</p>
<ol>
<li>组织结构清晰，哪个功能出错了马上就可以定位到</li>
<li>可读性强</li>
<li>前期和后期的扩展和维护性高：如果想扩展新的功能，需求修改源码，在真实的开发中，提倡开闭原则，对扩展进行开发，对修改进行关闭.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Calculator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int getResult(string oper)</span><br><span class="line">    &#123;</span><br><span class="line">        if (oper == &quot;+&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            return m_Num1 + m_Num2;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (oper == &quot;-&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            return m_Num1 - m_Num2;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (oper == &quot;*&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            return m_Num1 * m_Num2;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果想扩展新的功能，需求修改源码</span><br><span class="line">        //在真实的开发中，提倡开闭原则</span><br><span class="line">        //对扩展进行开发，对修改进行关闭</span><br><span class="line">    &#125;</span><br><span class="line">    int m_Num1;</span><br><span class="line">    int m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line">//利用多态实现计算器</span><br><span class="line">//实现计算器抽象类</span><br><span class="line">class AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual int getResult()</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int m_Num1;</span><br><span class="line">    int m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line">//加法计算器类</span><br><span class="line">class AddCalculator : public AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int getResult()</span><br><span class="line">    &#123;</span><br><span class="line">        return m_Num1 + m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//减法计算器类</span><br><span class="line">class SubCalculator : public AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int getResult()</span><br><span class="line">    &#123;</span><br><span class="line">        return m_Num1 - m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//乘法计算器类</span><br><span class="line">class MulCalculator : public AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int getResult()</span><br><span class="line">    &#123;</span><br><span class="line">        return m_Num1 * m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">   Calculator c;</span><br><span class="line">   c.m_Num1 = 10;</span><br><span class="line">   c.m_Num2 = 10;</span><br><span class="line">   cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;+&quot;) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">    //多态使用条件</span><br><span class="line">    //父类指针或者引用指向子类对象</span><br><span class="line">    //加法运算</span><br><span class="line">    AbstractCalculator * abc = new AddCalculator;</span><br><span class="line">    abc-&gt;m_Num1 = 10;</span><br><span class="line">    abc-&gt;m_Num2 = 10;</span><br><span class="line">    cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;</span><br><span class="line">    //用完要销毁，释放空间</span><br><span class="line">    delete abc;</span><br><span class="line">    //把堆区的数据释放了，但是指针的类型没有变</span><br><span class="line">    abc = new SubCalculator;</span><br><span class="line">    abc-&gt;m_Num1 = 10;</span><br><span class="line">    abc-&gt;m_Num2 = 10;</span><br><span class="line">    cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;</span><br><span class="line">    delete abc;</span><br><span class="line">    abc = new MulCalculator;</span><br><span class="line">    abc-&gt;m_Num1 = 10;</span><br><span class="line">    abc-&gt;m_Num2 = 10;</span><br><span class="line">    cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;</span><br><span class="line">    delete abc;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    test02();</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-7-3-纯虚函数和抽象类"><a href="#4-7-3-纯虚函数和抽象类" class="headerlink" title="4.7.3 纯虚函数和抽象类"></a>4.7.3 纯虚函数和抽象类</h4><p>一般在使用多态时，父类虚函数无意义，都是用子类调用，重写内容</p>
<p>因此可以将父类改成 <strong>纯虚函数</strong></p>
<p><code>virtual 返回值类型 函数名 （参数列表）= 0;</code><br>此时这个类称为抽象类</p>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //纯虚函数</span><br><span class="line">    //只要有一个纯虚函数，这个类称为抽象类</span><br><span class="line">    //抽象类特点：</span><br><span class="line">    //1、无法实例化对象</span><br><span class="line">    //2、子类必须重写父类中的纯虚函数，否则也属于抽象类</span><br><span class="line">    virtual void func() = 0;</span><br><span class="line">&#125;;</span><br><span class="line">class Son : public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void func() </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;func&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">    //Base b;   //无法实例化对象</span><br><span class="line">    Base * a = new Son;</span><br><span class="line">    a-&gt;func();</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    test01();</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-7-4-多态案例：制作饮品"><a href="#4-7-4-多态案例：制作饮品" class="headerlink" title="4.7.4 多态案例：制作饮品"></a>4.7.4 多态案例：制作饮品</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//多态案例2 制作饮品</span><br><span class="line">class AbstractDrinking</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Boil() = 0;</span><br><span class="line">    //冲泡</span><br><span class="line">    virtual void Brew() = 0;</span><br><span class="line">    //倒入杯中</span><br><span class="line">    virtual void PourInCup() = 0;</span><br><span class="line">    //导入辅料</span><br><span class="line">    virtual void PutSomething() = 0;</span><br><span class="line">    //制作饮品</span><br><span class="line">    void makeDrink()</span><br><span class="line">    &#123;</span><br><span class="line">        Boil();</span><br><span class="line">        Brew();</span><br><span class="line">        PourInCup();</span><br><span class="line">        PutSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//制作咖啡</span><br><span class="line">class Coffee :public AbstractDrinking</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">    virtual void Boil()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;煮农夫山泉&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //冲泡</span><br><span class="line">    virtual void Brew()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;冲泡咖啡&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //倒入杯中</span><br><span class="line">    virtual void PourInCup()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;倒入杯中&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //导入辅料</span><br><span class="line">    virtual void PutSomething()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;加入糖和牛奶&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//泡茶</span><br><span class="line">class Tea :public AbstractDrinking</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">    virtual void Boil()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;矿泉水&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //冲泡</span><br><span class="line">    virtual void Brew()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;冲泡茶叶&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //倒入杯中</span><br><span class="line">    virtual void PourInCup()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;倒入杯中&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //导入辅料</span><br><span class="line">    virtual void PutSomething()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;不加辅料&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void doWork(AbstractDrinking * abs)</span><br><span class="line">&#123;</span><br><span class="line">    abs-&gt;makeDrink();</span><br><span class="line">    delete abs;</span><br><span class="line">&#125;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">    doWork(new Coffee);</span><br><span class="line">    cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;</span><br><span class="line">    doWork(new Tea);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    test01();</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-7-5-虚析构和纯虚析构"><a href="#4-7-5-虚析构和纯虚析构" class="headerlink" title="4.7.5 虚析构和纯虚析构"></a>4.7.5 虚析构和纯虚析构</h4><p>多态使用时，如果子类中有一些属性放在堆区，父类指针在释放时无法调用子类的析构代码<br><img src="image-20220306131611778-6543772.png" alt="image-20220306131611778"><br>如图，没有调用Cat的析构函数，原因在于用父类指针指向的子类对象，父类指针在析构的时候不会调用子类中的析构函数</p>
<p>解决：将父类中的析构函数改为虚析构或纯虚析构</p>
<p>共性：</p>
<ul>
<li>都可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现<br>区别：</li>
<li>如果是纯虚构，该类属于抽象类，无法实例化对象<br>虚析构语法：<br><code>virtual ~类名（）&#123;&#125;</code><br>纯虚构语法：<br><code>virtual ~类名 （） = 0</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Animal()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Animal构造函数调用&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //纯虚函数</span><br><span class="line">    virtual void speak() = 0;</span><br><span class="line">    //利用虚析构可以解决 父类指针释放子类对象时不干净的问题</span><br><span class="line">    // virtual ~Animal()</span><br><span class="line">    // &#123;</span><br><span class="line">    //     cout &lt;&lt; &quot;Animal虚析构函数调用&quot; &lt;&lt; endl;</span><br><span class="line">    // &#125;</span><br><span class="line">    //纯虚析构 需要声明，也需要实现</span><br><span class="line">    //有了纯虚析构之后，这个类也属于抽象类，无法实例化对象。</span><br><span class="line">    virtual ~Animal() = 0;</span><br><span class="line">&#125;;</span><br><span class="line">Animal::~Animal()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Animal纯虚析构函数调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">class Cat : public Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Cat(string name)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Cat构造函数调用&quot; &lt;&lt; endl;</span><br><span class="line">        m_Name = new string(name);</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void speak()</span><br><span class="line">    &#123;</span><br><span class="line">    cout  &lt;&lt; *m_Name &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Cat()</span><br><span class="line">    &#123;</span><br><span class="line">        if (m_Name != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;Cat析构函数调用&quot; &lt;&lt; endl;</span><br><span class="line">            delete m_Name;</span><br><span class="line">            m_Name = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //创建在堆区，用指针区维护</span><br><span class="line">    string* m_Name;</span><br><span class="line">&#125;;</span><br><span class="line">class Dog : public Animal &#123;</span><br><span class="line">    public:</span><br><span class="line">    </span><br><span class="line">    void speak()</span><br><span class="line">    &#123;</span><br><span class="line">    cout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void doSpeak(Animal &amp;animal)</span><br><span class="line">&#123;</span><br><span class="line">    animal.speak();</span><br><span class="line">&#125;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">    Animal* animal = new Cat(&quot;Tom&quot;);</span><br><span class="line">    animal-&gt;speak();</span><br><span class="line">    delete animal;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    test01();</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/08/GAN%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E6%96%87%E7%8C%AE%E7%AE%80%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="篮球架上打砖块">
      <meta itemprop="description" content="Apodidae">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Upperlan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/08/GAN%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E6%96%87%E7%8C%AE%E7%AE%80%E8%AE%B0/" class="post-title-link" itemprop="url">GAN网络攻击文献简记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-08 13:28:37" itemprop="dateCreated datePublished" datetime="2021-07-08T13:28:37+08:00">2021-07-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-06 14:21:33" itemprop="dateModified" datetime="2022-03-06T14:21:33+08:00">2022-03-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A7%91%E7%A0%94%E4%B8%8E%E8%AE%BA%E6%96%87/" itemprop="url" rel="index"><span itemprop="name">科研与论文</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="恶意域名"><a href="#恶意域名" class="headerlink" title="恶意域名"></a>恶意域名</h2><p>Anderson H S, Woodbridge J, Filar B. <strong>DeepDGA: Adversarially-tuned domain generation and detection</strong>[C]//Proceedings of the 2016 ACM Workshop on Artificial Intelligence and Security. 2016: 13-21.</p>
<p>样本类型：域名字符串</p>
<p>数据集：A域lexa 100万中的访问量靠前的名</p>
<p>问题类型：恶意样本生成问题</p>
<p>方法：Autoencoder组成的GAN</p>
<p>我认为的contribution：提出的框架十分具有创新性，DGA的生成方法也是开创性的，文章写得也挺好，实验很完整</p>
<h2 id="恶意网络流"><a href="#恶意网络流" class="headerlink" title="恶意网络流"></a>恶意网络流</h2><p>潘一鸣,林家骏. 基于生成对抗网络的恶意网络流生成及验证[J]. 华东理工大学学报（自然科学版）,2019,45(2):344-350. DOI:10.14135/j.cnki.1006-3080.20180313003.</p>
<p>样本类型：组数据包序列， 它们具有相同的五元组信息：源 IP 地址、目的 IP 地址、源端口、目的端口、协议类型。将样本转化为 64×64 的二维向量，直接输入 模型。</p>
<p>问题类型：恶意样本生成问题</p>
<p>数据集：UNSW-NB15 数据集，9 种主流的攻击类型（没有良性，是个分类问题）</p>
<p>二进制api数据的缺点：（1）稀疏的特征难以完整反映样本的 特质；（2）二进制的特征向量无法以较小的步长渐变。</p>
<p>方法：利用弱相关位的原理来选择可更改的数据种类，用GAN生成的样本可以是深度学习模型错误分类，同时绕不过基于规则的Snort检测器，即为成功</p>
<p>我认为的contribution：在网络流这个领域提出对抗样本概念，恶意网络流可以直接作为深度学习模型的样本，弱相关位来保持可执行性</p>
<h2 id="僵尸网络检测"><a href="#僵尸网络检测" class="headerlink" title="僵尸网络检测"></a>僵尸网络检测</h2><p>Yin C, Zhu Y, Liu S, et al. <strong>An enhancing framework for botnet detection using generative adversarial networks</strong>[C]//2018 International Conference on Artificial Intelligence and Big Data (ICAIBD). IEEE, 2018: 228-234.</p>
<p>样本类型：预处理将包数据处理成flow数据，包含16种特征的包数据，</p>
<p>问题类型：恶意代码生成问题；机器学习数据集增强</p>
<p>数据集：ISCX botnet dataset created by the University of New Brunswick；normal traffic from ISCX 2012 intrusion detection dataset，其中测试集中有训练集里没有的恶意样本类型</p>
<p>方法：框架中的生成模型不断生成“伪”样本，辅助原始检测模型提高性能。该框架适用于扩充原始检测模型，降低了误报率。</p>
<p>我认为的contribution：在僵尸网络领域使用了GAN，有一定新意，同时用kali</p>
<h2 id="入侵检测"><a href="#入侵检测" class="headerlink" title="入侵检测"></a>入侵检测</h2><p>Usama M, Asim M, Latif S, et al. Generative adversarial networks for launching and thwarting adversarial attacks on network intrusion detection systems[C]//2019 15th international wireless communications &amp; mobile computing conference (IWCMC). IEEE, 2019: 78-83.</p>
<p>样本类型：序列，有41个特征，其中34个是连续值，7个是特征类别的值</p>
<p>数据集：KDD99</p>
<p>问题类型：生成恶意样本绕过机器学习模型</p>
<p>模型：GAN和各种机器学习算法</p>
<p>方法：GAN生成样本绕过IDS；生成的样本投进IDS的训练集，强化IDS</p>
<p>我认为的contribution：对比试验丰富，SVM，LR等，实验复现难度会小一些</p>
<h2 id="恶意代码"><a href="#恶意代码" class="headerlink" title="恶意代码"></a>恶意代码</h2><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>Nataraj L, Karthikeyan S, Jacob G, et al. Malware images: visualization and automatic classification[C]//Proceedings of the 8th international symposium on visualization for cyber security. 2011: 1-7.（已复现）</p>
<p>问题类型：恶意代码预处理；图像分类；</p>
<p>恶意软件类型：window PE</p>
<p>方法：本文首先将恶意二进制代码转变为矩阵，再转变为恶意图像。利用二进制代码长度计算出矩阵的行数和列数，矩阵中每个数值对应一个字节，每个字节范围在00~FF 之间，刚好对应图像的像素范围0~255。然后根据纹理特征分类</p>
<p>我认为的contribution：首先提出把恶意代码图像化的概念，把恶意代码的检测问题转变成一个图像检测问题，打开了新的思路。</p>
<h3 id="1神经网络"><a href="#1神经网络" class="headerlink" title="1神经网络"></a>1神经网络</h3><p>Grosse K, Papernot N, Manoharan P, et al. <strong>Adversarial perturbations against deep neural networks for malware classification</strong>[J]. arXiv preprint arXiv:1606.04435, 2016.(已复现用cnn分类pe软件的image)</p>
<p>恶意软件类型：安卓恶意软件</p>
<p>数据集：DREBIN dataset</p>
<p>问题类型：恶意样本生成问题</p>
<p>方法：api二进制化输入模型，加入扰动</p>
<p>我认为的contribution：实验和分析比较完整</p>
<p>Kolosnjaji B, Demontis A, Biggio B, et al. <strong>Adversarial Malware Binaries: Evading Deep Learning for Malware Detection in Executables</strong>[J]. arXiv preprint arXiv:1803.04173, 2018.</p>
<p>黑/白：白盒</p>
<p>方法：通过目标函数对输入的导数方向选择并在文件末尾增加字节来产生对抗样本</p>
<p>恶意软件类型：Windows PE</p>
<p>数据集：VirusShare、Citadel和APT：19195 malware Popular search engines：4000 benign software</p>
<p>模型：卷积神经网络</p>
<p>Result：60%</p>
<p>我认为的contribution：似乎是第一个攻击Malconv的比较成功的工作，尽管是白盒，但是结果还行</p>
<h3 id="2-GAN"><a href="#2-GAN" class="headerlink" title="2 GAN"></a>2 GAN</h3><p>Kim J Y, Bu S J, Cho S B. <strong>Zero-day malware detection using transferred generative adversarial networks based on deep autoencoders</strong>[J]. Information Sciences, 2018, 460: 83-102.</p>
<p>恶意软件类型：Window PE</p>
<p>方法：1.将恶意代码预处理成RGB三通道的image来处理，保留了较多的特征</p>
<ol>
<li>用autoencoder和GAN结合的tGAN模型，优点是生成器更换了结构之后生成的效果更好了，训练好的判别器通过迁移学习用于零日恶意软件的检测。</li>
</ol>
<p>数据集：微软kaggle malware</p>
<p>我认为的contribution：处理恶意代码image的思路不错，将GAN与恶意代码image结合</p>
<h3 id="3-强化学习"><a href="#3-强化学习" class="headerlink" title="3 强化学习"></a>3 强化学习</h3><p>Anderson H S, Kharkar A, Filar B, et al. <strong>Learning to evade static pe machine learning malware models via reinforcement learning</strong>[J]. arXiv preprint arXiv:1801.08917, 2018.</p>
<p>恶意软件类型：windows PE</p>
<p>数据集：50K randomly selected malware samples from Virus Share,</p>
<p>• 2.6K ransomware samples downloaded from VirusTotal,</p>
<p>• 1.6K Virut samples downloaded from VirusTotal, and</p>
<p>• 4.1K BrowseFox (adware) samples downloaded from Virus-Total.</p>
<p>方法：更通用的基于强化学习的框架来修改已有的恶意PE软件。它可以对于给定的恶意软件样本，尝试不同的操作序列来尝试避开检测器（查杀病毒的机器学习模型）。其主要方法就是改变pe文件中不影响程序运行的部分</p>
<p>我认为的contribution：提出了一种可行的让恶意软件变异的方法，同时不影响恶意软件的运行，关于变异后绕过机器学习检测算法的实验比较全面，但是关于恶意软件运行后是否还具有杀伤性的实验没有做，而且关于如何让这种恶意样本来增强检测模型能力的实验也没有说的很详细。</p>
<h3 id="4-GAN-强化学习"><a href="#4-GAN-强化学习" class="headerlink" title="4 GAN+强化学习"></a>4 GAN+强化学习</h3><p><strong>PESIDIOIUS：Malware Mutation using Reinforcement Learning and GANs（GitHub上的一个模型）</strong></p>
<p>关于以上模型的一个变种，结合了GAN和强化学习。在强化学习对PE文件进行”变异“的过程中需要向PE文件中添加一些内容，比如section table，import list等，这些东西的内容可能会成为机器学习识别算法的一个特征，所以本模型使用GAN去生成一些可以伪造成良性特征的添加内容，再用强化学习进行PE文件修改，从而达到更强的逃避检测能力。</p>
<h2 id="GAN与ML模型安全"><a href="#GAN与ML模型安全" class="headerlink" title="GAN与ML模型安全"></a>GAN与ML模型安全</h2><p>[2018][ICLR]Samangouei P, Kabkab M, Chellappa R. <strong>Defense-gan: Protecting classifiers against adversarial attacks using generative models</strong>[J]. arXiv preprint arXiv:1805.06605, 2018.（有代码）</p>
<p>方法：使用一个GAN模型来减小对抗样本扰动。</p>
<p>前提：所有的恶意样本都是在普通样本上加扰动（perturbation）</p>
<p>大概思路：生成器学会的是随机向量Z到样本空间的一个映射关系G，假设合法样本会在G中一个点的指定范围内，而对抗样本会在这个范围之外，所以，用GAN将样本”投影“（projecting）到G的指定范围内，就可以减少样本的对抗扰动。</p>
<p>防御方法综述：1.对抗训练；2.DEFENSIVE DISTILLATION；3.Magnet：MagNet是对我们的方法最接近的，因为它试图使用一个学习过的自动编码器来改造一个对抗性样本。</p>
<p>数据集：合法的正常样本（本文用的mnist）</p>
<p>模型：WGAN，本文投影（projection）用的GD（梯度下降）</p>
<p>我认为的contribution：一篇引用量600多的文章，传统的方法可能只适用于特定模型，或者黑盒攻击和白盒攻击的一种，而本文的方法都有适用性，可以用于不同的机器学习模型。类似于一种样本投入分类器之前的预处理。实验很完整，白盒和黑盒的实验都做了，可应用的领域很广。</p>
<p>局限性：但是问题在于这个方法的成功非常依靠GAN训练的稳定性，而GAN训练的稳定性问题目前还是一个很重要的研究领域，一个很难解决的问题。</p>
<p>Hu W, Tan Y. <strong>Generating adversarial malware examples for black-box attacks based on GAN</strong>[J]. arXiv preprint arXiv:1702.05983, 2017.</p>
<p>恶意软件类型：Window PE</p>
<p>样本类型：恶意软件的二进制API序列（一个带索引的二进制数组，固定长度，每一个二进制位代表是否使用了某个动态链接库的api，使用了就是1，没使用就是0）</p>
<p>数据集： <a target="_blank" rel="noopener" href="https://malwr.com/：180000">https://malwr.com/：180000</a> samples，30%malware</p>
<p>Result：多组实验达到100%</p>
<p>方法：用自己的机器学习模型去模仿黑盒模型，利用GAN去训练出可以绕过黑盒的样本</p>
<p>我认为的contribution：用自己的模型去模仿黑盒模型。文中开创性提出的GAN结构来实现模仿云上杀软分类器的方法，都很有创新性，实验也很完整，后续很多黑盒实验都使用这个思想去用自己的机器学习模型来“偷取”别人的模型。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/intro/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/intro/">1</a><a class="page-number" href="/intro/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">篮球架上打砖块</p>
  <div class="site-description" itemprop="description">Apodidae</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">篮球架上打砖块</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '[object Object]';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
