<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Apodidae">
<meta property="og:type" content="website">
<meta property="og:title" content="Upperlan">
<meta property="og:url" content="http://example.com/intro/page/2/index.html">
<meta property="og:site_name" content="Upperlan">
<meta property="og:description" content="Apodidae">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="篮球架上打砖块">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/intro/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Upperlan</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Upperlan</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-%E5%85%B3%E4%BA%8E%E5%8F%82%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%90%84%E7%A7%8D%E7%9A%84%E5%90%84%E7%A7%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="篮球架上打砖块">
      <meta itemprop="description" content="Apodidae">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Upperlan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-%E5%85%B3%E4%BA%8E%E5%8F%82%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%90%84%E7%A7%8D%E7%9A%84%E5%90%84%E7%A7%8D/" class="post-title-link" itemprop="url">深度学习基础-关于参数初始化的各种</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-08 20:32:12" itemprop="dateCreated datePublished" datetime="2022-03-08T20:32:12+08:00">2022-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-09 10:37:31" itemprop="dateModified" datetime="2022-03-09T10:37:31+08:00">2022-03-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">深度学习基础知识</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="参数初始化"><a href="#参数初始化" class="headerlink" title="参数初始化"></a>参数初始化</h2><p>目的：让深度学习模型在训练过程中梯度不为零，可能会加快梯度下降的收敛速度，降低训练错误的概率。</p>
<p>为了达到这个目的，初始化需要满足的条件：</p>
<ol>
<li>各层的激活值不会出现饱和迹象。（当输入过大或过小，激活函数的导数几乎为零，即梯度基本为0，称为饱和）</li>
<li>各层的激活值不为0.</li>
<li>尽量使各个层的激活值的方差保持一致。</li>
<li>尽量使各个层对  状态的梯度  的方差保持一致</li>
</ol>
<h2 id="几种初始化方式"><a href="#几种初始化方式" class="headerlink" title="几种初始化方式"></a>几种初始化方式</h2><ol>
<li>预训练模型</li>
<li>随机初始化：使权重分布符合正态分布，在训练深度神经网络时可能会造成梯度消失或者梯度爆炸（网络层数太深，梯度容易一直变大或者一直变小）</li>
<li>xavier初始化：基本思想事保持输入和输出的方差的一致，避免了所有的输出值都趋向于0；</li>
<li>kaiming初始化：何恺明提出的一种针对Relu的初始化方法，思想是在Relu网络中，假设有一半的神经元被激活,另一半为0。保持方差不变，只需要在xavier基础上除以2即可。</li>
</ol>
<h2 id="为什么不能全0初始化"><a href="#为什么不能全0初始化" class="headerlink" title="为什么不能全0初始化"></a>为什么不能全0初始化</h2><p>如果权重是0，那么中间层的输出是输入数据乘权重，就也是0且相等。神经网络计算出来的输出值是一样的，那么神经网络反向传播算法计算出来的梯度也是一样，参数更新值也一样。所以不管再训练多少次，这些隐藏层梯度都是一样，和线性模型就没有区别了。</p>
<h2 id="全部初始化为一样的值"><a href="#全部初始化为一样的值" class="headerlink" title="全部初始化为一样的值"></a>全部初始化为一样的值</h2><p>和上述一样，最后输出对于每一个参数反向传播的梯度都一样，相当于一个线性模型</p>
<h2 id="初始化为小的随机数"><a href="#初始化为小的随机数" class="headerlink" title="初始化为小的随机数"></a>初始化为小的随机数</h2><p>是打破网络对称性的一个普遍的解决办法。神经元一开始的权重值是随机的，所以梯度反向传播时会有不同的更新。看起来初始化的值类似于</p>
<script type="math/tex; mode=display">
\mathbf{w} =0.01 \times np.random.randn(D,H)</script><p><img src="image-20220308213348126-6746429.png" alt="image-20220308213348126"></p>
<p>0.01会试w变小，w很大时会导致神经元输出很大，再通过激活函数后容易梯度消失，饱和。当然如果太小，输出接近激活函数在负方向接近饱和，也容易梯度消失。</p>
<h2 id="预训练"><a href="#预训练" class="headerlink" title="预训练"></a>预训练</h2><p>只谈finetune策略</p>
<ol>
<li>把预训练模型当做权重初始化权重，对整个网络进行完全训练，精度比2高很多。</li>
<li>训练一些层而冻结其他层，一般较低层学习的是通用特征，较高层适用的是逻辑含义更复杂的抽象特征。如果模型很大，数据集不大，会冻结更多层以免过拟合。如果数据很多，模型不大，就可以训练更多层。一般只训练最后的分类层</li>
<li>冻结卷积块，即卷积层，池化层等堆积的一个卷积模块。这种情况适用于训练、冻结平衡的极端情况。</li>
</ol>
<h2 id="为什么深度学习模型难训练"><a href="#为什么深度学习模型难训练" class="headerlink" title="为什么深度学习模型难训练"></a>为什么深度学习模型难训练</h2><p>1.梯度消失</p>
<p>梯度反向传播的过程中越来越小，前面层比后面层学的慢，所以学习会卡住。反向传播过程中前面的层的梯度收到后面所有层的影响，如果梯度值很小，更新信息在传播中指数形式衰减，发生梯度消失。</p>
<p>可能会由：</p>
<p>学习率大小，网络初始化参数，激活函数的边缘效应（饱和）</p>
<p>2.梯度爆炸</p>
<p>梯度也可能在传播中指数增大，导致权重大幅度更新，甚至溢出，变成NaN值，无法更新</p>
<p>3.权重矩阵退化导致模型的有效自由度变小。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/07/%E5%85%B3%E4%BA%8EBatch-Normalization%E7%9A%84%E5%90%84%E7%A7%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="篮球架上打砖块">
      <meta itemprop="description" content="Apodidae">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Upperlan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/%E5%85%B3%E4%BA%8EBatch-Normalization%E7%9A%84%E5%90%84%E7%A7%8D/" class="post-title-link" itemprop="url">深度学习基础-关于Batch Normalization的各种</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-07 20:49:15" itemprop="dateCreated datePublished" datetime="2022-03-07T20:49:15+08:00">2022-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-24 11:40:13" itemprop="dateModified" datetime="2022-03-24T11:40:13+08:00">2022-03-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">深度学习基础知识</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="归一化（Normalization）"><a href="#归一化（Normalization）" class="headerlink" title="归一化（Normalization）"></a>归一化（Normalization）</h1><p>目的：</p>
<ol>
<li>应用层面需要统一量纲</li>
<li>在使用梯度下降发求解最优化问题时，归一化或标准化后可以加快梯度下降的求解速度，即提升收敛速度</li>
<li>可以避免神经元饱和。神经元的激活在0或1时会饱和，这些区域梯度几乎为0，这样的话在反向传播的时候局部梯度也会接近0。因此归一化可以有效缓解梯度消失</li>
<li>避免数据中小的数值被大数值吞噬，也避免数值太大引发的数值问题。（输入图像的值）</li>
</ol>
<h2 id="为什么要归一化"><a href="#为什么要归一化" class="headerlink" title="为什么要归一化"></a>为什么要归一化</h2><p>假设w1在[-10,10],w2在[-100,100]，梯度每次都前进一个单位，则w1在搜索全局最优时会相对来说走的更『快』。即提高了收敛速度</p>
<h2 id="归一化类型"><a href="#归一化类型" class="headerlink" title="归一化类型"></a>归一化类型</h2><h3 id="线性归一化"><a href="#线性归一化" class="headerlink" title="线性归一化"></a>线性归一化</h3><script type="math/tex; mode=display">
x^{'}=\frac{x-min(x)}{max(x)-min(x)}</script><p><img src="image-20220307211017670-6658619.png" alt="image-20220307211017670"></p>
<h2 id="标准归一化"><a href="#标准归一化" class="headerlink" title="标准归一化"></a>标准归一化</h2><script type="math/tex; mode=display">
x^{'}=\frac{x-\mu}{\sigma}</script><p><img src="image-20220307211225372-6658746.png" alt="image-20220307211225372"></p>
<p>归一化后均值为0，标准差为1，$ \mu $ 为左右样本数据的均值，$\sigma$ 是所有样本数据的标准差。</p>
<h1 id="批归一化（Batch-Normalization）"><a href="#批归一化（Batch-Normalization）" class="headerlink" title="批归一化（Batch Normalization）"></a>批归一化（Batch Normalization）</h1><p>在网络中间对数据进行归一化</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>减少对超参数的依赖，某些情况下可以取消Dropout方法或者L2正则项参数</li>
<li>减少对学习率的要求（加强对学习率参数的鲁棒性）</li>
<li>破坏原来的数据分布，一定程度上缓解过拟合，防止每批训练中某一个样本经常被选中</li>
<li>减少梯度消失（数据分布奇怪使激活函数输入接近0或者1，梯度很小）</li>
</ol>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>$x_{i}$是上一层的输出结果，B和Y是学习参数</p>
<ol>
<li>计算上一层输出数据的均值</li>
</ol>
<script type="math/tex; mode=display">
\mu _{\beta}=\frac{1}{m} \sum_{i=1}^{m}\left ( x_{i} \right)</script><p><img src="image-20220307212515863-6659517.png" alt="image-20220307212515863"></p>
<ol>
<li>计算上一层输出数据的标准差<script type="math/tex; mode=display">
\sigma_{\beta}^{2}=\frac{1}{m} \sum_{i=1}^{m}(x_{i}-\mu _{\beta})^{2}</script></li>
</ol>
<p><img src="image-20220307212905080-6659746.png" alt="image-20220307212905080"></p>
<ol>
<li><p>进行归一化处理，得到</p>
<script type="math/tex; mode=display">
x_{i}=\frac{x_{i}+\mu _{\beta}}{\sqrt{\sigma_{\beta}^{2}+\epsilon}}</script><p><img src="image-20220307213044587.png" alt="image-20220307213044587"></p>
<p>分母加一个极小值防止除0</p>
</li>
<li><p>重构</p>
<script type="math/tex; mode=display">
y_{i}=\gamma \hat{x_{i}}+\beta</script><p><img src="image-20220307213242003-6659962.png" alt="image-20220307213242003"></p>
<p>gamma和beta是可学习参数。此时的均值是计算所有批次的mu_{beta}值的平均值得到的，标准差是每个批次的标准差的无偏估计。</p>
</li>
</ol>
<h2 id="和组归一化比较（Group-Normalization）"><a href="#和组归一化比较（Group-Normalization）" class="headerlink" title="和组归一化比较（Group Normalization）"></a>和组归一化比较（Group Normalization）</h2><p>如果batch比较小，导致估计的值和整个数据集的真实均值方差差距较大，BN的误差就会很大。</p>
<p>GN是将通道（channel）分成组，在每组内计算归一化的均值和方差，其准确度在各种批量大小下都很稳定</p>
<h2 id="和权重归一化比较（weight-normalization）"><a href="#和权重归一化比较（weight-normalization）" class="headerlink" title="和权重归一化比较（weight normalization）"></a>和权重归一化比较（weight normalization）</h2><p>WN是对网络权重W进行归一化，适用于RNN，因为RNN处理的队列是变长的，基于时间状态计算，很难保存每个状态下的均值和方差，效率很低。</p>
<h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p> 适用于batch较大，数据分布比较接近的场景，不适用于动态网络和RNN结构。</p>
<h2 id="梯度方向推导"><a href="#梯度方向推导" class="headerlink" title="梯度方向推导"></a>梯度方向推导</h2><p><img src="118059082-39d1a500-b3c2-11eb-80f8-75f2bf677451.png" alt="image"></p>
<p>背诵版本：</p>
<p><img src="118059220-9208a700-b3c2-11eb-841f-73781fa93342.png" alt="image"></p>
<p>训练和测试时的区别：</p>
<p><img src="68747470733a2f2f67697465652e636f6d2f6c6562686f7279692f506963476f506963747572654265642f7261772f6d61737465722f696d672f32303231303830333232353131312e706e67.png" alt="image-20210803225110049"></p>
<h2 id="常用的归一化层"><a href="#常用的归一化层" class="headerlink" title="常用的归一化层"></a>常用的归一化层</h2><p><img src="68747470733a2f2f66696c65732e6d646e6963652e636f6d2f757365722f363933352f37383432636533652d613630662d346333372d623532302d3938383531353337663136642e706e67.png" alt="img"></p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013289254/article/details/99690730">深度学习中的五种归一化（BN、LN、IN、GN和SN）方法简介</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liuxiao214/article/details/81037416">BatchNormalization、LayerNormalization、InstanceNorm、GroupNorm、SwitchableNorm总结</a></p>
</li>
</ul>
<h1 id="BN代码实现，以及多卡训练的sync-bn"><a href="#BN代码实现，以及多卡训练的sync-bn" class="headerlink" title="BN代码实现，以及多卡训练的sync_bn"></a>BN代码实现，以及多卡训练的sync_bn</h1><p>用numpy实现BN：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> module <span class="keyword">import</span> Layers</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BatchNormlization</span>(<span class="title class_ inherited__">Layers</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    https://blog.csdn.net/weixin_44754861/article/details/108343938?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-5.pc_relevant_paycolumn_v3&amp;spm=1001.2101.3001.4242.4&amp;utm_relevant_index=7</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, x,eps =<span class="number">1e-7</span>, momentum =<span class="number">0.9</span>, mode = <span class="string">&quot;train&quot;</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(BatchNormlization).__init__(name)</span><br><span class="line">        self.eps =eps</span><br><span class="line">        self.<span class="built_in">input</span> = x</span><br><span class="line">        n, c, h, w = x.shape</span><br><span class="line">        self.momentum = momentum</span><br><span class="line">        <span class="comment"># 相同batch里不同样本的相同的通道来计算均值和方差</span></span><br><span class="line">        self.running_mean = np.zeros(c)</span><br><span class="line">        self.running_var = np.zeros(c)</span><br><span class="line">        self.gamma = np.random(c)</span><br><span class="line">        self.beta =np.random(c)</span><br><span class="line">        self.mode = mode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_dim</span>(<span class="params">x, dim</span>):</span><br><span class="line">        <span class="keyword">return</span> np.expand_dims(x, axis=dim) <span class="comment"># batch </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self</span>):</span><br><span class="line">        ib, ic, ih, iw = self.<span class="built_in">input</span>.shape</span><br><span class="line"></span><br><span class="line">        self.<span class="built_in">input</span> = self.<span class="built_in">input</span>.transpose(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>).reshape([ic, -<span class="number">1</span>]) <span class="comment"># n,c,h,w -&gt;c, n*h*w</span></span><br><span class="line">        <span class="keyword">if</span> self.mode ==<span class="string">&quot;train&quot;</span>:</span><br><span class="line">            self.var = np.sqrt(self.var +self.eps) <span class="comment"># </span></span><br><span class="line">            self.mean = np.mean(self.<span class="built_in">input</span>, axis=<span class="number">0</span>) <span class="comment"># 每个channel的均值</span></span><br><span class="line">            self.mean = self.add_dim(self.mean, <span class="number">1</span>) <span class="comment"># 与后面的self.input 维度一致</span></span><br><span class="line">            self.var = np.var(self.<span class="built_in">input</span>, axis=<span class="number">0</span>) <span class="comment">#每个channel的方差</span></span><br><span class="line">            self.var = self.add_dim(self.var , <span class="number">1</span>)</span><br><span class="line">            self.gamma = self.add_dim(self.gamma, <span class="number">1</span>)</span><br><span class="line">            self.beta = self.add_dim(self.beta, <span class="number">1</span>)</span><br><span class="line">            self.running_mean = self.momentum * self.running_mean + (<span class="number">1</span>-self.momentum) *self.mean</span><br><span class="line">            self.running_var = self.momentum * self.running_var + (<span class="number">1</span>-self.momentum) *self.var</span><br><span class="line">            self.input_ = (self.<span class="built_in">input</span> -  self.running_mean)/(self.running_var + self.eps)</span><br><span class="line">            dout = (self.input_*self.gamma +self.beta ).reshape(ic,ib, ih, iw).transpose(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">            self.cache = (self.input_, self.gamma, (self.<span class="built_in">input</span> - self.running_mean, self.running_var + self.eps))</span><br><span class="line">        <span class="keyword">elif</span> self.mode ==<span class="string">&quot;test&quot;</span>:</span><br><span class="line">            x_hat = (self.<span class="built_in">input</span> - self.running_mean) / (np.sqrt(self.running_var + self.eps))</span><br><span class="line">            dout = self.gamma * x_hat + self.beta</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Invalid forward batch normlization mode&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> dout, self.cache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self, dout</span>):</span><br><span class="line">        N, D = dout.shape</span><br><span class="line">        x_, gamma, x_minus_mean, var_plus_eps =self.cache</span><br><span class="line"></span><br><span class="line">        <span class="comment"># calculate gradients</span></span><br><span class="line">        dgamma = np.<span class="built_in">sum</span>(x_ * dout, axis=<span class="number">0</span>)</span><br><span class="line">        dbeta = np.<span class="built_in">sum</span>(dout, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        dx_ = np.matmul(np.ones((N,<span class="number">1</span>)), gamma.reshape((<span class="number">1</span>, -<span class="number">1</span>))) * dout</span><br><span class="line">        dx = N * dx_ - np.<span class="built_in">sum</span>(dx_, axis=<span class="number">0</span>) - x_ * np.<span class="built_in">sum</span>(dx_ * x_, axis=<span class="number">0</span>)</span><br><span class="line">        dx *= (<span class="number">1.0</span>/N) / np.sqrt(var_plus_eps)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dx, dgamma, dbeta</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, lr, dgamma, dbeta</span>):</span><br><span class="line">        self.gamma -= dgamma *lr</span><br><span class="line">        self.beta -= dbeta*lr</span><br></pre></td></tr></table></figure>
<p>BN 的性能和 batch size 有很大的关系。batch size 越大，BN 的统计量也会越准。然而像检测这样的任务，占用显存较高，一张显卡往往只能拿较少的图片（比如 2 张）来训练，这就导致 BN 的表现变差。一个解决方式是 SyncBN：所有卡共享同一个 BN，得到全局的统计量。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/337732517">PyTorch 源码解读之 BN &amp; SyncBN：BN 与 多卡同步 BN 详解</a></li>
</ul>
<p>单卡上的 BN 会计算该卡对应输入的均值、方差，然后做 Normalize；SyncBN 则需要得到全局的统计量，也就是“所有卡上的输入”对应的均值、方差。一个简单的想法是分两个步骤：</p>
<ol>
<li>每张卡单独计算其均值，然后做一次同步，得到全局均值</li>
<li>用全局均值去算每张卡对应的方差，然后做一次同步，得到全局方差</li>
</ol>
<p>但两次同步会消耗更多时间，事实上一次同步就可以实现 </p>
<p><img src="v2-98c5ec4adfd6b827e25127af0d0ba988_720w.jpg" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/07/Python%E7%9F%A5%E8%AF%86%E7%82%B9-%E8%A3%85%E9%A5%B0%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="篮球架上打砖块">
      <meta itemprop="description" content="Apodidae">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Upperlan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/Python%E7%9F%A5%E8%AF%86%E7%82%B9-%E8%A3%85%E9%A5%B0%E5%99%A8/" class="post-title-link" itemprop="url">Python知识点-装饰器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-07 19:45:31" itemprop="dateCreated datePublished" datetime="2022-03-07T19:45:31+08:00">2022-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-10 20:03:51" itemprop="dateModified" datetime="2022-03-10T20:03:51+08:00">2022-03-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="实现一个简单的装饰器"><a href="#实现一个简单的装饰器" class="headerlink" title="实现一个简单的装饰器"></a>实现一个简单的装饰器</h3><p>一句话总结：把别装饰的函数替换成新函数，二者接受相同的参数，一般情况下返回被装饰的函数本该返回的值，同时还会做一些额外操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个简单的装饰器，输出函数的运行时间</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clock</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">clocked</span>(<span class="params">*args</span>): <span class="comment">#*args的用法：当传入的参数个数未知，且不需要知道参数名称时。</span></span><br><span class="line">      <span class="comment">#**args的用法：当传入的参数个数未知，但需要知道参数的名称时(立马想到了字典，即键值对)</span></span><br><span class="line">        begin = time.perf_counter() <span class="comment"># 调用func时的时间</span></span><br><span class="line">        result = func(*args) <span class="comment">#运行被装饰函数</span></span><br><span class="line">        elapsed = time.perf_counter() - begin <span class="comment"># 函数运行时间</span></span><br><span class="line">        name = func.__name__ <span class="comment"># 得到被装饰函数名</span></span><br><span class="line">        arg_str = <span class="string">&#x27;,&#x27;</span>.join(<span class="built_in">repr</span>(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args) <span class="comment"># 显示被装饰函数的传入参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[%0.8fs] %s(%s) -&gt; %r&#x27;</span> % (elapsed, name, arg_str, result)) </span><br><span class="line">        <span class="comment"># func运行后，输出格式是[时间] 函数名（传入参数）-&gt; 函数结果</span></span><br><span class="line">        <span class="keyword">return</span> result <span class="comment"># 记得返回结果！</span></span><br><span class="line">    <span class="keyword">return</span> clocked <span class="comment"># 被装饰函数已经被换成了一个新的函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用装饰器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> clockdeco <span class="keyword">import</span> clock <span class="comment"># 直接import</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">snooze</span>(<span class="params">seconds</span>):</span><br><span class="line">    time.sleep(seconds)</span><br><span class="line"></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">factorial</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n*factorial(n-<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span> * <span class="number">40</span>, <span class="string">&#x27;Calling snooze(.123)&#x27;</span>)</span><br><span class="line">snooze(<span class="number">.123</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span> * <span class="number">40</span>, <span class="string">&#x27;Calling factorial(6)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;6! = &#x27;</span>, factorial(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">**************************************** Calling snooze(<span class="number">.123</span>)</span><br><span class="line">[<span class="number">0.12749738</span>s] snooze(<span class="number">0.123</span>) -&gt; <span class="literal">None</span></span><br><span class="line">**************************************** Calling factorial(<span class="number">6</span>)</span><br><span class="line">[<span class="number">0.00000154</span>s] factorial(<span class="number">1</span>) -&gt; <span class="number">1</span></span><br><span class="line">[<span class="number">0.00010962</span>s] factorial(<span class="number">2</span>) -&gt; <span class="number">2</span></span><br><span class="line">[<span class="number">0.00018708</span>s] factorial(<span class="number">3</span>) -&gt; <span class="number">6</span></span><br><span class="line">[<span class="number">0.00026196</span>s] factorial(<span class="number">4</span>) -&gt; <span class="number">24</span></span><br><span class="line">[<span class="number">0.00049425</span>s] factorial(<span class="number">5</span>) -&gt; <span class="number">120</span></span><br><span class="line">[<span class="number">0.00076513</span>s] factorial(<span class="number">6</span>) -&gt; <span class="number">720</span></span><br><span class="line"><span class="number">6</span>! =  <span class="number">720</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<p>但此时如果访问被装饰函数的<code>__name__</code>和<code>__doc__</code>时就被clocked遮盖了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">snooze.__name__</span><br><span class="line"><span class="string">&#x27;clocked&#x27;</span></span><br></pre></td></tr></table></figure>
<p>可以用functools模块中的functools.wraps来构建行为良好的解释器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个简单的装饰器，输出函数的运行时间</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clock</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">clocked</span>(<span class="params">*args, **kwargs</span>): <span class="comment">#*args的用法：当传入的参数个数未知，且不需要知道参数名称时。</span></span><br><span class="line">        <span class="comment">#**args的用法：当传入的参数个数未知，但需要知道参数的名称时(立马想到了字典，即键值对)</span></span><br><span class="line">        begin = time.time() <span class="comment"># 调用func时的时间</span></span><br><span class="line">        result = func(*args, **kwargs) <span class="comment">#运行被装饰函数</span></span><br><span class="line">        elapsed = time.time() - begin <span class="comment"># 函数运行时间</span></span><br><span class="line">        name = func.__name__ <span class="comment"># 得到被装饰函数名</span></span><br><span class="line">        arg_lst = []</span><br><span class="line">        <span class="keyword">if</span> args:</span><br><span class="line">            arg_lst.append(<span class="string">&#x27;,&#x27;</span>.join(<span class="built_in">repr</span>(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args))</span><br><span class="line">        <span class="keyword">if</span> kwargs:</span><br><span class="line">            pairs = [<span class="string">&#x27;%s=%r&#x27;</span> % (k, w) <span class="keyword">for</span> k, w <span class="keyword">in</span> <span class="built_in">sorted</span>(kwargs.items())]</span><br><span class="line">            arg_lst.append(<span class="string">&#x27;,&#x27;</span>.join(pairs))</span><br><span class="line">        arg_str = <span class="string">&#x27;,&#x27;</span>.join(arg_lst) <span class="comment"># 显示被装饰函数的传入参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[%0.8fs] %s(%s) -&gt; %r&#x27;</span> % (elapsed, name, arg_str, result)) </span><br><span class="line">        <span class="comment"># func运行后，输出格式是[时间] 函数名（传入参数）-&gt; 函数结果</span></span><br><span class="line">        <span class="keyword">return</span> result <span class="comment"># 记得返回结果！</span></span><br><span class="line">    <span class="keyword">return</span> clocked <span class="comment"># 被装饰函数已经被换成了一个新的函数</span></span><br></pre></td></tr></table></figure>
<h3 id="叠放装饰器"><a href="#叠放装饰器" class="headerlink" title="叠放装饰器"></a>叠放装饰器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@d1</span></span><br><span class="line"><span class="meta">@d2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;f&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">f() = d1(d2(f))</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/07/Vision-Transformer%E5%A4%84%E7%90%86%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E5%9B%BE%E5%83%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="篮球架上打砖块">
      <meta itemprop="description" content="Apodidae">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Upperlan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/Vision-Transformer%E5%A4%84%E7%90%86%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E5%9B%BE%E5%83%8F/" class="post-title-link" itemprop="url">Vision Transformer处理恶意软件图像</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-07 12:06:39 / 修改时间：20:43:10" itemprop="dateCreated datePublished" datetime="2022-03-07T12:06:39+08:00">2022-03-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A7%91%E7%A0%94%E4%B8%8E%E8%AE%BA%E6%96%87/" itemprop="url" rel="index"><span itemprop="name">科研与论文</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h1><p>将恶意软件的PE十六进制机器码转换成序列，再根据ASCII码表将序列值转化成像素点的数值，最后用多种方法填充成一幅图像，供Vision Transformer模型进行分类。</p>
<h1 id="1-简要前言：转换成图像的意义"><a href="#1-简要前言：转换成图像的意义" class="headerlink" title="1.简要前言：转换成图像的意义"></a>1.简要前言：转换成图像的意义</h1><p>可以利用视觉领域先进的模型与算法，更好的提取PE恶意软件十六进制代码里的特征。</p>
<p><img src="image-20220307121458807-6626500.png" alt="image-20220307121458807"></p>
<p>上图就是我们直接读取可执行PE文件的十六进制代码的结果。最左边一列是这些代码在虚拟内存中的地址，右边是每个地址存储的待执行代码。很明显几乎不可能直观的看出来这些代码的逻辑和操作。而如果用机器学习进行分类，就需要很多关于此类数据的先验知识对这些数据进行特征提取或降维。而深度学习模型的一个特点就是能够找到众多输入数据中所包含的特征，如图像分类问题中，CNN有能力识别到指定图片中目标对象的类别。因此直觉上深度学习模型是处理此类问题十分有效的工具。</p>
<p>而深度学习模型的输入数据一般是统一成一个指定类型的数据。目前图像领域里有很多sota模型可以对图像类数据的特征进行提取，分类，因此如果能让输入数据具备类似图像上的特征，即像素点数据分布的特征，那么就可以利用视觉类深度学习模型来处理恶意软件的分类问题。所以如何将恶意软件进行图像化就是一个很重要的问题了。</p>
<p>使用视觉类DL模型的另外一个原因是恶意软件的序列并不是严格意义上的时间序列，而是包含了丰富的语义特征的序列，就像NLP里单词和单词之间，单词与句子之间的语义一样。用于NLP模型的恶意软件数据集很难构建出来，因为需要大量的可执行文件反汇编，逆向工程的先验知识。因此图像类深度学习模型，或者由NLP领域发展而来的Vision Transformer模型是目前我实验中比较有效的模型。</p>
<h1 id="2-Vision-Transformer特点"><a href="#2-Vision-Transformer特点" class="headerlink" title="2.Vision Transformer特点"></a>2.Vision Transformer特点</h1><p>Vision Transformer模型的特点是和self attention模块的功能高度相关的。从宏观上来说，self-attention layer能够并行输入一个sequence，输出一个sequence，<strong>它的每一个输出都看过了整个的输入sequence，这一点与bi-directional RNN相同。但是神奇的地方是：它的每一个输出都可以并行化计算。</strong></p>
<p><img src="image-20220307134209708-6631731.png" alt="image-20220307134209708"></p>
<p>用CNN，你确实也可以做到输入是一个sequence，输出是另外一个sequence。但是，表面上CNN和Vision Transformer可以做到相同的输入和输出，但是CNN只能考虑非常有限的内容。比如在我们下图中CNN的filter只考虑了3个vector，不像RNN可以考虑之前的所有vector。但是CNN也不是没有办法考虑很长时间的dependency的，你只需要堆叠filter，多堆叠几层，上层的filter就可以考虑比较多的资讯，比如，第二层的filter (蓝色的三角形)看了6个vector，所以，只要叠很多层，就能够看很长时间的资讯。</p>
<p>做CNN的时候是只考虑感受野红框里面的资讯，而不是图片的全局信息。所以CNN可以看作是一种简化版本的self-attention。</p>
<p>或者可以反过来说，self-attention是一种复杂化的CNN，在做CNN的时候是只考虑感受野红框里面的资讯，而感受野的范围和大小是由人决定的。但是self-attention由attention找到相关的pixel，就好像是感受野的范围和大小是自动被学出来的，所以CNN可以看做是self-attention的特例，如图所示。</p>
<p><img src="v2-f28a8b0295863ab78d92a281ae55fce2_720w.jpg" alt="img"></p>
<p><img src="v2-f268035371aa22a350a317fc237a04f7_720w.jpg" alt="img"></p>
<p>既然self-attention是更广义的CNN，则这个模型更加flexible。而我们认为，一个模型越flexible，训练它所需要的数据量就越多，所以在训练self-attention模型时就需要更多的数据，论文 ViT 中有印证，它需要的数据集是有3亿张图片的JFT-300，而如果不使用这么多数据而只使用ImageNet，则性能不如CNN。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/06/Swin-Transformer%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="篮球架上打砖块">
      <meta itemprop="description" content="Apodidae">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Upperlan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/06/Swin-Transformer%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Swin Transformer笔记-Shifted机制与MSA机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-06 16:12:19" itemprop="dateCreated datePublished" datetime="2022-03-06T16:12:19+08:00">2022-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-07 11:07:30" itemprop="dateModified" datetime="2022-03-07T11:07:30+08:00">2022-03-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A7%91%E7%A0%94%E4%B8%8E%E8%AE%BA%E6%96%87/" itemprop="url" rel="index"><span itemprop="name">科研与论文</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文来自：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/367111046">https://zhuanlan.zhihu.com/p/367111046</a></p>
<p>我加上一些代码的注释方便阅读</p>
<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="9da511d843648230e72d5dc78e58a148-6556114.png" alt="9da511d843648230e72d5dc78e58a148"></p>
<p>一共包含4个Stage，每个stage都会缩小输入特征图的分辨率，像CNN一样逐层扩大感受野。框架代码大致如下，省略了一些参数与层的细节。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SwinTransformer</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">...</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># absolute position embedding</span></span><br><span class="line">        <span class="keyword">if</span> self.ape: <span class="comment"># 是否加入位置编码</span></span><br><span class="line">            self.absolute_pos_embed = nn.Parameter(torch.zeros(<span class="number">1</span>, num_patches, embed_dim))</span><br><span class="line">            <span class="comment"># 每个head的shape都是num_patches * embed_dim</span></span><br><span class="line">        self.pos_drop = nn.Dropout(p=drop_rate)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># build layers</span></span><br><span class="line">        self.layers = nn.ModuleList()</span><br><span class="line">        <span class="keyword">for</span> i_layer <span class="keyword">in</span> <span class="built_in">range</span>(self.num_layers):</span><br><span class="line">            layer = BasicLayer(...)</span><br><span class="line">            self.layers.append(layer)</span><br><span class="line"></span><br><span class="line">        self.norm = norm_layer(self.num_features)</span><br><span class="line">        self.avgpool = nn.AdaptiveAvgPool1d(<span class="number">1</span>)</span><br><span class="line">        self.head = nn.Linear(self.num_features, num_classes) <span class="keyword">if</span> num_classes &gt; <span class="number">0</span> <span class="keyword">else</span> nn.Identity()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward_features</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.patch_embed(x) <span class="comment"># 先取得图象块的embeddings</span></span><br><span class="line">        <span class="keyword">if</span> self.ape: <span class="comment"># 位置编码是否需要</span></span><br><span class="line">            x = x + self.absolute_pos_embed</span><br><span class="line">        x = self.pos_drop(x) <span class="comment"># dropout层</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers:</span><br><span class="line">            x = layer(x)</span><br><span class="line"></span><br><span class="line">        x = self.norm(x)  <span class="comment"># B L C</span></span><br><span class="line">        x = self.avgpool(x.transpose(<span class="number">1</span>, <span class="number">2</span>))  <span class="comment"># B C L</span></span><br><span class="line">        x = torch.flatten(x, <span class="number">1</span>) <span class="comment"># 展平</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.forward_features(x)</span><br><span class="line">        x = self.head(x) <span class="comment"># 线性层</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<p>其中有几个地方处理方法与ViT不同：</p>
<ul>
<li>ViT在输入会给embedding进行位置编码。而Swin-T这里则是作为一个<strong>可选项</strong>（<code>self.ape</code>），Swin-T是在计算Attention的时候做了一个<code>相对位置编码</code></li>
<li>ViT会单独加上一个可学习参数，作为分类的token。而Swin-T则是<strong>直接做平均</strong>，输出分类，有点类似CNN最后的全局平均池化层</li>
</ul>
<p>接下来我们看下各个组件的构成</p>
<h2 id="Patch-Embedding"><a href="#Patch-Embedding" class="headerlink" title="Patch Embedding"></a><strong>Patch Embedding</strong></h2><p>在输入进Block前，我们需要将图片切成一个个patch，然后嵌入向量。</p>
<p>具体做法是对原始图片裁成一个个 <code>patch_size * patch_size</code>的窗口大小，然后进行嵌入。</p>
<p>这里可以通过二维卷积层，<strong>将stride，kernelsize设置为patch_size大小</strong>。设定输出通道来确定嵌入向量的大小。最后将H,W维度展开，并移动到第一维度，这里的处理与ViT是一样的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PatchEmbed</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, img_size=<span class="number">224</span>, patch_size=<span class="number">4</span>, in_chans=<span class="number">3</span>, embed_dim=<span class="number">96</span>, norm_layer=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        img_size = to_2tuple(img_size) <span class="comment"># -&gt;  将int类型的size转换成tuple类型数据:(img_size, img_size)</span></span><br><span class="line">        patch_size = to_2tuple(patch_size) <span class="comment"># -&gt; (patch_size, patch_size)</span></span><br><span class="line">        patches_resolution = [img_size[<span class="number">0</span>] // patch_size[<span class="number">0</span>], img_size[<span class="number">1</span>] // patch_size[<span class="number">1</span>]]<span class="comment"># patch的行，列数</span></span><br><span class="line">        self.img_size = img_size</span><br><span class="line">        self.patch_size = patch_size</span><br><span class="line">        self.patches_resolution = patches_resolution</span><br><span class="line">        self.num_patches = patches_resolution[<span class="number">0</span>] * patches_resolution[<span class="number">1</span>] <span class="comment"># 一共多少个patches</span></span><br><span class="line"></span><br><span class="line">        self.in_chans = in_chans <span class="comment"># 输入通道数</span></span><br><span class="line">        self.embed_dim = embed_dim <span class="comment"># 一个嵌入向量的维度，即一个patch的数据展平后通过嵌入层线性映射的目标向量维度</span></span><br><span class="line"></span><br><span class="line">        self.proj = nn.Conv2d(in_chans, embed_dim, kernel_size=patch_size, stride=patch_size) <span class="comment"># 逐行逐个块取线性映射</span></span><br><span class="line">        <span class="keyword">if</span> norm_layer <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: <span class="comment"># layer norm层</span></span><br><span class="line">            self.norm = norm_layer(embed_dim)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.norm = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># 假设采取默认参数</span></span><br><span class="line">        x = self.proj(x) <span class="comment"># 出来的是(N, 96, 224/4, 224/4) </span></span><br><span class="line">        x = torch.flatten(x, <span class="number">2</span>) <span class="comment"># 把HW维展开，(N, 96, 56*56)</span></span><br><span class="line">        x = torch.transpose(x, <span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># 把通道维放到最后 (N, 56*56, 96)</span></span><br><span class="line">        <span class="keyword">if</span> self.norm <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            x = self.norm(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<h2 id="Patch-Merging"><a href="#Patch-Merging" class="headerlink" title="Patch Merging"></a><strong>Patch Merging</strong></h2><p>该模块的作用是在每个Stage开始前做降采样，用于缩小分辨率，调整通道数 进而形成层次化的设计，同时也能节省一定运算量。</p>
<blockquote>
<p>在CNN中，则是在每个Stage开始前用<code>stride=2</code>的卷积/池化层来降低分辨率。</p>
</blockquote>
<p>每次降采样是两倍，因此<strong>在行方向和列方向上，间隔2选取元素</strong>。</p>
<p>然后拼接在一起作为一整个张量，最后展开。<strong>此时通道维度会变成原先的4倍</strong>（因为H,W各缩小2倍），此时再通过一个<strong>全连接层再调整通道维度为原来的两倍</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PatchMerging</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_resolution, dim, norm_layer=nn.LayerNorm</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.input_resolution = input_resolution</span><br><span class="line">        self.dim = dim</span><br><span class="line">        self.reduction = nn.Linear(<span class="number">4</span> * dim, <span class="number">2</span> * dim, bias=<span class="literal">False</span>)</span><br><span class="line">        self.norm = norm_layer(<span class="number">4</span> * dim)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        x: B, H*W, C</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        H, W = self.input_resolution</span><br><span class="line">        B, L, C = x.shape <span class="comment"># L就等于num_patches</span></span><br><span class="line">        <span class="keyword">assert</span> L == H * W, <span class="string">&quot;input feature has wrong size&quot;</span></span><br><span class="line">        <span class="keyword">assert</span> H % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> W % <span class="number">2</span> == <span class="number">0</span>, <span class="string">f&quot;x size (<span class="subst">&#123;H&#125;</span>*<span class="subst">&#123;W&#125;</span>) are not even.&quot;</span></span><br><span class="line"></span><br><span class="line">        x = x.view(B, H, W, C) <span class="comment"># 将特征图再分成按patch为单位，长为W，高为H的形状排列</span></span><br><span class="line">				<span class="comment"># 对原图进行取样，降低image_size</span></span><br><span class="line">        x0 = x[:, <span class="number">0</span>::<span class="number">2</span>, <span class="number">0</span>::<span class="number">2</span>, :]  <span class="comment"># B H/2 W/2 C</span></span><br><span class="line">        x1 = x[:, <span class="number">1</span>::<span class="number">2</span>, <span class="number">0</span>::<span class="number">2</span>, :]  <span class="comment"># B H/2 W/2 C</span></span><br><span class="line">        x2 = x[:, <span class="number">0</span>::<span class="number">2</span>, <span class="number">1</span>::<span class="number">2</span>, :]  <span class="comment"># B H/2 W/2 C</span></span><br><span class="line">        x3 = x[:, <span class="number">1</span>::<span class="number">2</span>, <span class="number">1</span>::<span class="number">2</span>, :]  <span class="comment"># B H/2 W/2 C</span></span><br><span class="line">        x = torch.cat([x0, x1, x2, x3], -<span class="number">1</span>)  <span class="comment"># B H/2 W/2 4*C</span></span><br><span class="line">        x = x.view(B, -<span class="number">1</span>, <span class="number">4</span> * C)  <span class="comment"># B H/2*W/2 4*C size是原来的二分之一，通道数是原来的2倍</span></span><br><span class="line"></span><br><span class="line">        x = self.norm(x)</span><br><span class="line">        x = self.reduction(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<p>下面是一个示意图（输入张量N=1, H=W=8, C=1，不包含最后的全连接层调整）</p>
<p><img src="f26297bb391b288a896c6519b141a19f-6559133.png" alt="f26297bb391b288a896c6519b141a19f"></p>
<p><img src="v2-f9c4e3d69da7508562358f9c3f683c63_1440w.png" alt="img"></p>
<blockquote>
<p>个人感觉这像是PixelShuffle的反操作</p>
</blockquote>
<h2 id="Window-Partition-Reverse"><a href="#Window-Partition-Reverse" class="headerlink" title="Window Partition/Reverse"></a><strong>Window Partition/Reverse</strong></h2><p><code>window partition</code>函数是用于对张量划分窗口，指定窗口大小。将原本的张量从 <code>N H W C</code>, 划分成 <code>num_windows*B, window_size, window_size, C</code>，其中 <code>num_windows = H*W / window_size</code>，即窗口的个数，这里的窗口是由patches为单位组成的。而<code>window reverse</code>函数则是对应的逆过程。这两个函数会在后面的<code>Window Attention</code>用到。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">window_partition</span>(<span class="params">x, window_size</span>):</span><br><span class="line">    B, H, W, C = x.shape</span><br><span class="line">    x = x.view(B, H // window_size, window_size, W // window_size, window_size, C)</span><br><span class="line">    windows = x.permute(<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>).contiguous().view(-<span class="number">1</span>, window_size, window_size, C)</span><br><span class="line">    <span class="keyword">return</span> windows <span class="comment"># (num_windows*B, window_size, window_size, C)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">window_reverse</span>(<span class="params">windows, window_size, H, W</span>):</span><br><span class="line">    B = <span class="built_in">int</span>(windows.shape[<span class="number">0</span>] / (H * W / window_size / window_size))</span><br><span class="line">    x = windows.view(B, H // window_size, W // window_size, window_size, window_size, -<span class="number">1</span>)</span><br><span class="line">    x = x.permute(<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>).contiguous().view(B, H, W, -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<h2 id="Window-Attention"><a href="#Window-Attention" class="headerlink" title="Window Attention"></a><strong>Window Attention</strong></h2><p>这是这篇文章的关键。传统的Transformer都是<strong>基于全局来计算注意力的</strong>，因此计算复杂度十分高。而Swin Transformer则将<strong>注意力的计算限制在每个窗口内</strong>，进而减少了计算量。</p>
<p>我们先简单看下公式</p>
<script type="math/tex; mode=display">
Attention\left ( Q,K,T\right )=Softmax\left ( \frac{QK^{T}}{\sqrt{d}+B}\right )V</script><p><img src="eaff53eb1815f6e3c84d3a7b36783701.png" alt="eaff53eb1815f6e3c84d3a7b36783701"></p>
<p>主要区别是在原始计算Attention的公式中的Q,K时<strong>加入了相对位置编码</strong>。后续实验有证明相对位置编码的加入提升了模型性能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WindowAttention</span>(nn.Module):</span><br><span class="line">    <span class="string">r&quot;&quot;&quot; Window based multi-head self attention (W-MSA) module with relative position bias.</span></span><br><span class="line"><span class="string">    It supports both of shifted and non-shifted window.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        dim (int): Number of input channels.</span></span><br><span class="line"><span class="string">        window_size (tuple[int]): The height and width of the window.(int, int)</span></span><br><span class="line"><span class="string">        num_heads (int): Number of attention heads.</span></span><br><span class="line"><span class="string">        qkv_bias (bool, optional):  If True, add a learnable bias to query, key, value. Default: True</span></span><br><span class="line"><span class="string">        qk_scale (float | None, optional): Override default qk scale of head_dim ** -0.5 if set</span></span><br><span class="line"><span class="string">        attn_drop (float, optional): Dropout ratio of attention weight. Default: 0.0</span></span><br><span class="line"><span class="string">        proj_drop (float, optional): Dropout ratio of output. Default: 0.0</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, dim, window_size, num_heads, qkv_bias=<span class="literal">True</span>, qk_scale=<span class="literal">None</span>, attn_drop=<span class="number">0.</span>, proj_drop=<span class="number">0.</span></span>):</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.dim = dim</span><br><span class="line">        self.window_size = window_size  <span class="comment"># Wh, Ww 和前面的patch size区分</span></span><br><span class="line">        self.num_heads = num_heads <span class="comment"># nH</span></span><br><span class="line">        head_dim = dim // num_heads <span class="comment"># 每个注意力头对应的通道数</span></span><br><span class="line">        self.scale = qk_scale <span class="keyword">or</span> head_dim ** -<span class="number">0.5</span> <span class="comment"># (前面公式的根号d)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># define a parameter table of relative position bias</span></span><br><span class="line">        self.relative_position_bias_table = nn.Parameter(</span><br><span class="line">            torch.zeros((<span class="number">2</span> * window_size[<span class="number">0</span>] - <span class="number">1</span>) * (<span class="number">2</span> * window_size[<span class="number">1</span>] - <span class="number">1</span>), num_heads))  </span><br><span class="line">        <span class="comment"># 设置一个形状为（2*(Wh-1) * 2*(Ww-1), nH）的可学习变量，用于后续的位置编码</span></span><br><span class="line">  </span><br><span class="line">        self.qkv = nn.Linear(dim, dim * <span class="number">3</span>, bias=qkv_bias) <span class="comment"># qkv三个向量的计算综合到一起</span></span><br><span class="line">        self.attn_drop = nn.Dropout(attn_drop)</span><br><span class="line">        self.proj = nn.Linear(dim, dim)</span><br><span class="line">        self.proj_drop = nn.Dropout(proj_drop)</span><br><span class="line"></span><br><span class="line">        trunc_normal_(self.relative_position_bias_table, std=<span class="number">.02</span>)</span><br><span class="line">        self.softmax = nn.Softmax(dim=-<span class="number">1</span>)</span><br><span class="line">     <span class="comment"># 相关位置编码...</span></span><br></pre></td></tr></table></figure>
<p>下面把涉及到相关位置编码的逻辑给单独拿出来，这部分比较绕</p>
<p>首先QK计算出来的Attention张量形状为<code>(numWindows*B, num_heads, window_size*window_size, window_size*window_size)</code>。</p>
<p>我们利用<code>torch.arange</code>和<code>torch.meshgrid</code>函数生成对应的坐标，这里我们以<code>windowsize=2</code>为例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">coords_h = torch.arange(self.window_size[<span class="number">0</span>])</span><br><span class="line">coords_w = torch.arange(self.window_size[<span class="number">1</span>])</span><br><span class="line">coords = torch.meshgrid([coords_h, coords_w]) <span class="comment"># -&gt; 2*(wh, ww)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  (tensor([[0, 0],</span></span><br><span class="line"><span class="string">           [1, 1]]), </span></span><br><span class="line"><span class="string">   tensor([[0, 1],</span></span><br><span class="line"><span class="string">           [0, 1]]))</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>然后堆叠起来，展开为一个二维向量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">coords = torch.stack(coords)  <span class="comment"># 2, Wh, Ww</span></span><br><span class="line">coords_flatten = torch.flatten(coords, <span class="number">1</span>)  <span class="comment"># 2, Wh*Ww</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[0, 0, 1, 1],</span></span><br><span class="line"><span class="string">        [0, 1, 0, 1]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>利用广播（broadcast）机制，分别在第一维，第二维，插入一个维度，进行广播相减，得到 <code>2, wh*ww, wh*ww</code>的张量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">relative_coords_first = coords_flatten[:, :, <span class="literal">None</span>]  <span class="comment"># 2, wh*ww, 1</span></span><br><span class="line">relative_coords_second = coords_flatten[:, <span class="literal">None</span>, :] <span class="comment"># 2, 1, wh*ww</span></span><br><span class="line">relative_coords = relative_coords_first - relative_coords_second <span class="comment"># 最终得到 2, wh*ww, wh*ww 形状的张量</span></span><br></pre></td></tr></table></figure>
<p>因为采取的是相减，所以得到的索引是从负数开始的，<strong>我们加上偏移量，让其从0开始</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">relative_coords = relative_coords.permute(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>).contiguous() <span class="comment"># Wh*Ww, Wh*Ww, 2</span></span><br><span class="line">relative_coords[:, :, <span class="number">0</span>] += self.window_size[<span class="number">0</span>] - <span class="number">1</span></span><br><span class="line">relative_coords[:, :, <span class="number">1</span>] += self.window_size[<span class="number">1</span>] - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>后续我们需要将其展开成一维偏移量。而对于(1，2）和（2，1）这两个坐标。在二维上是不同的，<strong>但是通过将x,y坐标相加转换为一维偏移的时候，他的偏移量是相等的</strong>。</p>
<p><img src="v2-5b1f589ca71a4bc406a266296025b4b4_1440w.jpg" alt="img"></p>
<p>所以最后我们对其中做了个乘法操作，以进行区分</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">relative_coords[:, :, <span class="number">0</span>] *= <span class="number">2</span> * self.window_size[<span class="number">1</span>] - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><img src="v2-0c99206fb39da67bae3415a650c38742_1440w.png" alt="img"></p>
<p>然后再最后一维上进行求和，展开成一个一维坐标，并注册为一个不参与网络学习的变量</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">relative_position_index = relative_coords.sum(-1)  # Wh*Ww, Wh*Ww</span><br><span class="line">self.register_buffer(&quot;relative_position_index&quot;, relative_position_index)</span><br></pre></td></tr></table></figure>
<p>接着我们看前向代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, mask=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        x: input features with shape of (num_windows*B, N, C)</span></span><br><span class="line"><span class="string">        mask: (0/-inf) mask with shape of (num_windows, Wh*Ww, Wh*Ww) or None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    B_, N, C = x.shape</span><br><span class="line">    </span><br><span class="line">    qkv = self.qkv(x).reshape(B_, N, <span class="number">3</span>, self.num_heads, C // self.num_heads).permute(<span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    q, k, v = qkv[<span class="number">0</span>], qkv[<span class="number">1</span>], qkv[<span class="number">2</span>]  <span class="comment"># make torchscript happy (cannot use tensor as tuple)</span></span><br><span class="line"></span><br><span class="line">    q = q * self.scale</span><br><span class="line">    attn = (q @ k.transpose(-<span class="number">2</span>, -<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    relative_position_bias = self.relative_position_bias_table[self.relative_position_index.view(-<span class="number">1</span>)].view(</span><br><span class="line">        self.window_size[<span class="number">0</span>] * self.window_size[<span class="number">1</span>], self.window_size[<span class="number">0</span>] * self.window_size[<span class="number">1</span>], -<span class="number">1</span>)  <span class="comment"># Wh*Ww,Wh*Ww,nH</span></span><br><span class="line">    relative_position_bias = relative_position_bias.permute(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>).contiguous()  <span class="comment"># nH, Wh*Ww, Wh*Ww</span></span><br><span class="line">    attn = attn + relative_position_bias.unsqueeze(<span class="number">0</span>) <span class="comment"># (1, num_heads, windowsize, windowsize)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: <span class="comment"># 下文会分析到</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        attn = self.softmax(attn)</span><br><span class="line"></span><br><span class="line">    attn = self.attn_drop(attn)</span><br><span class="line"></span><br><span class="line">    x = (attn @ v).transpose(<span class="number">1</span>, <span class="number">2</span>).reshape(B_, N, C)</span><br><span class="line">    x = self.proj(x)</span><br><span class="line">    x = self.proj_drop(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<ul>
<li>首先输入张量形状为 <code>numWindows*B, window_size * window_size, C</code>（后续会解释）</li>
<li>然后经过<code>self.qkv</code>这个全连接层后，进行reshape，调整轴的顺序，得到形状为<code>3, numWindows*B, num_heads, window_size*window_size, c//num_heads</code>，并分配给<code>q,k,v</code>。</li>
<li>根据公式，我们对<code>q</code>乘以一个<code>scale</code>缩放系数，然后与<code>k</code>（为了满足矩阵乘要求，需要将最后两个维度调换）进行相乘。得到形状为<code>(numWindows*B, num_heads, window_size*window_size, window_size*window_size)</code>的<code>attn</code>张量</li>
<li>之前我们针对位置编码设置了个形状为<code>(2*window_size-1*2*window_size-1, numHeads)</code>的可学习变量。我们用计算得到的相对编码位置索引<code>self.relative_position_index</code>选取，得到形状为<code>(window_size*window_size, window_size*window_size, numHeads)</code>的编码，加到<code>attn</code>张量上</li>
<li>暂不考虑mask的情况，剩下就是跟transformer一样的softmax，dropout，与<code>V</code>矩阵乘，再经过一层全连接层和dropout</li>
</ul>
<h2 id="Shifted-Window-Attention"><a href="#Shifted-Window-Attention" class="headerlink" title="Shifted Window Attention"></a><strong>Shifted Window Attention</strong></h2><p>前面的Window Attention是在每个窗口下计算注意力的，为了更好的和其他window进行信息交互，Swin Transformer还引入了shifted window操作。</p>
<p><img src="v2-07a98325a29db1da6521e4ddaaed3c88_1440w.jpg" alt="img"></p>
<p>左边是没有重叠的Window Attention，而右边则是将窗口进行移位的Shift Window Attention。可以看到移位后的窗口包含了原本相邻窗口的元素。但这也引入了一个新问题，即<strong>window的个数翻倍了</strong>，由原本四个窗口变成了9个窗口。</p>
<p>在实际代码里，我们是<strong>通过对特征图移位，并给Attention设置mask来间接实现的</strong>。能在<strong>保持原有的window个数下</strong>，最后的计算结果等价。</p>
<p><img src="v2-84b7dd5ba83bf0c686a133dec758d974_1440w.jpg" alt="img"></p>
<h2 id="特征图移位操作"><a href="#特征图移位操作" class="headerlink" title="特征图移位操作"></a><strong>特征图移位操作</strong></h2><p>代码里对特征图移位是通过<code>torch.roll</code>来实现的，下面是示意图</p>
<p><img src="v2-7b594ca54a3cfac5370d8fef2be6f768_1440w.jpg" alt="img"></p>
<blockquote>
<p>如果需要<code>reverse cyclic shift</code>的话只需把参数<code>shifts</code>设置为对应的正数值。</p>
</blockquote>
<h2 id="Attention-Mask"><a href="#Attention-Mask" class="headerlink" title="Attention Mask"></a><strong>Attention Mask</strong></h2><p>我认为这是Swin Transformer的精华，通过设置合理的mask，让<code>Shifted Window Attention</code>在与<code>Window Attention</code>相同的窗口个数下，达到等价的计算结果。</p>
<p>首先我们对Shift Window后的每个窗口都给上index，并且做一个<code>roll</code>操作（window_size=2, shift_size=-1）</p>
<p><img src="v2-d80364e0b73c60bcd8a60bbd91cfbaeb_1440w.jpg" alt="img"></p>
<p>我们希望在计算Attention的时候，<strong>让具有相同index QK进行计算，而忽略不同index QK计算结果</strong>。</p>
<p>最后正确的结果如下图所示</p>
<p><img src="v2-e72bf67b5cbcc27e2d2640bcd3522d0e_1440w.jpg" alt="img"></p>
<p>而要想在原始四个窗口下得到正确的结果，我们就必须给Attention的结果加入一个mask（如上图最右边所示）</p>
<p>相关代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> self.shift_size &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># calculate attention mask for SW-MSA</span></span><br><span class="line">    H, W = self.input_resolution</span><br><span class="line">    img_mask = torch.zeros((<span class="number">1</span>, H, W, <span class="number">1</span>))  <span class="comment"># 1 H W 1</span></span><br><span class="line">    h_slices = (<span class="built_in">slice</span>(<span class="number">0</span>, -self.window_size),</span><br><span class="line">                <span class="built_in">slice</span>(-self.window_size, -self.shift_size),</span><br><span class="line">                <span class="built_in">slice</span>(-self.shift_size, <span class="literal">None</span>))</span><br><span class="line">    w_slices = (<span class="built_in">slice</span>(<span class="number">0</span>, -self.window_size),</span><br><span class="line">                <span class="built_in">slice</span>(-self.window_size, -self.shift_size),</span><br><span class="line">                <span class="built_in">slice</span>(-self.shift_size, <span class="literal">None</span>))</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> h_slices:</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> w_slices:</span><br><span class="line">            img_mask[:, h, w, :] = cnt</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    mask_windows = window_partition(img_mask, self.window_size)  <span class="comment"># nW, window_size, window_size, 1</span></span><br><span class="line">    mask_windows = mask_windows.view(-<span class="number">1</span>, self.window_size * self.window_size)</span><br><span class="line">    attn_mask = mask_windows.unsqueeze(<span class="number">1</span>) - mask_windows.unsqueeze(<span class="number">2</span>)</span><br><span class="line">    attn_mask = attn_mask.masked_fill(attn_mask != <span class="number">0</span>, <span class="built_in">float</span>(-<span class="number">100.0</span>)).masked_fill(attn_mask == <span class="number">0</span>, <span class="built_in">float</span>(<span class="number">0.0</span>))</span><br></pre></td></tr></table></figure>
<p>以上图的设置，我们用这段代码会得到这样的一个mask</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">tensor([[[[[   0.,    0.,    0.,    0.],</span><br><span class="line">           [   0.,    0.,    0.,    0.],</span><br><span class="line">           [   0.,    0.,    0.,    0.],</span><br><span class="line">           [   0.,    0.,    0.,    0.]]],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         [[[   0., -100.,    0., -100.],</span><br><span class="line">           [-100.,    0., -100.,    0.],</span><br><span class="line">           [   0., -100.,    0., -100.],</span><br><span class="line">           [-100.,    0., -100.,    0.]]],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         [[[   0.,    0., -100., -100.],</span><br><span class="line">           [   0.,    0., -100., -100.],</span><br><span class="line">           [-100., -100.,    0.,    0.],</span><br><span class="line">           [-100., -100.,    0.,    0.]]],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         [[[   0., -100., -100., -100.],</span><br><span class="line">           [-100.,    0., -100., -100.],</span><br><span class="line">           [-100., -100.,    0., -100.],</span><br><span class="line">           [-100., -100., -100.,    0.]]]]])</span><br></pre></td></tr></table></figure>
<p>在之前的window attention模块的前向代码里，包含这么一段</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    nW = mask.shape[<span class="number">0</span>]</span><br><span class="line">    attn = attn.view(B_ // nW, nW, self.num_heads, N, N) + mask.unsqueeze(<span class="number">1</span>).unsqueeze(<span class="number">0</span>)</span><br><span class="line">    attn = attn.view(-<span class="number">1</span>, self.num_heads, N, N)</span><br><span class="line">    attn = self.softmax(attn)</span><br></pre></td></tr></table></figure>
<p>将mask加到attention的计算结果，并进行softmax。mask的值设置为-100，softmax后就会忽略掉对应的值</p>
<h2 id="Transformer-Block整体架构"><a href="#Transformer-Block整体架构" class="headerlink" title="Transformer Block整体架构"></a><strong>Transformer Block整体架构</strong></h2><p><img src="v2-b1f64ea254af2c7b1cdbaf9288731371_1440w.jpg" alt="img"></p>
<p>两个连续的Block架构如上图所示，需要注意的是一个Stage包含的Block个数必须是偶数，因为需要交替包含一个含有<code>Window Attention</code>的Layer和含有<code>Shifted Window Attention</code>的Layer。</p>
<p>我们看下Block的前向代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">    H, W = self.input_resolution</span><br><span class="line">    B, L, C = x.shape</span><br><span class="line">    <span class="keyword">assert</span> L == H * W, <span class="string">&quot;input feature has wrong size&quot;</span></span><br><span class="line"></span><br><span class="line">    shortcut = x</span><br><span class="line">    x = self.norm1(x)</span><br><span class="line">    x = x.view(B, H, W, C)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># cyclic shift</span></span><br><span class="line">    <span class="keyword">if</span> self.shift_size &gt; <span class="number">0</span>:</span><br><span class="line">        shifted_x = torch.roll(x, shifts=(-self.shift_size, -self.shift_size), dims=(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        shifted_x = x</span><br><span class="line"></span><br><span class="line">    <span class="comment"># partition windows</span></span><br><span class="line">    x_windows = window_partition(shifted_x, self.window_size)  <span class="comment"># nW*B, window_size, window_size, C</span></span><br><span class="line">    x_windows = x_windows.view(-<span class="number">1</span>, self.window_size * self.window_size, C)  <span class="comment"># nW*B, window_size*window_size, C</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># W-MSA/SW-MSA</span></span><br><span class="line">    attn_windows = self.attn(x_windows, mask=self.attn_mask)  <span class="comment"># nW*B, window_size*window_size, C</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># merge windows</span></span><br><span class="line">    attn_windows = attn_windows.view(-<span class="number">1</span>, self.window_size, self.window_size, C)</span><br><span class="line">    shifted_x = window_reverse(attn_windows, self.window_size, H, W)  <span class="comment"># B H&#x27; W&#x27; C</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># reverse cyclic shift</span></span><br><span class="line">    <span class="keyword">if</span> self.shift_size &gt; <span class="number">0</span>:</span><br><span class="line">        x = torch.roll(shifted_x, shifts=(self.shift_size, self.shift_size), dims=(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x = shifted_x</span><br><span class="line">    x = x.view(B, H * W, C)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># FFN</span></span><br><span class="line">    x = shortcut + self.drop_path(x)</span><br><span class="line">    x = x + self.drop_path(self.mlp(self.norm2(x)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<p>整体流程如下</p>
<ul>
<li>先对特征图进行LayerNorm</li>
<li>通过<code>self.shift_size</code>决定是否需要对特征图进行shift</li>
<li>然后将特征图切成一个个窗口</li>
<li>计算Attention，通过<code>self.attn_mask</code>来区分<code>Window Attention</code>还是<code>Shift Window Attention</code></li>
<li>将各个窗口合并回来</li>
<li>如果之前有做shift操作，此时进行<code>reverse shift</code>，把之前的shift操作恢复</li>
<li>做dropout和残差连接</li>
<li>再通过一层LayerNorm+全连接层，以及dropout和残差连接</li>
</ul>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a><strong>实验结果</strong></h2><p><img src="v2-bf00e048de979decd68ebc7c5372cb27_1440w.jpg" alt="img"></p>
<p>在ImageNet22K数据集上，准确率能达到惊人的86.4%。另外在检测，分割等任务上表现也很优异，感兴趣的可以翻看论文最后的实验部分。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>这篇文章创新点很棒，引入window这一个概念，将CNN的局部性引入，还能控制模型整体计算量。在Shift Window Attention部分，用一个mask和移位操作，很巧妙的实现计算等价。作者的代码也写得十分赏心悦目，推荐阅读！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/06/%E7%A7%91%E7%A0%94%E8%AE%BA%E6%96%87%E4%B9%A6%E5%86%99%E5%B0%8F%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="篮球架上打砖块">
      <meta itemprop="description" content="Apodidae">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Upperlan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/06/%E7%A7%91%E7%A0%94%E8%AE%BA%E6%96%87%E4%B9%A6%E5%86%99%E5%B0%8F%E8%AE%B0/" class="post-title-link" itemprop="url">科研论文书写小记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-06 13:28:37" itemprop="dateCreated datePublished" datetime="2022-03-06T13:28:37+08:00">2022-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-10 20:02:12" itemprop="dateModified" datetime="2022-03-10T20:02:12+08:00">2022-03-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A7%91%E7%A0%94%E4%B8%8E%E8%AE%BA%E6%96%87/" itemprop="url" rel="index"><span itemprop="name">科研与论文</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><p>来源：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/368677897">https://zhuanlan.zhihu.com/p/368677897</a></p>
<p><img src="v2-37eb4b8e53a842758725be0936c9a07e_720w.jpg" alt="img"></p>
<p>（一种很典型的行文方式：把所有工作摊煎饼地摆出来，反正我列出来了，哪个有用你自己找)</p>
<p>“做这个工作的有ABCD, A 做了xxx，B做了xxx，C和D做了xxx” ——类似的句式，<strong>不要再这样写啦</strong>。写相关工作的时候，作者应该是充当一种指路人，或者说书人的角色：在详细介绍核心内容之前，<strong>把故事背景在读者面前慢慢地，有条理地展开</strong>。</p>
<p>所以，你需要把面前的相关文献们，用一条线串起来，来向读者展现它们之间，以及和自己工作之间的关联。这些逻辑可能是递进的：<strong>例如文章ABC开创了某个领域，DEF在这个问题领域提出了集中思路，GHI则是在各个思路下的改进——那么我们就可以先说用总领的话来叙述ABC，然后用并列的方式讲DEF，最后可以一笔带过GHI</strong>（如果它们不是那么重要的话）。</p>
<p>这些逻辑可能是并列的：例如文章ABC用了X技术来解决某个问题，DEF用了Y技术，而GHI则用了DrustZ的技术——那么我们可以使用分条列举的方式，先写”为了解决某个问题，大家采用了不同的方法“，然后列出1）X技术[ABC] 2）Y技术[DEF] 3) DrustZ的技术[GHI] 。这样把类似的文章集中起来，大家看着也顺溜。</p>
<p>还有些其他不怎么常见的逻辑顺序，比如分-总（例如先有零散的工作，后来有一篇文献把它们综合了起来）。但是当我们意识到文献内在的逻辑顺序，并且把它们按照逻辑列举出来的时候，就已经比许多论文的相关文献高出了不止一个档次：）</p>
<p>更加高级的写作方式，则是与其列举文献，更像是让文献为作者自己的陈述服务。你在阅读的过程中，很难感觉到作者在刻意塞进一些文献来充数；相反，作者是在整理自己的思路，顺便引用了关键的文献来加以佐证。</p>
<p>开头不要直接列别人的文章，先概括地说一下这个段落的主题；写完一个小部分，不要立即跳到下一段开始写另一个部分，而是在末尾写一个过渡句：“以上就是人们在X领域的研究，但是随着Y技术的进步，更多的人把目光转移到了Z上”，“对于Y技术在X领域的研究已经介绍许多，但在另一个Z方面，相同的技术也有许多应用”。拿出小学作文满分的本领来！</p>
<p>我老板写Related Work有一个习惯，从来不会在大标题下什么都不写就直接跳到第一个小标题（例如上边那个反例）。在大标题的下面，用一些总领的语言来概括+引出接下来的小章节，其实也是一个很好的过渡方式。一切为了读者服务！</p>
<p><img src="v2-cafd63855ff2e5659ed60614d4280d62_720w.jpg" alt="img"></p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>作者：平海鸥鸣<br>链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/406397855">https://zhuanlan.zhihu.com/p/406397855</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p><strong>将研究成果和研究目的联系起来</strong><br>Simple statistical analysis was used to …<br>The next question asked the informants …<br>To assess X, the Y questionnaire was used.<br>Changes in X and Y were compared using …<br>Regression analysis was used to predict the …<br>To distinguish between these two possibilities, …<br>The first set of analyses examined the impact of … </p>
<p><strong>描述图标中的研究成果</strong><br>As shown in Figure 1,<br>As can be seen from the table (above),<br>From the graph above we can see that<br>It can be seen from the data in Table 1 that </p>
<p>It is apparent from this table that very few …<br>The most interesting aspect of this graph is …<br>In Fig.10 there is a clear trend of decreasing …<br>What is striking about the figures in this table is …<br>What is interesting about the data in this table is that …<br>The differences between X and Y are highlighted in Table 4.<br>From the chart, it can be seen that by far the greatest demand is for …<br>From this data, we can see that Study 2 resulted in the lowest value of … </p>
<p><strong>只是描述研究结果</strong><br><strong>正面的</strong><br>The mean score for X was …<br>Further analysis showed that …<br>Further statistical tests revealed …<br>A two-way ANOVA revealed that …<br>On average, Xs were shown to have …<br>Strong evidence of X was found when …<br>This result is significant at the p = 0.05 level.<br>The results, as shown in Table 1, indicate that …<br>A positive correlation was found between X and Y.<br>There was a significant positive correlation between … </p>
<p><strong>负面的</strong><br>No difference greater than X was observed.<br>No significant differences were found between …<br>None of these differences were statistically significant.<br>No significant difference between the two groups was evident.<br>No significant reduction in X was found compared with placebo.<br>No evidence was found for non-linear associations between X and Y.<br>No significant correlation was found between X scores and the Y scores (p = .274) </p>
<p><strong>将之前的结果（正面的或负面的）——进行简单的现象描述</strong><br>Stimulation of X cells with Y did not increase the …<br>With successive increases in intensity of the X, the Y moved further to …<br>Following the addition of X, a significant increase (<em>P</em>&lt;0.05) in the Y was recorded.<br>When X cells were stimulated with Y, no significant difference in the number of Z was detected. </p>
<p><strong>如果发现有意思的结果</strong></p>
<p>This result is somewhat counterintuitive.<br>Interestingly, this correlation is related to …<br>The more surprising correlation is with the …<br>Surprisingly, only a minority of respondents …<br>The most surprising aspect of the data is in the …<br>The correlation between X and Y is interesting because …<br>The most striking result to emerge from the data is that …<br>Interestingly, there were also differences in the ratios of …<br>The single most striking observation to emerge from the data comparison was … </p>
<p><strong>然后，就开始说我们的对自己研究结果的解释</strong><br>This result may be explained by the fact that …<br>There are, however, other possible explanations.<br>These relationships may partly be explained by …<br>There are several possible explanations for this result.<br>A possible explanation for these results may be the lack of adequate …<br>These differences can be explained in part by the proximity of X and Y. </p>
<p><strong>描述另一个实验结果</strong></p>
<p>A comparison of the two results reveals …<br>Turning now to the experimental evidence on …<br>Comparing the two results, it can be seen that …<br>The next section of the survey was concerned with …<br>In the final part of the survey, respondents were asked … </p>
<p><strong>最后肯定就是对现有研究工作进行的总结</strong></p>
<p>Overall, these results indicate that …<br>In summary, these results show that …<br>In summary, for the informants in this study, …<br>Together these results provide important insights into …<br>Taken together, these results suggest that there is an association between …<br>The results in this chapter indicate that … The next chapter, therefore, moves on to discuss the …</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/06/ATSS%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-Anchor-based%E5%92%8CAnchor-free%E6%A8%A1%E5%9E%8B%E5%85%B3%E9%94%AE%E5%B7%AE%E5%BC%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="篮球架上打砖块">
      <meta itemprop="description" content="Apodidae">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Upperlan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/06/ATSS%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-Anchor-based%E5%92%8CAnchor-free%E6%A8%A1%E5%9E%8B%E5%85%B3%E9%94%AE%E5%B7%AE%E5%BC%82/" class="post-title-link" itemprop="url">ATSS论文笔记:Anchor-based和Anchor-free模型关键差异</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-06 11:42:13 / 修改时间：11:58:22" itemprop="dateCreated datePublished" datetime="2022-03-06T11:42:13+08:00">2022-03-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/" itemprop="url" rel="index"><span itemprop="name">目标检测</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>论文: Bridging the Gap Between Anchor-based and Anchor-free Detection via Adaptive Training Sample Selection</p>
<p>简述：论文指出one-stage anchor-based和center-based anchor-free检测算法间的差异主要来自于正负样本的选择，基于此提出ATSS(Adaptive Training Sample Selection)方法，该方法能够<strong>自动根据GT的相关统计特征选择合适的anchor box作为正样本</strong>，在<strong>不带来额外计算量和参数</strong>的情况下，能够大幅提升模型的性能，十分有用。</p>
<p>背景：RetinaNet是一个anchor-based检测模型，FCOS是一个anchor-free检测模型，两者有三点不同：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>RetinaNet</th>
<th>FCOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.每个位置的anchor数</td>
<td>RetinaNet每个grid cell有几个anchor box</td>
<td>FCOS每个位置只根据一个anchor point来回归bbox</td>
</tr>
<tr>
<td>2.正负样本的定义不同</td>
<td>根据IoU来区分正副样本</td>
<td>根据选择样本的空间和规模限制（即gt框中心周围的一部分区域的点作为正样本。）</td>
</tr>
<tr>
<td>3.回归的对象不同</td>
<td>回归anchor box的偏移值</td>
<td>回归点到bbox四条边的距离</td>
</tr>
</tbody>
</table>
</div>
<p>实验中FCOS比RetinaNet的效果要好</p>
<p>实验：论文选取<strong>anchor-based方法RetinaNet</strong>和<strong>anchor-free方法FCOS</strong>进行对比，主要对比正负样本定义和回归开始状态的差异，将RetinaNet的anchor数改为1降低差异性，方便与FCOS比较，后续会测试anchor数带来的作用。</p>
<p>首先将FCOS上有的tricks加在RetinaNet上</p>
<p><img src="image-20220306115011025-6538616.png" alt="image-20220306115011025"></p>
<p>现在FCOS和RetinaNet只有两个不同：</p>
<p>1.正负样本的分配</p>
<p>2.回归对象的不同</p>
<p>而此时FCOS比RetinaNet高0.8个点，所以再验证这两个不同的影响：</p>
<p><img src="image2022-2-11_16-10-11.png" alt="image2022-2-11_16-10-11"></p>
<p>又上图得RetinaNet将IoU阈值分配正负样本（与yolov3相同）换成点和区域分配正负样本时，涨点了，而FCOS使用IoU阈值时反而掉点了</p>
<p>后续实验验证回归对象的时候发现对象不同几乎不影响mAP。</p>
<p>因此作者得出结论：</p>
<p>FCOS的表现比RetinaNet要好主要是因为FCOS的正负样本分配策略更好。</p>
<p>因此对于anchor-based模型，为了消除anchor超参数的影响，提出</p>
<p><strong>Adaptive Training Sample Selection (ATSS)</strong></p>
<p>自动根据物体的统计特征划分正负样本，几乎没有任何超参数。</p>
<p><img src="image-20220306115249710-6538771.png" alt="image-20220306115249710"></p>
<p>先选出每一层的所有预测框中与真实框L2距离最小的k个预测框，计算这些预测框与每一个gt框的IoU，统计这些IoU值的均值m和均方差v，则IoU阈值t=m+v。如果一个预测框与某个gt框的阈值大于t，则为正样本，否则为负样本。</p>
<p>m：为了有合适数目的正样本，如果m很大，说明有许多高质量的预测框，则IoU阈值应该更大；如果m比较小，说明预测框的质量不太好，IoU阈值应该更小</p>
<p>v：如果v较小，说明有几个特征层都适合完成当前的检测任务，所以m+v的值更小，则选取更多正样本；如果v较大，则说明有某些特定的特征层更适合完成当前目标的检测任务，所以IoU阈值更大，来选取更合适的特征层上的检测框</p>
<p>根据统计学理论，IoU值在阈值t以上的预测框大概在16%左右，每个目标物体大概会分配 （0.2 <em> k </em> 特征层数 ）个正样本。该方法只引入了一个超参数k，而且k对结果的影响并不大，一般设置为9，因此本算法可以近似看做不增加超参数。</p>
<p><img src="image-20220306115325575-6538806.png" alt="image-20220306115325575"></p>
<ul>
<li>将RetinaNet中的正负样本替换为ATSS，AP提升了2.9%，这样的性能提升几乎是没有任何额外消耗的</li>
<li>在FCOS上的应用主要用两种：lite版本采用ATSS的思想，从选取GT内的anchor point改为选取每层离GT最近的top $k$个候选anchor point，提升了0.8%AP；full版本将FCOS的anchor point改为长宽为$8S$的anchor box来根据ATSS选择正负样本，但仍然使用原始的回归方法，提升了1.4%AP。两种方法找到的anchor point在空间位置上大致相同，但是在FPN层上的选择不太一样。从结果来看，自适应的选择方法比固定的方法更有效</li>
</ul>
<p>这里的RetinaNet只用了一个anchor box，如果使用多个anchor box，结果如下：</p>
<p><img src="image-20220306115542160-6538944.png" alt="image-20220306115542160"></p>
<p>Imprs为用在了FCOS中的提升手段。从结果来看，在每个位置设定多个anchor box是无用的操作，关键在于选择合适的正样本</p>
<p>论文结论：</p>
<p>1.这两种方法之间的本质区别是<strong>正负训练样本的选择</strong>，这导致了它们之间的性能差距。如果他们在训练期间选择相同的正负样本，无论是回归anchor bbox或anchor point，最终表现都没有明显的差距。</p>
<p>2.通过一系列实验，可以得出结论，没有必要在图像上每个位置设置多个anchor box来检测物体。</p>
<p>3.相同的主干网络下，ATSS方法能够大幅增加准确率，十分有效</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/05/docker%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="篮球架上打砖块">
      <meta itemprop="description" content="Apodidae">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Upperlan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/05/docker%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">docker常用操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-05 22:18:54 / 修改时间：22:20:25" itemprop="dateCreated datePublished" datetime="2022-03-05T22:18:54+08:00">2022-03-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E4%BD%9C%E5%B8%B8%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">工作常用</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="docker操作"><a href="#docker操作" class="headerlink" title="docker操作"></a>docker操作</h1><h2 id="docker基本命令"><a href="#docker基本命令" class="headerlink" title="docker基本命令"></a>docker基本命令</h2><ul>
<li>查看容器镜像列表 docker images</li>
<li>查看当前所有正在运行的容器 docker ps  (查看所有容器，包括运行和停止的。t)<h4 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h4></li>
<li>将网上或者别的服务器上的docker镜像拉到本地。例如： docker pull uber/horovod:0.15.1-tf1.11.0-torch0.4.1-py3.</li>
</ul>
<h4 id="docker-push"><a href="#docker-push" class="headerlink" title="docker push"></a>docker push</h4><ul>
<li><p>上传docker镜像(注意上传镜像统一格式，yq01-aip-m12-tianzhi14.yq01.baidu.com/[Name]:tagls<br>$ docker push yq01-aip-m12-tianzhi14.yq01.baidu.com/lvhaijun/tsm_horovod:0.15.0-tf1.11.0-torch0.4.1-py2.7</p>
</li>
<li><p>建立一个带gpu驱动的容器：</p>
</li>
<li>nvidia-docker run -e PASSWORD=tianzhi05 —network=host —shm-size=32g —name=haijunlv -v /home/ssd1/lvhaijun:/home/lvhaijun -it haijun_tf1.11_torch0.4_py2.7:latest /bin/bash 注意建立容器时请一定将—name 带上，用以区分创建者。无名字的/默认名字的，如果容器在被杀掉概不负责</li>
</ul>
<p>-e：设置环境变量<br>—network：将容器联网<br>—shm-size：/dev/shm/的大小（共享内存）<br>—name：给容器命名<br>-v：将宿主机目录挂载进docker，冒号左边是Host的路径，右边是容器内的路径<br>-it：指示Docker分配连接到容器的伪TTY<br>-p: 指定端口映射，格式为：主机(宿主)端口:容器端口<br>最后是镜像名称:镜像版本</p>
<p>$docker run —runtime=nvidia —shm-size=32g —name=dingzhenkai -p 8017:8017 -v /home/dingzhenkai:/home/dingzhenkai -it registry.baidubce.com/rudder/train_basic/paddle2.1.2-gpu-cuda10.1-cudnn7:basic /bin/bash</p>
<p>注意建立容器时请一定将—name 带上，用以区分创建者。</p>
<ul>
<li><p>退出容器： exit （杀死该容器进程） Control + p+ q (不kill 进程， 只退出当前容器，高频使用)</p>
</li>
<li><p>重新进行一个运行中的容器 docker attach CONTAINER_ID</p>
</li>
<li>从容器进程中创建一个容器进程(某进程死机后可用此方法再创建进程，查看死机进程状况) docker exec -it CONTAINER_ID bash</li>
<li>重新启动一个停止的容器 docker start CONTAINER_ID</li>
<li>docker 容器删除 docker container rm CONTAINER_ID </li>
<li>docker 镜像删除 docker image rm IMAGE_ID</li>
<li>docker rename 重命名</li>
<li>docker exec —privileged -u root -it container-id bash root权限进入容器</li>
<li>docker system df -v 查看容器占用空间</li>
<li>批量静止容器删除 #删除所有未运行的容器（已经运行的删除不了，未运行的就一起被删除了） sudo docker rm $(sudo docker ps -a -q)</li>
<li>docker 服务重启 service docker restart</li>
<li>docker 容器保存成镜像 doker commit <container_id> new_image_name:tag</li>
<li>镜像保存到本地 docker save image_name -o 本地路径/—.tar</li>
<li>镜像从本地加载 docker load -i 本地路径/—.tar</li>
<li>Dead 容器删除:<br>$ docker rm $(docker ps —all -q -f status=dead)</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/05/tmux%E4%BD%BF%E7%94%A8%E7%AE%80%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="篮球架上打砖块">
      <meta itemprop="description" content="Apodidae">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Upperlan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/05/tmux%E4%BD%BF%E7%94%A8%E7%AE%80%E8%BF%B0/" class="post-title-link" itemprop="url">tmux使用简述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-05 22:16:44" itemprop="dateCreated datePublished" datetime="2022-03-05T22:16:44+08:00">2022-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-08 17:11:51" itemprop="dateModified" datetime="2022-03-08T17:11:51+08:00">2022-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E4%BD%9C%E5%B8%B8%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">工作常用</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称”窗口”），在里面输入命令。用户与计算机的这种临时的交互，称为一次”会话”（session） 。</p>
<p>会话的一个重要特点是，窗口与其中启动的进程是连在一起的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。</p>
<p>一个典型的例子就是，SSH 登录远程计算机，打开一个远程窗口执行命令。这时，网络突然断线，再次登录的时候，是找不回上一次执行的命令的。因为上一次 SSH 会话已经终止了，里面的进程也随之消失了。</p>
<p>为了解决这个问题，会话与窗口可以”解绑”：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话”绑定”其他窗口。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>（1）它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。</p>
<p>（2） 它可以让新窗口”接入”已经存在的会话。</p>
<p>（3）它允许每个会话有多个连接窗口，因此可以多人实时共享会话。</p>
<p>（4）它还支持窗口任意的垂直和水平拆分。</p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>键入tmux命令，就进入了 Tmux 窗口。<br>按下ctrl+d或者输入exit可以退出</p>
<h4 id="前缀键"><a href="#前缀键" class="headerlink" title="前缀键"></a>前缀键</h4><p>Tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是Ctrl+b，即先按下Ctrl+b，快捷键才会生效。</p>
<p>举例来说，帮助命令的快捷键是Ctrl+b ?。它的用法是，在 Tmux 窗口中，先按下Ctrl+b，再按下?，就会显示帮助信息。</p>
<p>然后，按下 ESC 键或q键，就可以退出帮助。</p>
<h4 id="新建会话"><a href="#新建会话" class="headerlink" title="新建会话"></a>新建会话</h4><p>第一个启动的 Tmux 窗口，编号是0，第二个窗口的编号是1，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。</p>
<p>使用编号区分会话，不太直观，更好的方法是为会话起名。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">tmux new -s &lt;session-name&gt;</span> </span><br></pre></td></tr></table></figure></p>
<h4 id="分离会话"><a href="#分离会话" class="headerlink" title="分离会话"></a>分离会话</h4><p>在 Tmux 窗口中，按下Ctrl+b d或者输入tmux detach命令，就会将当前会话与窗口分离。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">tmux detach</span></span><br></pre></td></tr></table></figure>
<p>上面命令执行后，就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行。</p>
<p><code>tmux ls</code>命令可以查看当前所有的 Tmux 会话。</p>
<h4 id="接入会话"><a href="#接入会话" class="headerlink" title="接入会话"></a>接入会话</h4><p>tmux attach命令用于重新接入某个已存在的会话。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">使用会话编号</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">tmux attach -t 0</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">使用会话名称</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">tmux attach -t &lt;session-name&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="杀死会话"><a href="#杀死会话" class="headerlink" title="杀死会话"></a>杀死会话</h4><p><code>tmux kill-session</code>命令用于杀死某个会话。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">使用会话编号</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">tmux kill-session -t 0</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">使用会话名称</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">tmux kill-session -t &lt;session-name&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="切换会话"><a href="#切换会话" class="headerlink" title="切换会话"></a>切换会话</h4><p><code>tmux switch</code>命令用于切换会话。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">使用会话编号</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">tmux switch -t 0</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">使用会话名称</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">tmux switch -t &lt;session-name&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="重命名会话"><a href="#重命名会话" class="headerlink" title="重命名会话"></a>重命名会话</h4><p><code>tmux rename-session</code>命令用于重命名会话。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">tmux rename-session -t 0 &lt;new-name&gt;</span></span><br><span class="line">上面命令将0号会话重命名。</span><br></pre></td></tr></table></figure>
<h4 id="会话快捷键"><a href="#会话快捷键" class="headerlink" title="会话快捷键"></a>会话快捷键</h4><p>下面是一些会话相关的快捷键。</p>
<p>Ctrl+b d：分离当前会话。<br>Ctrl+b s：列出所有会话。<br>Ctrl+b $：重命名当前会话。</p>
<h3 id="tmux-的窗格常用操作"><a href="#tmux-的窗格常用操作" class="headerlink" title="tmux 的窗格常用操作"></a>tmux 的窗格常用操作</h3><p>我一直认为使用 tmux 中的窗格是一件很酷的事情，很多人喜欢 tmux 也是因为窗格功能的存在。</p>
<p>什么是窗格（pane）呢？</p>
<p>前文也提到过，这里在详细描述一下：当前我们的工作区域，一块工作屏幕我们叫做窗口，窗口是可以被分割的，当前的工作区域被分割的一块块区域就是窗格。</p>
<p>每一个窗格我们可以用来干不同的事情，窗格同窗格之间是相互独立的，可以想象我们使用 vim 来搭配 tmux 的窗格功能是不是很酷呢？</p>
<p><strong>切割窗格</strong></p>
<p>切割窗格的命令是：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux split-window </span><br></pre></td></tr></table></figure>
<p>该命令会把当前工作区域分成上下两个小窗格</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux split-window -h</span><br></pre></td></tr></table></figure>
<p>该命令会把当前工作区域分成左右两个窗格</p>
<p>切割窗格的快捷键 <strong>ctrl + b %</strong> 可以快速的左右切割，<strong>ctrl + b “</strong> 可以快速的上下进行切割。</p>
<p><strong>不同窗格间移动光标</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux select-pane  -U</span><br></pre></td></tr></table></figure>
<p>把当前光标移动到上方的窗格</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux select-pane -D</span><br></pre></td></tr></table></figure>
<p>把当前的光标移动的下方的窗格</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux select-pane -L</span><br></pre></td></tr></table></figure>
<p>把当前的光标移动到左边的窗格</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux select-pane -R</span><br></pre></td></tr></table></figure>
<p>把当前的光标移动到右边的窗格</p>
<p>移动窗格光标的快捷键：</p>
<p><strong>ctrl +b <arrow key></strong>例如 ctrl +b ⬆ 会把光标移动到上方的窗格。</p>
<p><strong>ctrl +b ;</strong>光标切换到上一个窗格</p>
<p><strong>ctrl +b o</strong> 光标切换到下一个窗格</p>
<p><strong>交换窗格的位置</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux swap-pane -U</span><br></pre></td></tr></table></figure>
<p>当前窗格向上移动</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux swap-pane -D</span><br></pre></td></tr></table></figure>
<p>当前窗格向下移动</p>
<p><strong>关闭当前的窗格</strong></p>
<p>关闭窗格通常使用快捷键 <strong>ctrl + b x</strong></p>
<p><strong>放大窗格</strong></p>
<p>快捷键 <strong>ctrl + b z</strong> ,将会放大当前操作的窗格，继续触发该快捷键将会还原当前的窗格。</p>
<p><strong>窗格显示时间</strong></p>
<p>快捷键 <strong>ctrl +b t</strong> 将会把在当前的窗格当中显示时钟，非常酷炫的一个功能，点击 enter (回车键将会复原)。</p>
<p><strong>窗格总结</strong></p>
<p>关于窗格的操作我们经常操作的就是分割，移动光标，放大窗格，关闭窗格，可以熟练以上提到的操作，关于移动光标的快捷键操作，下文在 .tmux.conf 中也会处理成快捷键进行操作。</p>
<h4 id="进入tmux翻屏模式"><a href="#进入tmux翻屏模式" class="headerlink" title="进入tmux翻屏模式"></a>进入tmux翻屏模式</h4><p>Crtl+b，松开 按 [ 进入翻屏模式，PgUp和PgDn实现上下翻页。退出按q</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/10/%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E7%AF%AE%E7%90%83%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="篮球架上打砖块">
      <meta itemprop="description" content="Apodidae">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Upperlan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/10/%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92-%E7%AF%AE%E7%90%83%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">训练计划-篮球技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-10 14:35:17" itemprop="dateCreated datePublished" datetime="2022-01-10T14:35:17+08:00">2022-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-06 13:44:39" itemprop="dateModified" datetime="2022-03-06T13:44:39+08:00">2022-03-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%94%B7%E5%A3%AB%E4%BC%91%E9%97%B2/" itemprop="url" rel="index"><span itemprop="name">男士休闲</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一-Elite"><a href="#一-Elite" class="headerlink" title="一. Elite"></a>一. Elite</h2><p>原地普通运球 左右手各50<br>原地V字运球 左右手各50<br>原地普通运球+体前变向 30<br>原地普通运球+胯下 30<br>小幅度变向 50<br>背后运球 50<br>原地胯下背后Combo 左右侧各 15<br>原地胯下体前Combo 左右侧各 20<br>原地连续剪刀胯下 50<br>原地体前+胯下+背后 50<br>胯下体前胯下背后 左右各50</p>
<ul>
<li><strong>运球一定要使劲儿！用全力！</strong></li>
<li><strong>不要怕丢！大家都会有失误很正常，追求完美，努力克服自己、克服困难！</strong></li>
<li><strong>做不了的动作 就努力尝试！老去尝试 去挑战自然而然就会了！</strong></li>
<li><strong>运球注意抬头！Eyes Up！</strong></li>
<li><strong>压低重心，屈膝</strong>！</li>
</ul>
<p>行进中运球（底线到三分线的距离来回）<br>Sham+双体前<br>胯下行进<br>背后行进<br>In n Out胯下体前<br>胯下+双背后<br>In N Out Crossover<br>双体前+胯下+双背后</p>
<ul>
<li>新手 努力尝试！</li>
<li>不熟的话可以先把动作慢慢做 熟悉后加快速率！</li>
<li>高手 尽全力 干！！</li>
</ul>
<p><strong>以下所有数字全部为要求 -进-球-数- ！</strong></p>
<p>篮筐底下投篮 10 （争取空心）<br>弧顶顺步突破抛投 左右各 8<br>弧顶试探步突破转身上篮 左右各5<br>右-突破胯下拉回跳投 5<br>右-突破胯下拉回变向拜佛 5 正向拜佛 5<br>左-突破胯下拉回跳投 5<br>左-突破胯下拉回变向拜佛 5 正向拜佛 5<br>*拜佛后的处理 自己选择！放大自己的想象力！各种各样的上篮！<br>罚球 3<br>认真对待每一个球！</p>
<p>面对挡拆的处理<br>-右侧-<br>过挡拆后直接投篮 5 （当防守者从挡拆后面绕）<br>过挡拆后犹豫步突破 5 （当补防大个没有及时防你）ps：突破后 各种上篮或抛投 自己选择<br>过挡拆前变向跳投 5 （当防守者自作聪明提前绕挡拆）<br>过挡拆后Split突破 5 （当补防者过于凶猛地扑你）ps：突破后的选择 自己发挥想象力！<br>过挡拆后后撤 胯下体前 8 （当对手选择直接换防）接下来跳投或突破 自己选择<br>-左侧-<br>过挡拆后直接投篮 5 （当防守者从挡拆后面绕）<br>过挡拆后犹豫步突破 5 （当补防大个没有及时防你）ps：突破后 各种上篮或抛投 自己选择<br>过挡拆前变向跳投 5 （当防守者自作聪明提前绕挡拆）<br>过挡拆后Split突破 5 （当补防者过于凶猛地扑你）ps：突破后的选择 自己发挥想象力！<br>过挡拆后后撤 胯下体前 8 （当对手选择直接换防）接下来跳投或突破 自己选择<br>罚球 3<br>在疲累的时候 罚球 更考验真本事！</p>
<p>推进<br>In n out Crossover 跳投 左右各 5<br>哈登步突破抛投 左右各 5<br>哈登步接胯下突破上篮 左右各 5<br>In n out 接急停跳投 左右各 8<br>*投篮射程按照自己的能力与需求定哦<br>罚球 5</p>
<h2 id="二-Good-Times"><a href="#二-Good-Times" class="headerlink" title="二. Good Times"></a>二. Good Times</h2><p>半场距离往返运球<br>-进攻+后退+胯下运球进攻<br>-行进间背后运球<br>-胯下突破背后拉回<br>-双变向Hesi胯下<br>-In n Out 背后运胯下拉回</p>
<p>胯下突破上篮 左右各 3<br>胯下突破抛投 左右各 3<br>顺步突破反篮 左右各 3 （可用诶诶步）<br>胯下hesi crossover 左右翼各 3 （变向要学会用眼神！）<br>双变向突破rondo假上篮 左右各 2<br>罚球 5</p>
<p>三威胁一次运球急停跳投 左右各 5<br>转身后12步急停跳投 左右各 5<br><em>自己定射程！根据自己的需求与能力</em><br>胯下Hesi急停跳投 左右各 5<br>胯下Hesi一次运球急停跳投 左右各 3<br>In n Out胯下12步急停跳投 左右各 3<br>胯下Hesi Crossover急停跳投 左右各 5<br>胯下紧接干拔 左右各 5<br>胯下突破背后拉回跳投 左右各 5<br>变向拜佛突破抛投 左右翼各 5<br>哈登步Crossover顿拜突破 左右各 3<br>超级后撤步 左右各 3<br>利拉德后撤步 左右各 5<br>IT突破接后撤步跳投 左右翼各 5<br>In n Out 一次运球急停跳投 左右翼各 5<br>In n Out 接拜佛突破 8<br>胯下加胯下后跳步跳投  5<br>罚球 10 </p>
<h2 id="三-Project-A"><a href="#三-Project-A" class="headerlink" title="三. Project A"></a>三. Project A</h2><p>双球 交替运50<br>双球 齐v字50<br>双球交替v字50<br>双球 齐侧v字50<br>双球交替侧v字50<br>单球 低运绕八字 100<br>单球 低运反绕八字 100<br>行进间 胯下变向 半场来回1次<br>行进间 背后变向 半场来回1次<br>行进间 体前变向 半场来回1次<br>行进间 in n out crossover 半场来回 1次<br>行进间 胯下+体前 半场来回1次<br>行进间 胯下+背后 半场来回1次<br>行进间 背后+背后 半场来回1次<br>5罚球<br>篮下miken训练<br>双脚正篮 10 反篮 10<br>单脚正篮 10 反篮 10<br>篮筐底下投篮（要求空心）10<br>弧顶持球<br>1次运球 急停跳投 左右各5<br>1次运球突破 背后拉回 跳投 左右各5<br>1次 运球突破 反胯下拉回 跳投 左右各5<br>胯下+体前crossover 跳投 左右各10<br>胯下+体前crossover 抛投 左右各8<br>哈登步突破上篮 左右各 5<br>哈登步急停跳投 左右各8</p>
<p>左右翼<br>半转身走底线突破上篮 左右各5<br>hesi 突破底线 背后拉回跳投 左右各5<br>双体前crossover 突破底线反篮 左右各5</p>
<p>In n out Crossover 跳投 左右各5<br>In n out Crossover 反胯下拉回 左右各5</p>
<p>左右翼Again<br>双体前crossover 抛投 左右各5<br>双体前 crossover 后撤步 左右各5<br>背后+体前crossover 跳投 左右各5<br>背后+体前crossover 突破欧洲步 左右各5<br>10罚球</p>
<ul>
<li>以上分别是ELITE、Good Times、PROJECT A 三个板块，不同的训练结构、动作、方法、技能，可以选择每天换一个板块练，也可以选择每周 或 每月换一个板块练，根据自己的水平与需求！</li>
<li>每一个板块的内容，是每一次训练（每天）需要完成的量，这是最理想的状态。</li>
<li>如若说一天完成不了 某板块里面规定的内容，可以根据自己的情况 分两天（最多三天）完成，挑战自己！克服困难！</li>
<li>训练过程中你会发现很多自己的不足，克服他们！保持稳定的训练！</li>
<li>假设说里面某个动作让你非常喜欢，你也完全可以加量练习它！</li>
<li>无论是哪个板块，争取每天都抽一个做一遍！或每周做四次以上！天道勤酬！</li>
</ul>
<p>Never Give Up！<br>When you put your heart and mind in to Anything, God will you help you achieve it.<br>与君共勉！</p>
<p><a target="_blank" rel="noopener" href="https://v.youku.com/v_show/id_XMzgwNzM1NjI5Mg==.html?spm=a2h3j.8428770.3416059.1">https://v.youku.com/v_show/id_XMzgwNzM1NjI5Mg==.html?spm=a2h3j.8428770.3416059.1</a></p>
<p>密码：thankyouGod<br>注意大小写<br>00:00 - 20:15 Elite<br>20:16 - 32:47 Good Times<br>32:48 - 50:40 Project A</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/intro/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/intro/">1</a><span class="page-number current">2</span><a class="page-number" href="/intro/page/3/">3</a><a class="extend next" rel="next" href="/intro/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">篮球架上打砖块</p>
  <div class="site-description" itemprop="description">Apodidae</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">篮球架上打砖块</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '[object Object]';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
